<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="Raven005">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="http://example.com/2024/11/11/operating-system-2/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
        <meta name="description" content="进程概念进程是动态的，是程序的一次执行过程，同一个程序多次执行会对应多个进程 组成 程序段、数据段、PCB三部分组成了进程的实体（进程映像）引入进程实体的概念后，可以把进程定义为：进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位  注意： PCB是进程存在的唯一标识  PCB当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的”身份证号” PID 操作系统要记录PID,进程所">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统02">
<meta property="og:url" content="http://example.com/2024/11/11/operating-system-2/index.html">
<meta property="og:site_name" content="Raven&#39;s blog">
<meta property="og:description" content="进程概念进程是动态的，是程序的一次执行过程，同一个程序多次执行会对应多个进程 组成 程序段、数据段、PCB三部分组成了进程的实体（进程映像）引入进程实体的概念后，可以把进程定义为：进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位  注意： PCB是进程存在的唯一标识  PCB当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的”身份证号” PID 操作系统要记录PID,进程所">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s2.loli.net/2024/11/11/ZFzQMLamHjBE7Ob.png">
<meta property="og:image" content="https://s2.loli.net/2024/11/11/9ZaJQ1iPj8C2VlA.png">
<meta property="og:image" content="https://s2.loli.net/2024/11/11/cfoRVUtBn3hQq7K.png">
<meta property="og:image" content="https://s2.loli.net/2024/10/13/eSvaALZ4ObCm8Uq.png">
<meta property="og:image" content="https://s2.loli.net/2024/10/19/qUKygHXkmvCuV9E.png">
<meta property="og:image" content="https://s2.loli.net/2024/10/19/BthUpkoEsmRxQDc.png">
<meta property="og:image" content="https://s2.loli.net/2024/10/19/2jDbBaEivdwr1Fy.png">
<meta property="og:image" content="https://s2.loli.net/2024/10/19/PHROKcFw2eoZ6Mz.png">
<meta property="og:image" content="https://s2.loli.net/2024/10/19/TNZQCUxvphPtOSk.png">
<meta property="og:image" content="https://s2.loli.net/2024/10/19/8oBOAwD32GZ9qN6.png">
<meta property="og:image" content="https://s2.loli.net/2024/10/19/t1ZHYzvU3Ob9Sh6.png">
<meta property="og:image" content="https://s2.loli.net/2024/11/02/Yj3DG4NtRFrImzf.png">
<meta property="og:image" content="https://s2.loli.net/2024/11/02/I3zMS9iCoHJnc6v.png">
<meta property="og:image" content="https://s2.loli.net/2024/11/02/ZuNwMVpD6YsLioq.png">
<meta property="og:image" content="https://s2.loli.net/2024/11/04/EbnIucekK2zmo6U.png">
<meta property="article:published_time" content="2024-11-11T14:40:06.000Z">
<meta property="article:modified_time" content="2025-03-13T08:18:29.569Z">
<meta property="article:author" content="Raven005">
<meta property="article:tag" content="408">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2024/11/11/ZFzQMLamHjBE7Ob.png">
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/head.svg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/head.svg">
    <meta name="theme-color" content="#7aa2f7">
    <link rel="shortcut icon" href="/images/head.svg">
    <!--- Page Info-->
    
    <title>
        
            操作系统02 | Raven&#39;s blog
        
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/assets/build/styles.css">

    

    
<link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css">

    
<link rel="stylesheet" href="/fonts/Geist/geist.css">

    <!--- Font Part-->
    
    
    
    
    
    
        
<script src="/js/libs/anime.min.js"></script>

    

    <script id="hexo-configurations">
    window.config = {"hostname":"example.com","root":"/","language":"en","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":true,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"vs2015"},"font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":3,"number":false,"expand":true,"init_open":true},"copyright":{"enable":false,"default":"cc_by_nc_sa"},"lazyload":true,"recommendation":{"enable":true,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/background_light.jpg","skip_dirs":[]}},"colors":{"primary":"#7aa2f7","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":true},"scroll_progress":{"bar":true,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":true,"open_graph":true,"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/background_light.jpg","dark":"/images/background_dark.jpg"},"title":"Raven's blog","subtitle":{"text":["coding is life"],"hitokoto":{"enable":false,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":true,"style":"default","links":{"github":"https://github.com/Encounter005","instagram":null,"zhihu":"https://www.zhihu.com/people/eznoob","twitter":null,"email":null},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":true,"version":"9.3.0"}},"version":"2.7.3","navbar":{"auto_hide":false,"color":{"left":"#7aa2f7","right":"#c0caf5","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"Archives":{"path":"/archives","icon":"fa-regular fa-archive"}},"search":{"enable":true,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"info","announcement":"不定期更新","show_on_mobile":true,"links":null},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2022/8/17 11:45:14"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/atom.xml" title="Raven's blog" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
<!--        <span class="swup-progress-icon">-->
<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
<!--        </span>-->
    
</div>



    <style>
    :root {
        --preloader-background-color: #fff;
        --preloader-text-color: #000;
    }

    @media (prefers-color-scheme: dark) {
        :root {
            --preloader-background-color: #202124;
            --preloader-text-color: #fff;
        }
    }

    @media (prefers-color-scheme: light) {
        :root {
            --preloader-background-color: #fff;
            --preloader-text-color: #000;
        }
    }

    @media (max-width: 600px) {
        .ml13 {
            font-size: 2.6rem !important; /* Adjust this value as needed */
        }
    }

    .preloader {
        display: flex;
        flex-direction: column;
        gap: 1rem; /* Tailwind 'gap-4' is 1rem */
        align-items: center;
        justify-content: center;
        position: fixed;
        padding: 12px;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        width: 100vw;
        height: 100vh; /* 'h-screen' is 100% of the viewport height */
        background-color: var(--preloader-background-color);
        z-index: 1100; /* 'z-[1100]' sets the z-index */
        transition: opacity 0.2s ease-in-out;
    }

    .ml13 {
        font-size: 3.2rem;
        /* text-transform: uppercase; */
        color: var(--preloader-text-color);
        letter-spacing: -1px;
        font-weight: 500;
        font-family: 'Chillax-Variable', sans-serif;
        text-align: center;
    }

    .ml13 .word {
        display: inline-flex;
        flex-wrap: wrap;
        white-space: nowrap;
    }

    .ml13 .letter {
        display: inline-block;
        line-height: 1em;
    }
</style>

<div class="preloader">
    <h2 class="ml13">
        Raven&#39;s blog
    </h2>
    <script>
        var textWrapper = document.querySelector('.ml13');
        // Split text into words
        var words = textWrapper.textContent.trim().split(' ');

        // Clear the existing content
        textWrapper.innerHTML = '';

        // Wrap each word and its letters in spans
        words.forEach(function(word) {
            var wordSpan = document.createElement('span');
            wordSpan.classList.add('word');
            wordSpan.innerHTML = word.replace(/\S/g, "<span class='letter'>$&</span>");
            textWrapper.appendChild(wordSpan);
            textWrapper.appendChild(document.createTextNode(' ')); // Add space between words
        });

        var animation = anime.timeline({ loop: true })
            .add({
                targets: '.ml13 .letter',
                translateY: [20, 0],
                translateZ: 0,
                opacity: [0, 1],
                filter: ['blur(5px)', 'blur(0px)'],
                easing: "easeOutExpo",
                duration: 1200,
                delay: (el, i) => 300 + 20 * i,
            })
            .add({
                targets: '.ml13 .letter',
                translateY: [0, -20],
                opacity: [1, 0],
                filter: ['blur(0px)', 'blur(5px)'],
                easing: "easeInExpo",
                duration: 1000,
                delay: (el, i) => 15 * i,
                complete: function() {
                    hidePreloader();
                }
            }, '-=700');


        let themeStatus = JSON.parse(localStorage.getItem('REDEFINE-THEME-STATUS'))?.isDark;

        // If the theme status is not found in local storage, check the preferred color scheme
        if (themeStatus === undefined || themeStatus === null) {
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                themeStatus = 'dark';
            } else {
                themeStatus = 'light';
            }
        }

        // Now you can use the themeStatus variable in your code
        if (themeStatus) {
            document.documentElement.style.setProperty('--preloader-background-color', '#202124');
            document.documentElement.style.setProperty('--preloader-text-color', '#fff');
        } else {
            document.documentElement.style.setProperty('--preloader-background-color', '#fff');
            document.documentElement.style.setProperty('--preloader-text-color', '#000');
        }

        window.addEventListener('load', function () {
            setTimeout(hidePreloader, 5000); // Call hidePreloader after 5000 milliseconds if not already called by animation
        });

        function hidePreloader() {
            var preloader = document.querySelector('.preloader');
            preloader.style.opacity = '0';
            setTimeout(function () {
                preloader.style.display = 'none';
            }, 200);
        }
    </script>
</div>

<main class="page-container" id="swup">

    

    <div class="main-content-container flex flex-col justify-between min-h-dvh">


        <div class="main-content-header">
            <header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
                <a class="logo-image h-8 w-8 sm:w-10 sm:h-10 mr-3" href="/">
                    <img src="/images/head.svg" class="w-full h-full rounded-sm">
                </a>
            
            <a class="logo-title" href="/">
                
                Raven&#39;s blog
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/archives"
                                        >
                                    <i class="fa-regular fa-archive fa-fw"></i>
                                    ARCHIVES
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/archives"
                        >
                            <span>
                                ARCHIVES
                            </span>
                            
                                <i class="fa-regular fa-archive fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            

            
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">19</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">4</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">31</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="main-content-body">

            

            <div class="main-content">

                
                    <div class="post-page-container flex relative justify-between box-border w-full h-full">
    <div class="article-content-container">

        <div class="article-title relative w-full">
            
                <div class="w-full flex items-center pt-6 justify-start">
                    <h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">操作系统02</h1>
                </div>
            
            </div>

        
            <div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
                <div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
                    <img src="/images/head.svg">
                </div>
                <div class="info flex flex-col justify-between">
                    <div class="author flex items-center">
                        <span class="name text-default-text-color text-lg font-semibold">Raven005</span>
                        
                            <span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv3</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2024-11-11 22:40:06</span>
        <span class="mobile">2024-11-11 22:40:06</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2025-03-13 16:18:29</span>
            <span class="mobile">2025-03-13 16:18:29</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/%E8%80%83%E7%A0%94/">考研</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/408/">408</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fa-regular fa-typewriter"></i>&nbsp;<span>13.3k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fa-regular fa-clock"></i>&nbsp;<span>48 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        


        <div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
            <h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>进程是动态的，是程序的一次执行过程，同一个程序多次执行会对应多个进程</p>
<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2024/11/11/ZFzQMLamHjBE7Ob.png" alt="进程的组成.png"></p>
<p>程序段、数据段、PCB三部分组成了进程的实体（进程映像）<br>引入进程实体的概念后，可以把进程定义为：<br>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位</p>
<blockquote>
<p>注意： <code>PCB是进程存在的唯一标识</code></p>
</blockquote>
<h3 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h3><p>当进程被创建时，操作系统会为该进程分配一个<strong>唯一的、不重复</strong>的”身份证号” PID</p>
<p>操作系统要记录PID,进程所属用户ID，还要记录给进程分配了哪些资源、进程的运行情况<br>这些信息都被保存在一个数据结构<code>PCB</code>,即进程控制块，操作系统需要对各个并发运行的进程进行管理，<code>但凡管理时所需要的信息，都会被放在PCB中</code></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2024/11/11/9ZaJQ1iPj8C2VlA.png" alt="PCB.png"></p>
<h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2024/11/11/cfoRVUtBn3hQq7K.png" alt="进程的特征.png"></p>
<p>程序是静态的，进程是动态的，动态性是进程最基本的特征</p>
<h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><pre class="mermaid">flowchart TD
    A[创建态] --&gt;|系统完成创建进程的一系列工作| B[就绪态] --&gt;|进程被调度| C[运行态] --&gt;|进程运行结束,或者运行过程中遇到不可修复的错误| D[终止态]
    C --&gt;|进程用'系统调用'的方式申请某种系统资源,或者请求等待某个事件发生 | E[阻塞态]
    E --&gt;|申请的资源被分配,或等待某个事件发生| B
    C --&gt;|时间片到,或处理机被抢占| B
    B --&gt;|挂起| F[就绪挂起]
    F --&gt;|激活| B
    E --&gt;|挂起| G[阻塞挂起]
    G --&gt;|激活| E
    A --&gt; F
    G --&gt;|事件出现| F
    C --&gt; F</pre>

<p>运行态–&gt;到阻塞态是一种进程自身作出的主动行为<br>阻塞态–&gt;就绪态是不是进程自身能控制的，是一种被动行为</p>
<blockquote>
<p>注意:</p>
<ul>
<li>不能由阻塞态直接转换为运行态，也不能由就绪态直接转换为阻塞态(<code>因为进入阻塞态是进程主动请求的，必然需要进程在运行时才能发出这种请求</code>)</li>
<li>“挂起”和“阻塞”的区别，两种状态都是暂时不能获得CPU的服务，但挂起态是将进程映像调到外存去了，而阻塞态下进程映像还在内存中</li>
</ul>
</blockquote>
<h3 id="创建态"><a href="#创建态" class="headerlink" title="创建态"></a>创建态</h3><p>进程正在被创建时，它的状态是<code>创建态</code>，在这个阶段操作系统会为进程分配资源、初始化PCB</p>
<h3 id="就绪态"><a href="#就绪态" class="headerlink" title="就绪态"></a>就绪态</h3><p>当进程被创建完成后，便进入<code>就绪态</code>，处于就绪态的进程已经具备运行条件，但由于没有空闲CPU,就暂时不能运行</p>
<h3 id="运行态"><a href="#运行态" class="headerlink" title="运行态"></a>运行态</h3><p>如果一个进程此时在CPU上运行，那么这个进程处于<code>运行态</code></p>
<h3 id="阻塞态"><a href="#阻塞态" class="headerlink" title="阻塞态"></a>阻塞态</h3><p>在进程运行的过程中，可能会请求等待某个时间的发生(如等待某种系统资源分配，或者等待其他进程的响应)，在这个事件发生之前，进程无法继续往下执行，此时操作系统会让这个进程下CPU,并让他进入<code>阻塞态</code><br>当CPU空闲时，又会选择另一个<code>就绪态</code>进程上CPU运行</p>
<h3 id="终止态"><a href="#终止态" class="headerlink" title="终止态"></a>终止态</h3><p>一个进程可以执行exit系统调用，请求操作系统终止该进程，此时该进程会进入<code>终止态</code>，操作系统会让该进程下CPU,并回收内存空间等资源，最后还要回收该进程的PCB</p>
<h2 id="进程的组织方式"><a href="#进程的组织方式" class="headerlink" title="进程的组织方式"></a>进程的组织方式</h2><h3 id="链式方式"><a href="#链式方式" class="headerlink" title="链式方式"></a>链式方式</h3><ul>
<li>按照进程状态将PCB分为多个队列</li>
<li>操作系统持有指向各个队列的指针</li>
</ul>
<h3 id="索引方式"><a href="#索引方式" class="headerlink" title="索引方式"></a>索引方式</h3><ul>
<li>根据进程状态的不同，建立几张索引表</li>
<li>操作系统持有指向各个索引表的指针</li>
</ul>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="原语"><a href="#原语" class="headerlink" title="原语"></a>原语</h3><p>原语是一种特殊的程序，它的执行具有原自行。也就是说这段程序的运行必须一气呵成，不可中断</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>可以用“关中断指令”和“开中断指令”实现原子性</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2024/10/13/eSvaALZ4ObCm8Uq.png" alt="原子性.png"></p>
<h3 id="进程控制相关原语"><a href="#进程控制相关原语" class="headerlink" title="进程控制相关原语"></a>进程控制相关原语</h3><h4 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h4><ol>
<li><p>创建原语</p>
<ul>
<li>申请空白PCB</li>
<li>为新进程分配所需资源</li>
<li>初始化PCB</li>
<li>将PCB插入就绪队列 创建态–&gt;就绪态</li>
</ul>
</li>
<li><p>引起进程创建的事件</p>
<ul>
<li>用户登录<ul>
<li>分时系统中，用户登录成功，系统会为其建立一个新进程</li>
<li>作业调度，多道批处理系统，有新的作业放入内存时，会为其建立一个新的进程</li>
<li>提供服务，用户向操作系统提出某些请求时，会新建一个进程处理该请求</li>
<li>应用请求，由用户进程主动请求创建一个子进程</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h4><ol>
<li><p>撤销原语</p>
<ul>
<li>从PCB集合中找到终止进程的PCB</li>
<li>若进程正在运行，立即剥夺CPU,将CPU分配给其他进程</li>
<li>终止其所有子进程</li>
<li>将该进程拥有的所有资源归还给父进程或操作系统</li>
</ul>
</li>
<li><p>引起进程终止的事件</p>
<ul>
<li>正常结束</li>
<li>异常结束</li>
<li>外界干预</li>
</ul>
</li>
</ol>
<h4 id="进程阻塞"><a href="#进程阻塞" class="headerlink" title="进程阻塞"></a>进程阻塞</h4><ol>
<li><p>进程的阻塞</p>
<ul>
<li>阻塞原语 运行态–&gt;阻塞态<ul>
<li>找到要阻塞的进程对应PCB</li>
<li>保护进程运行现场，将PCB状态信息设置为“阻塞态”，展示停止进程运行</li>
<li>将PCB插入相应事件的等待队列</li>
</ul>
</li>
<li>引起进程阻塞的事件<ul>
<li>需要等待系统分配某种资源</li>
<li>需要等待相互合作的其他进程完成工作</li>
</ul>
</li>
</ul>
</li>
<li><p>进程的唤醒</p>
<ul>
<li>唤醒原语<ul>
<li>在事件等待队列中找到PCB</li>
<li>将PCB从等待队列中移除，设置进程为就绪态</li>
<li>将PCB插入就绪队列，等待被调度</li>
</ul>
</li>
<li>引起进程唤醒的事件<ul>
<li>等待事件的发生</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h4><ol>
<li>切换原语<ul>
<li>将运行环境信息存入PCB</li>
<li>PCB移入相应队列</li>
<li>选择另一个进程执行，并更新其PCB</li>
<li>根据PCB恢复新进程所需的运行环境</li>
</ul>
</li>
<li>引起进程切换的事件<ul>
<li>当前进程时间片到</li>
<li>有更高优先级的进程到达</li>
<li>当前进程主动阻塞</li>
<li>当前进程终止</li>
</ul>
</li>
</ol>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><h3 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h3><ul>
<li>基于数据结构的共享: 比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种<strong>低级通信方式</strong></li>
<li>基于存储区的共享: 操作系统在内存中划出一块共享存储区，数据的形式、存放位置都由通信进程控制，而不是操作系统。这种共享方式速度很快，是一种<strong>高级通信方式</strong></li>
</ul>
<h3 id="消息通信"><a href="#消息通信" class="headerlink" title="消息通信"></a>消息通信</h3><ul>
<li>直接通信方式</li>
</ul>
<p>消息传送进程要指明接受进程的ID</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2024/10/19/qUKygHXkmvCuV9E.png" alt="直接通信.png"></p>
<ul>
<li>间接通信方式</li>
</ul>
<p>通过“信箱”间接的通信。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2024/10/19/BthUpkoEsmRxQDc.png" alt="间接通信.png"></p>
<h3 id="管道通信（循环队列）"><a href="#管道通信（循环队列）" class="headerlink" title="管道通信（循环队列）"></a>管道通信（循环队列）</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2024/10/19/2jDbBaEivdwr1Fy.png" alt="管道通信.png"></p>
<p>管道通信和共享存储在于管道通信的读写都是先进先出的</p>
<ol>
<li><p>管道只能采用<strong>半双工通信</strong>，某一之间段内只能采用半双工通信，某一时间段内只能实现单向的传输。如果要实现<strong>双向同时通信</strong>，则<strong>需要设置两个管道</strong></p>
</li>
<li><p>各进程要互斥访问管道（由操作系统实现）</p>
</li>
<li><p>当<strong>管道写满</strong>时，<strong>写进程</strong>将<strong>阻塞</strong>，知道读进程将管道中的数据取走，即可唤醒写进程</p>
</li>
<li><p>当<strong>管道读空</strong>时，<strong>读进程</strong>将<strong>阻塞</strong>，知道写进程往管道写入数据，即可唤醒读进程</p>
</li>
<li><p>管道中的数据一旦被读出，就彻底消失。因此，当多个进程读同一个管道时，可能会错乱。对此，通常有两种解决方案</p>
<ol>
<li><strong>一个管道允许多个写进程，一个读进程</strong></li>
<li>允许有<strong>多个写进程，多个读进程</strong>，但系统会让各个读进程轮流从管道中读数据(linux)</li>
</ol>
</li>
</ol>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h3><p>线程是一个基本的CPU执行单元，也是程序执行流的最小单位</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul>
<li>线程是处理机调度的基本单位</li>
<li>多CPU计算机中，各个县城可占用不同的CPU</li>
<li>每个线程都有一个线程ID、线程控制块(TCB)</li>
<li>线程也有就绪、阻塞、运行三种基本状态</li>
<li>线程几乎不拥有系统资源</li>
<li>同一进程的不同线程间共享进程的资源</li>
<li>由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预</li>
<li>同一进程中的线程切换，不会引起进程切换</li>
<li>不同进程中的线程切换，会引起进程切换</li>
<li>切换同进程内的线程，系统开销很小</li>
<li>切换进程，系统开销比较大</li>
</ul>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><h4 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2024/10/19/PHROKcFw2eoZ6Mz.png" alt="用户级线程.png"></p>
<h4 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a>内核级线程</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2024/10/19/TNZQCUxvphPtOSk.png" alt="内核级线程.png"></p>
<h3 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h3><h4 id="一对一模型"><a href="#一对一模型" class="headerlink" title="一对一模型"></a>一对一模型</h4><p>每个用户级线程都对应一个内核级线程</p>
<ul>
<li><p>优点</p>
<ul>
<li><strong>提高了并发性</strong>：当一个线程进行阻塞系统调用时，其他线程可以继续执行。</li>
<li><strong>更好的并行性</strong>：在多处理器架构中，多线程可在多核处理机上并行执行。</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li><strong>资源消耗较高</strong>：由于每个用户级线程都需要一个内核级线程来对应，这可能会增加系统的开销和复杂度。</li>
</ul>
</li>
</ul>
<h4 id="多对一模型"><a href="#多对一模型" class="headerlink" title="多对一模型"></a>多对一模型</h4><p>在多线程的多对一模型中，多个用户级线程被映射到一个内核级线程上,且一个进程只被分配一个内核级线程上</p>
<ul>
<li><p>优点</p>
<ul>
<li><strong>资源管理效率高</strong>：由于线程管理主要由用户空间的线程库处理，不需要切换到核心态，这使得该模型相对高效。</li>
<li><strong>减少开销</strong>：与一对一模型相比，多对一模型减少了内核级别的上下文切换次数，从而降低了系统开销。</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li><strong>资源竞争严重</strong>：当一个用户级线程进行阻塞系统调用时，所有其他用户级线程都会被阻塞。</li>
</ul>
</li>
</ul>
<h4 id="多对多模型"><a href="#多对多模型" class="headerlink" title="多对多模型"></a>多对多模型</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2024/10/19/8oBOAwD32GZ9qN6.png" alt="多对多模型.png"></p>
<h3 id="线程状态与转换"><a href="#线程状态与转换" class="headerlink" title="线程状态与转换"></a>线程状态与转换</h3><pre class="mermaid">flowchart TD
A[就绪] --&gt;|被调度程序选中| B[运行]
B --&gt;|时间用完| A
B --&gt;|等待某事件| C[阻塞]
C --&gt;|等待的事件发生| A</pre>

<h3 id="线程的组织与控制"><a href="#线程的组织与控制" class="headerlink" title="线程的组织与控制"></a>线程的组织与控制</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2024/10/19/t1ZHYzvU3Ob9Sh6.png" alt="线程的组织与控制.png"></p>
<h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>调度器通过选择就绪队列中的一个进程并将其分配给CPU来实现这一目标。这使得多个进程能够在有限的硬件资源下并发执行，从而提高系统的整体性能和响应速度</p>
<ul>
<li><p><strong>分类与层次</strong>：调度可以根据不同的标准进行分类，通常分为三个层次：</p>
<ul>
<li><strong>高级调度（作业调度）</strong>：决定哪些作业或任务被加载到系统中。</li>
<li><strong>中级调度（内存调度）</strong>：管理进程在主存中的驻留和交换。</li>
<li><strong>低级调度（进程调度或时间片轮转）</strong>：决定当前CPU时间片由哪个进程使用</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>调度类别</th>
<th>要做什么</th>
<th>发生地</th>
<th>发生频率</th>
<th>对进程状态的影响</th>
</tr>
</thead>
<tbody><tr>
<td>高级调度(作业调度)</td>
<td>按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程</td>
<td>外存-&gt;内存(面向作业)</td>
<td>最低</td>
<td>无-&gt;创建态-&gt;就绪态</td>
</tr>
<tr>
<td>中级调度(内存调度)</td>
<td>按照某种规则，从挂起队列中选择合适的进程将其数据回调内存</td>
<td>外存-&gt;内存(面向进程)</td>
<td>中等</td>
<td>挂起态-&gt;就绪态(阻塞挂起-&gt;阻塞态)</td>
</tr>
<tr>
<td>低级调度(进程调度)</td>
<td>按照某种规则，从就绪队列中选择一个进程为其分配处理机</td>
<td>内存-&gt;CPU</td>
<td>最高</td>
<td>就绪态-&gt;运行态</td>
</tr>
</tbody></table>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><p>进程调度（低级调度）就是按照某种算法从就绪队列中选择一个进程为其分配进程</p>
<h3 id="时机"><a href="#时机" class="headerlink" title="时机"></a>时机</h3><p>需要进行进程调度与切换的情况</p>
<ul>
<li><p>当前运行的进程<code>主动放弃</code>处理机</p>
<ul>
<li>进程正常终止</li>
<li>运行过程中发生异常</li>
<li>进程主动请求阻塞</li>
</ul>
</li>
<li><p>当前运行的进程<code>被动放</code>弃处理机</p>
<ul>
<li>分给进程的时间片用完</li>
<li>有更紧急的事需要处理(I/O中断)</li>
<li>有更高优先级的进程进入就绪队列</li>
</ul>
</li>
<li><p>不能进行进程调度与切换情况</p>
<ul>
<li>在处理中断的过程中</li>
<li>进程在操作系统内核临界区中,但是进程在普通临界区中是可以进行调度、切换的</li>
<li>在原子操作过程中。原子操作不可中断，要一气呵成</li>
</ul>
</li>
</ul>
<h2 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h2><p>非剥夺调度方式(非抢占式)</p>
<ul>
<li>一旦某个进程获得了CPU的控制权，它就会一直运行，直到该进程主动放弃CPU（例如，因为等待I/O操作完成或因为进程结束）。在此期间，即使有更高优先级的进程到达，也不会中断当前进程的执行。</li>
</ul>
<p>剥夺调度式(抢占方式)</p>
<ul>
<li>指操作系统可以在任何时刻中断当前正在运行的进程，并将CPU分配给另一个进程。这种中断通常发生在时间片用完、更高优先级的进程到达或某些特定事件发生时。</li>
</ul>
<h2 id="切换与过程"><a href="#切换与过程" class="headerlink" title="切换与过程"></a>切换与过程</h2><blockquote>
<p>注意<br>频繁的进程调度、切换会让整个操作系统效率降低，使系统大部分时间都花在进程切换上，属于进程执行的时间减少了</p>
</blockquote>
<h3 id="切换"><a href="#切换" class="headerlink" title="切换"></a>切换</h3><p>“狭义的进程调度”与“进程切换的区别”</p>
<ul>
<li>狭义的进程调度指的是从就绪队列中选中一个要运行的进程</li>
<li>进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程</li>
</ul>
<p>“广义的进程调度”包含了选择一个进程和进程切换两个步骤</p>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>进程的切换主要完成:</p>
<ul>
<li>对原来运行进程各种数据的保存</li>
<li>对新的进程各种数据的恢复</li>
</ul>
<h2 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a>调度算法的评价指标</h2><h3 id="CPU利用率"><a href="#CPU利用率" class="headerlink" title="CPU利用率"></a>CPU利用率</h3><p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -2.059ex;" xmlns="http://www.w3.org/2000/svg" width="19.85ex" height="5.285ex" role="img" focusable="false" viewBox="0 -1426 8773.6 2336"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">利</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">用</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">率</text></g></g><g data-mml-node="mo" transform="translate(3277.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(4333.6,0)"><g data-mml-node="mrow" transform="translate(220,676)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">忙</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">绿</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g></g><g data-mml-node="mrow" transform="translate(720,-710)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">总</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g></g><rect width="4200" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container></p>
<h3 id="系统吞吐量"><a href="#系统吞吐量" class="headerlink" title="系统吞吐量"></a>系统吞吐量</h3><p>单位时间内完成的作业数量</p>
<p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -2.059ex;" xmlns="http://www.w3.org/2000/svg" width="37.949ex" height="5.285ex" role="img" focusable="false" viewBox="0 -1426 16773.6 2336"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">系</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">统</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">吞</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">吐</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">量</text></g></g><g data-mml-node="mo" transform="translate(5277.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(6333.6,0)"><g data-mml-node="mrow" transform="translate(220,676)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">总</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">共</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">完</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">成</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">了</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">多</text></g><g data-mml-node="mi" transform="translate(6000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">少</text></g><g data-mml-node="mi" transform="translate(7000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">道</text></g><g data-mml-node="mi" transform="translate(8000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">作</text></g><g data-mml-node="mi" transform="translate(9000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">业</text></g></g><g data-mml-node="mrow" transform="translate(1220,-710)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">总</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">共</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">花</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">了</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">多</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">少</text></g><g data-mml-node="mi" transform="translate(6000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(7000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g></g><rect width="10200" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container></p>
<h3 id="周转时间"><a href="#周转时间" class="headerlink" title="周转时间"></a>周转时间</h3><p>从作业被提交给系统开始，到作业完成为止的这段时间间隔</p>
<p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="48.267ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 21334 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(389,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">作</text></g><g data-mml-node="mi" transform="translate(1389,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">业</text></g><g data-mml-node="mo" transform="translate(2389,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(2778,0)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">周</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">转</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g></g><g data-mml-node="mo" transform="translate(7055.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(8111.6,0)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">作</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">业</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">完</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">成</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g></g><g data-mml-node="mo" transform="translate(14333.8,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(15334,0)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">作</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">业</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">提</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">交</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g></g></g></g></svg></mjx-container></p>
<p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -2.059ex;" xmlns="http://www.w3.org/2000/svg" width="37.949ex" height="5.285ex" role="img" focusable="false" viewBox="0 -1426 16773.6 2336"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">平</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">均</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">周</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">转</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g></g><g data-mml-node="mo" transform="translate(6277.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(7333.6,0)"><g data-mml-node="mrow" transform="translate(220,676)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">各</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">作</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">业</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">周</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">转</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(6000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g><g data-mml-node="mi" transform="translate(7000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">之</text></g><g data-mml-node="mi" transform="translate(8000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">和</text></g></g><g data-mml-node="mrow" transform="translate(3220,-710)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">作</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">业</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">数</text></g></g><rect width="9200" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container></p>
<p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -2.059ex;" xmlns="http://www.w3.org/2000/svg" width="69.614ex" height="5.285ex" role="img" focusable="false" viewBox="0 -1426 30769.6 2336"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">带</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">权</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">周</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">转</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g><g data-mml-node="mo" transform="translate(6277.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(7333.6,0)"><g data-mml-node="mrow" transform="translate(1220,676)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">作</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">业</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">周</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">转</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g></g><g data-mml-node="mrow" transform="translate(220,-710)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">作</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">业</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">实</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">际</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">运</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">行</text></g><g data-mml-node="mi" transform="translate(6000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(7000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g></g><rect width="8200" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(16051.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(17107.1,0)"><g data-mml-node="mrow" transform="translate(220,676)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">作</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">业</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">完</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">成</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g><g data-mml-node="mo" transform="translate(6222.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(7222.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">作</text></g><g data-mml-node="mi" transform="translate(8222.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">业</text></g><g data-mml-node="mi" transform="translate(9222.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">提</text></g><g data-mml-node="mi" transform="translate(10222.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">交</text></g><g data-mml-node="mi" transform="translate(11222.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(12222.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g></g><g data-mml-node="mrow" transform="translate(2831.2,-710)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">作</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">业</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">实</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">际</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">运</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">行</text></g><g data-mml-node="mi" transform="translate(6000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(7000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g></g><rect width="13422.4" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container></p>
<blockquote>
<p>注意<br>带权周转时间必然&gt;=1</p>
</blockquote>
<p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -2.059ex;" xmlns="http://www.w3.org/2000/svg" width="46.999ex" height="5.285ex" role="img" focusable="false" viewBox="0 -1426 20773.6 2336"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">平</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">均</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">带</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">权</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">周</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">转</text></g><g data-mml-node="mi" transform="translate(6000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(7000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g><g data-mml-node="mo" transform="translate(8277.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(9333.6,0)"><g data-mml-node="mrow" transform="translate(220,676)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">各</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">作</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">业</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">带</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">权</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">周</text></g><g data-mml-node="mi" transform="translate(6000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">转</text></g><g data-mml-node="mi" transform="translate(7000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(8000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g><g data-mml-node="mi" transform="translate(9000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">之</text></g><g data-mml-node="mi" transform="translate(10000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">和</text></g></g><g data-mml-node="mrow" transform="translate(4220,-710)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">作</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">业</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">数</text></g></g><rect width="11200" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container></p>
<h3 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h3><p>从用户提交请求到首次产生响应的时间</p>
<h2 id="进程同步和互斥"><a href="#进程同步和互斥" class="headerlink" title="进程同步和互斥"></a>进程同步和互斥</h2><h4 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h4><p>同步也叫直接制约关系，是指为完成某种任务而建立的两个或多个进程，这些进程是因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作</p>
<h4 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h4><p>我们把<code>一个时间段内只允许一个进程</code>使用的资源叫做<code>临界资源</code><br>进程互斥是指当一个进程访问某个临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源</p>
<p>对进程的互斥访问:</p>
<ul>
<li>进入区：负责检查是否可进入临界区，若可进入，则设置”正在访问临界资源标志”</li>
<li>临界区：访问临界资源的那段代码</li>
<li>退出区：负责解除“正在访问临界资源的标志”（解锁）</li>
<li>剩余区：其他处理</li>
</ul>
<blockquote>
<p>注意</p>
<ul>
<li>临界区是进程中访问临界资源的代码段</li>
<li>进入区和退出区是负责实现互斥的代码段</li>
<li>临界区可称为”临界段”</li>
</ul>
</blockquote>
<p>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则:</p>
<ol>
<li>空闲让进: 临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区</li>
<li>忙则等待: 当已有进程进入临界区时，其他试图进入临界区的进程必须等待</li>
<li>有限等待: 对请求访问的进程，应保证能在有限时间内进入临界区</li>
<li>让权等待: 当进程不能进入临界区，应立即释放处理机，防止进程忙等待</li>
</ol>
<h4 id="进程互斥的软件实现方法"><a href="#进程互斥的软件实现方法" class="headerlink" title="进程互斥的软件实现方法"></a>进程互斥的软件实现方法</h4><h5 id="单步标志法"><a href="#单步标志法" class="headerlink" title="单步标志法"></a>单步标志法</h5><p>单标志法的算法思想是：两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予。具体实现过程如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> turn = <span class="number">0</span>; <span class="comment">//表示当前允许进入临界区的进程号</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P1</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">while</span>(turn != <span class="number">0</span>) { <span class="comment">// 进入区</span></span><br><span class="line">        <span class="comment">// critical section 临界区</span></span><br><span class="line">        turn = <span class="number">1</span>; <span class="comment">// 退出区</span></span><br><span class="line">        <span class="comment">// remainder seciont  剩余区</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P2</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">while</span>(turn != <span class="number">1</span>) {</span><br><span class="line">        <span class="comment">// critical section</span></span><br><span class="line">        turn = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// remainder seciont</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>对于turn表示当前允许进入临界区的进程号，而只有当前允许进入临界区的进程在访问了临界区之后，才会修改turn的值。也就是说，对于临界区的访问，一定是按p0→p1→p0→p1…这样轮流访问。</p>
<p>这种必须轮流访问带来的问题是，如果此时允许进入临界区的进程是P0，而P0一直不访问临界区，那么虽然此时临界区空闲，但是并不允许P1访问。因此对于单标志法，其违背了空闲让进的原则。</p>
<h5 id="双标志先检查法"><a href="#双标志先检查法" class="headerlink" title="双标志先检查法"></a>双标志先检查法</h5><p>双标志先检查法的算法思想是：设置一个布尔型数组flag[]，数组中各个元素用来标记各进程想进入临界区的意愿，比如flag[0] = true意味着0号进程p0现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志flag[i]设为true，之后开始访问临界区。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>] = {<span class="literal">false</span>, <span class="literal">false</span>};</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P1</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">while</span>(flag[<span class="number">1</span>] );  <span class="comment">// 1</span></span><br><span class="line">    flag[<span class="number">0</span>] = <span class="literal">true</span>; <span class="comment">// 2</span></span><br><span class="line">    <span class="comment">//critical section // 3</span></span><br><span class="line">    flag[<span class="number">0</span>] = <span class="literal">false</span>; <span class="comment">// 4</span></span><br><span class="line">    <span class="comment">//remainder section</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P2</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">while</span>(flag[<span class="number">0</span>]); <span class="comment">// 5</span></span><br><span class="line">    flag[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 6</span></span><br><span class="line">    <span class="comment">//critical section // 7</span></span><br><span class="line">    flag[<span class="number">1</span>] = <span class="literal">false</span>; <span class="comment">// 8</span></span><br><span class="line">    <span class="comment">//remainder section</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>需要注意的是，如果按照152637的顺序执行，p0和p1将会同时访问临界区。因此对于双标志先检查法，其违背了忙则等待的原则。</p>
<p>之所以造成这种问题，就是因为进入区的检查和上锁不是原子操作，在检查完的下一步还没上锁很有可能发生其他事件。</p>
<h5 id="双标志后检查法"><a href="#双标志后检查法" class="headerlink" title="双标志后检查法"></a>双标志后检查法</h5><p>双标志后检查法的思想是：既然先检查后上锁不行，那我就先上锁，然后在检查。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>] = {<span class="literal">false</span>, <span class="literal">false</span>};</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P0</span><span class="params">()</span> {</span><br><span class="line">    flag[<span class="number">0</span>] = <span class="literal">true</span>; <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">while</span>(flag[<span class="number">1</span>]); <span class="comment">// 2</span></span><br><span class="line">    <span class="comment">//critical section // 3</span></span><br><span class="line">    flag[<span class="number">0</span>] = <span class="literal">false</span>; <span class="comment">// 4</span></span><br><span class="line">    <span class="comment">//remainder section</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P1</span><span class="params">()</span> {</span><br><span class="line">    flag[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 5</span></span><br><span class="line">    <span class="keyword">while</span>(flag[<span class="number">0</span>]); <span class="comment">// 6</span></span><br><span class="line">    <span class="comment">//critical section // 7</span></span><br><span class="line">    flag[<span class="number">1</span>] = <span class="literal">false</span>; <span class="comment">// 8</span></span><br><span class="line">    <span class="comment">//remainder section</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>需要注意的是，如果按照1526的顺序执行，p0和p1将都无法进入临界区。</p>
<p>因此双标志后检查法虽然解决了忙则等待的问题，但是又违背了空闲让进和有限等待原则，因为如果各进程都长期无法访问临界资源会产生饥饿现象。</p>
<h5 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h5><p>在双标志后检查法中，两个进程都争着想进入临界区，但是谁也不让谁，既然这样，那只需要有人礼让即可解决问题。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>] = {<span class="literal">false</span>, <span class="literal">false</span>};</span><br><span class="line"><span class="type">int</span> turn = <span class="number">0</span>; <span class="comment">// 表示优先让哪个进程进入临界区</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P0</span><span class="params">()</span> {</span><br><span class="line">    flag[<span class="number">0</span>] = <span class="literal">true</span>; <span class="comment">// 1</span></span><br><span class="line">    turn = <span class="number">1</span>; <span class="comment">// 2  可以让对方先进入临界区</span></span><br><span class="line">    <span class="keyword">while</span>(flag[<span class="number">1</span>] &amp;&amp; turn == <span class="number">1</span>); <span class="comment">// 3</span></span><br><span class="line">    <span class="comment">//critical section // 4</span></span><br><span class="line">    flag[<span class="number">0</span>] = <span class="literal">false</span>; <span class="comment">// 5</span></span><br><span class="line">    <span class="comment">//remainder section</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P1</span><span class="params">()</span> {</span><br><span class="line">    flag[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 6</span></span><br><span class="line">    turn = <span class="number">0</span>; <span class="comment">// 7</span></span><br><span class="line">    <span class="keyword">while</span>(flag[<span class="number">0</span>] &amp;&amp; turn == <span class="number">0</span>); <span class="comment">// 8</span></span><br><span class="line">    <span class="comment">//critical section // 9</span></span><br><span class="line">    flag[<span class="number">1</span>] = <span class="literal">false</span>; <span class="comment">// 10</span></span><br><span class="line">    <span class="comment">//remainder section</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>如果按照123678的顺序，则相当于串行执行，这种方式肯定可以执行。</p>
<p>如果按照162378的顺序，那么进程0表明自己想进入临界区，进程1表明自己想进入临界区，回到2步骤，0进程表示愿意先让给1进程执行，然后在检查1也有意愿进入临界区和自己已经让位的情况下，自己处于等待状态。这时候回到7步骤，1号进程也表示自己愿意先让给0进程执行，然后在检查0也有意愿进入临界区和自己已经让位的情况下，自己也处于等待状态。此时回到步骤3，0号进程发现turn被修改为0了，说明自己可以不用等待让位了，先行一步作为后回到步骤8，进程P1也顺利做完了。</p>
<p>尽管Peterson算法用软件方法解决了进程互斥问题，遵循了空闲让进、忙则等待、有限等待三个原则，但是依然未遵循让权等待原则。但是相较于前面三种算法，其本身已然是最好</p>
<h4 id="进程互斥的硬件实现方法"><a href="#进程互斥的硬件实现方法" class="headerlink" title="进程互斥的硬件实现方法"></a>进程互斥的硬件实现方法</h4><h5 id="中断屏蔽方法"><a href="#中断屏蔽方法" class="headerlink" title="中断屏蔽方法"></a>中断屏蔽方法</h5><h6 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h6><p>中断屏蔽是指在某个进程或中断处理程序进入临界区之前，暂时禁止系统接收新的中断请求。这样做的目的是确保当前进程在执行临界区代码时不会被其他中断处理程序打断，从而避免并发访问导致的数据不一致问题。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2024/11/02/Yj3DG4NtRFrImzf.png" alt="中断屏蔽方法.png"></p>
<h5 id="TestAndSet指令"><a href="#TestAndSet指令" class="headerlink" title="TestAndSet指令"></a>TestAndSet指令</h5><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2024/11/02/I3zMS9iCoHJnc6v.png" alt="TestAndSet.png"></p>
<p>优点：</p>
<ul>
<li>实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞，适用于多处理机环境</li>
</ul>
<p>缺点:</p>
<ul>
<li>忙等待：未获取锁的线程会不断循环等待，占用 CPU 资源，影响系统性能。</li>
<li>不适合长时间临界区：对于长时间的临界区访问，忙等待会导致 CPU 资源浪费。</li>
<li>多处理机环境：在多处理机系统中，TAS 指令只能确保当前处理器上的同步，无法阻止其他处理器上的线程访问共享资源。</li>
</ul>
<h5 id="swap指令"><a href="#swap指令" class="headerlink" title="swap指令"></a>swap指令</h5><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2024/11/02/ZuNwMVpD6YsLioq.png" alt="swap指令.png"></p>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>一个进程在进入临界区时应获得锁，在推出临界区时释放锁。函数<code>acquire</code>获得锁，函数<code>release</code>释放锁。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">acquire() {</span><br><span class="line">    <span class="keyword">while</span> (!available);</span><br><span class="line">    available = <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line">release() {</span><br><span class="line">    available = <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>注意<br>acquire() 和 release() 函数都是原子操作，因此互斥锁通常采用硬件机制实现</p>
</blockquote>
<p>特性：</p>
<ul>
<li><p>优点：</p>
<ul>
<li>等待期间不用切换进程上下文，多处理器系统中，若上锁的时间短，则等待代价很低</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>需忙等，进程时间片用完才下处理机，违反“让权等待”</li>
<li>忙等待： 当有一个进程在临界区中，任何其他进程在进入临界区时必须连续循环调用<code>acquire()</code>。当多个进程共享统一CPU时，就浪费了CPU周期。</li>
</ul>
</li>
<li><p>常用于多处理器系统，一个核忙等，其他核照常工作，并快速释放临界区</p>
</li>
<li><p>不太适用于但处理机系统，忙等的过程中不可能解锁</p>
</li>
</ul>
<h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><p>信号量是一个整数值，通常用于表示可用资源的数量。它可以分为两种类型：</p>
<ul>
<li>整型信号量最初Dijkstra把整型信号量定义为一个用于表示资源数目的整型量S，它与一般的整型量不同，除初始化外，仅能通过两个标准原子操作（Atomic Operation）wait(S)和signal(S)操作可以描述为：</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> S = <span class="number">1</span>; <span class="comment">// 表示当前系统中可用的资源数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> S)</span>: <span class="comment">// wait原语，相当于进入区</span></span><br><span class="line">    <span class="title function_">while</span><span class="params">(S&lt;=<span class="number">0</span>)</span>; <span class="comment">// 如果资源数不够就循环等待</span></span><br><span class="line">    S = S - <span class="number">1</span>; <span class="comment">// 如果资源数够，就占用一个资源</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal</span> <span class="params">(<span class="type">int</span> S)</span>: <span class="comment">// signal原语，相当于退出区</span></span><br><span class="line">    S = S + <span class="number">1</span>; <span class="comment">// 使用完资源后，在退出区释放资源</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<ul>
<li>记录型信号量在整型信号量机制中的wait操作，只要是信号量S&lt;=0,就会不断测试。因此，该机制并未遵循“让权等待”准则，而是使进程处于“忙等”状态。记录型信号量机制则是一种不存在“忙等”现象的进程同步机制。但在采取了“让权等待”的策略后，又会出现多个进程等待访问同一个临界资源的情况。为此，在信号量机制中，除了需要一个用于代表资源数目的整型变量value外，还应该增加一个进程链表指针L，用于链接上述的所有等待进程。记录型信号量是由于它采用了记录型的数据结构而得名的。它所包含的上述两个数据项可以描述为：type semaphore=recordvalue:integerL:list of process;end相应的，wait(S)和signal(S)的操作可描述为</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="type">int</span> value; <span class="comment">// 剩余资源数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">L</span>;</span> <span class="comment">// 等待队列</span></span><br><span class="line">} semaphore;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">wait</span><span class="params">(semaphore S)</span> {</span><br><span class="line">    S.value --;</span><br><span class="line">    <span class="keyword">if</span>(S.value &lt; <span class="number">0</span>) {</span><br><span class="line">        block(S.L); <span class="comment">// 如果资源数量不够，就用block将进程从运行态进入阻塞态，并把挂到信号量S的等待队列中</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal</span><span class="params">(semaphore S)</span> {</span><br><span class="line">    S.value ++;</span><br><span class="line">    <span class="keyword">if</span>(S.value &lt;= <span class="number">0</span>) {</span><br><span class="line">        wakeup(S.L); <span class="comment">// 释放资源后，若还有别的进程在等待这种资源，则使用wakeup唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h4 id="操作机制"><a href="#操作机制" class="headerlink" title="操作机制"></a>操作机制</h4><p>信号量机制主要通过两个操作来实现：</p>
<ul>
<li><p>P操作（wait）：<br>当进程想要进入临界区时，它会执行P操作，将信号量的值减1。<br>如果减1后信号量的值大于或等于0，进程可以继续执行；如果小于0，进程会被阻塞，进入等待队列。</p>
</li>
<li><p>V操作（signal）：<br>当进程离开临界区时，它会执行V操作，将信号量的值加1。<br>如果有其他进程在等待该信号量，则其中一个等待的进程将被唤醒。</p>
</li>
</ul>
<h4 id="实现进程互斥"><a href="#实现进程互斥" class="headerlink" title="实现进程互斥"></a>实现进程互斥</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2024/11/04/EbnIucekK2zmo6U.png" alt="信号量实现进程互斥.png"></p>
<ol>
<li><p><strong>定义信号量</strong>：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>; <span class="comment">// 初始化互斥信号量</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>进入临界区前的操作（P操作）</strong>：<br>在进程要访问临界区之前，必须执行P（wait）操作以请求对资源的访问。这一操作会将信号量的值减1：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P(mutex); <span class="comment">// 请求进入临界区</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>临界区代码</strong>：<br>进程在临界区内执行需要互斥访问的代码。此时，其他进程无法进入该区域。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 临界区代码段</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>离开临界区后的操作（V操作）</strong>：<br>当进程完成对共享资源的访问后，必须执行V（signal）操作来释放资源，将信号量的值加1，从而允许其他等待的进程进入临界区：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">V(mutex); <span class="comment">// 释放临界区</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<h5 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h5><p>以下是一个简单的示例，展示了如何使用信号量实现进程互斥：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>; <span class="comment">// 初始化信号量为1</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">process1</span><span class="params">()</span> {</span><br><span class="line">    P(mutex); <span class="comment">// 请求进入临界区</span></span><br><span class="line">    <span class="comment">// 临界区代码段...</span></span><br><span class="line">    V(mutex); <span class="comment">// 离开临界区</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">process2</span><span class="params">()</span> {</span><br><span class="line">    P(mutex); <span class="comment">// 请求进入临界区</span></span><br><span class="line">    <span class="comment">// 临界区代码段...</span></span><br><span class="line">    V(mutex); <span class="comment">// 离开临界区</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h5 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h5><ul>
<li><strong>互斥性</strong>：通过将信号量初值设置为1，确保同一时间只能有一个进程进入临界区。</li>
<li><strong>阻塞与唤醒</strong>：如果一个进程在执行P操作时发现信号量值为0，则该进程会被阻塞，直到其他进程执行V操作并唤醒它。</li>
<li><strong>原子性</strong>：P和V操作通常被实现为原子操作，以防止中断，从而避免竞争条件。</li>
</ul>
<h4 id="实现进程同步"><a href="#实现进程同步" class="headerlink" title="实现进程同步"></a>实现进程同步</h4><ol>
<li><p><strong>分析同步需求</strong>：<br>确定哪些操作需要同步，即需要保证某些操作按顺序执行。例如，若进程P1的某个操作必须在进程P2的操作之前完成，则需要实现同步。</p>
</li>
<li><p><strong>设置同步信号量</strong>：<br>创建一个信号量，初始值设置为0。这个信号量用于控制两个或多个操作之间的顺序。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">semaphore sync = <span class="number">0</span>; <span class="comment">// 初始化同步信号量为0</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>在“前操作”后执行V操作</strong>：<br>在需要确保先执行的操作完成后，调用V操作以释放信号量。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前操作代码</span></span><br><span class="line">V(sync); <span class="comment">// 释放信号量</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>在“后操作”前执行P操作</strong>：<br>在需要确保后执行的代码之前，调用P操作以请求信号量。如果信号量值为0，则当前进程会被阻塞，直到其他进程释放该信号量。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">P(sync); <span class="comment">// 请求信号量</span></span><br><span class="line"><span class="comment">// 后操作代码</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<h5 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h5><p>以下是一个简单示例，展示如何使用信号量实现两个进程之间的同步：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">semaphore sync = <span class="number">0</span>; <span class="comment">// 初始化同步信号量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">process1</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// 执行前操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    V(sync); <span class="comment">// 完成前操作，释放信号量</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">process2</span><span class="params">()</span> {</span><br><span class="line">    P(sync); <span class="comment">// 请求信号量，等待process1完成前操作</span></span><br><span class="line">    <span class="comment">// 执行后操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h5 id="关键点-1"><a href="#关键点-1" class="headerlink" title="关键点"></a>关键点</h5><ul>
<li><strong>阻塞与唤醒</strong>：通过设置初始值为0，可以确保在执行后续操作之前，相关进程必须先完成其前置条件。</li>
<li><strong>避免竞争条件</strong>：使用信号量可以有效避免由于并发执行导致的数据不一致问题。</li>
</ul>
<p>通过以上步骤和机制，信号量能够有效地实现进程之间的同步，使得多个并发进程能够按照预定顺序有序地推进。</p>
<h4 id="信号量机制实现前驱关系"><a href="#信号量机制实现前驱关系" class="headerlink" title="信号量机制实现前驱关系"></a>信号量机制实现前驱关系</h4><p>信号量机制可以有效地处理进程之间的前驱关系，确保某些操作在其他操作之前完成。以下是信号量如何实现前驱关系的基本原理和步骤。</p>
<h5 id="前驱关系的定义"><a href="#前驱关系的定义" class="headerlink" title="前驱关系的定义"></a>前驱关系的定义</h5><p>前驱关系指的是在多个进程或操作中，某个操作的执行必须依赖于另一个操作的完成。例如，如果操作S1必须在操作S2之前完成，则可以表示为S1 -&gt; S2。</p>
<h5 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h5><ol>
<li><p><strong>设置信号量</strong>：<br>为每个需要同步的操作设置一个信号量，初始值为0。这表示该操作在执行之前必须等待其前驱操作完成。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">semaphore a1 = <span class="number">0</span>; <span class="comment">// 用于S1 -&gt; S2</span></span><br><span class="line">semaphore a2 = <span class="number">0</span>; <span class="comment">// 用于S1 -&gt; S3</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>执行前驱操作并释放信号量</strong>：<br>在前驱操作（如S1）完成后，调用V操作释放相应的信号量，以通知其他进程可以继续执行。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">S1</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// 执行S1的代码</span></span><br><span class="line">    V(a1); <span class="comment">// 通知S2可以执行</span></span><br><span class="line">    V(a2); <span class="comment">// 通知S3可以执行</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>在后续操作中请求信号量</strong>：<br>在每个后续操作（如S2和S3）开始之前，调用P操作请求相应的信号量。如果信号量值为0，进程将被阻塞，直到前驱操作完成并释放信号量。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">S2</span><span class="params">()</span> {</span><br><span class="line">    P(a1); <span class="comment">// 等待S1完成</span></span><br><span class="line">    <span class="comment">// 执行S2的代码</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">S3</span><span class="params">()</span> {</span><br><span class="line">    P(a2); <span class="comment">// 等待S1完成</span></span><br><span class="line">    <span class="comment">// 执行S3的代码</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>继续后续操作</strong>：<br>后续操作（如S4、S5、S6等）也可以使用类似的方法进行同步，确保它们在适当的时候执行。</p>
</li>
</ol>
<h5 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h5><p>以下是一个完整示例，展示了如何使用信号量实现多个进程之间的前驱关系：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">semaphore a1 = <span class="number">0</span>; <span class="comment">// S1 -&gt; S2</span></span><br><span class="line">semaphore a2 = <span class="number">0</span>; <span class="comment">// S1 -&gt; S3</span></span><br><span class="line">semaphore b1 = <span class="number">0</span>; <span class="comment">// S2 -&gt; S4</span></span><br><span class="line">semaphore b2 = <span class="number">0</span>; <span class="comment">// S2 -&gt; S5</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">S1</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// 执行S1的代码</span></span><br><span class="line">    V(a1); <span class="comment">// 通知S2可以执行</span></span><br><span class="line">    V(a2); <span class="comment">// 通知S3可以执行</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">S2</span><span class="params">()</span> {</span><br><span class="line">    P(a1); <span class="comment">// 等待S1完成</span></span><br><span class="line">    <span class="comment">// 执行S2的代码</span></span><br><span class="line">    V(b1); <span class="comment">// 通知S4可以执行</span></span><br><span class="line">    V(b2); <span class="comment">// 通知S5可以执行</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">S3</span><span class="params">()</span> {</span><br><span class="line">    P(a2); <span class="comment">// 等待S1完成</span></span><br><span class="line">    <span class="comment">// 执行S3的代码</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">S4</span><span class="params">()</span> {</span><br><span class="line">    P(b1); <span class="comment">// 等待S2完成</span></span><br><span class="line">    <span class="comment">// 执行S4的代码</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">S5</span><span class="params">()</span> {</span><br><span class="line">    P(b2); <span class="comment">// 等待S2完成</span></span><br><span class="line">    <span class="comment">// 执行S5的代码</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h3><p>生产者消费者问题是一个经典的进程同步问题，描述了两个进程（生产者和消费者）如何在共享缓冲区中安全地交互。以下是对该问题的详细介绍，包括其背景、问题描述、解决方案及实现方式。</p>
<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>在生产者消费者模型中，生产者负责生成数据并将其放入共享缓冲区，而消费者则从缓冲区中取出数据进行消费。关键在于要确保：</p>
<ul>
<li><strong>缓冲区不满</strong>：当缓冲区已满时，生产者必须等待，直到消费者消费了数据。</li>
<li><strong>缓冲区不空</strong>：当缓冲区为空时，消费者必须等待，直到生产者生成了数据。</li>
</ul>
<p>这种模型确保了生产者和消费者之间的协调，避免了数据丢失或错误读取的情况。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="使用信号量"><a href="#使用信号量" class="headerlink" title="使用信号量"></a>使用信号量</h5><p>信号量是一种用于进程间同步的机制，可以有效地解决生产者消费者问题。通常需要使用两个信号量：</p>
<ul>
<li><strong>freeSpace</strong>：表示缓冲区中可用的空位数量。</li>
<li><strong>usedSpace</strong>：表示缓冲区中已用的产品数量。</li>
</ul>
<h5 id="伪代码示例"><a href="#伪代码示例" class="headerlink" title="伪代码示例"></a>伪代码示例</h5><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">semaphore freeSpace = N; <span class="comment">// N为缓冲区大小</span></span><br><span class="line">semaphore usedSpace = <span class="number">0</span>; <span class="comment">// 初始时没有产品</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">producer</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        produceItem(); <span class="comment">// 生产一个产品</span></span><br><span class="line">        P(freeSpace); <span class="comment">// 请求一个空位</span></span><br><span class="line">        putItemIntoBuffer(); <span class="comment">// 将产品放入缓冲区</span></span><br><span class="line">        V(usedSpace); <span class="comment">// 增加已用产品计数</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">consumer</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        P(usedSpace); <span class="comment">// 请求一个已用产品</span></span><br><span class="line">        getItemFromBuffer(); <span class="comment">// 从缓冲区获取产品</span></span><br><span class="line">        V(freeSpace); <span class="comment">// 增加空位计数</span></span><br><span class="line">        consumeItem(); <span class="comment">// 消费该产品</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h5 id="使用互斥锁和条件变量"><a href="#使用互斥锁和条件变量" class="headerlink" title="使用互斥锁和条件变量"></a>使用互斥锁和条件变量</h5><p>在多生产者和多消费者的情况下，可以使用互斥锁和条件变量来实现更复杂的同步机制。互斥锁用于保护对共享资源的访问，而条件变量则用于在特定条件下阻塞和唤醒线程。</p>
<h5 id="伪代码示例-1"><a href="#伪代码示例-1" class="headerlink" title="伪代码示例"></a>伪代码示例</h5><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">mutex lock;</span><br><span class="line">condition_variable notFull, notEmpty;</span><br><span class="line"><span class="type">int</span> buffer[N]; <span class="comment">// 缓冲区</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 当前产品数量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">producer</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        produceItem();</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">while</span> (count == N) {</span><br><span class="line">            notFull.wait(lock); <span class="comment">// 等待直到有空位</span></span><br><span class="line">        }</span><br><span class="line">        buffer[count++] = item; <span class="comment">// 放入产品</span></span><br><span class="line">        notEmpty.notify_one(); <span class="comment">// 通知消费者有新产品</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">consumer</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) {</span><br><span class="line">            notEmpty.wait(lock); <span class="comment">// 等待直到有产品可消费</span></span><br><span class="line">        }</span><br><span class="line">        item = buffer[--count]; <span class="comment">// 获取产品</span></span><br><span class="line">        notFull.notify_one(); <span class="comment">// 通知生产者有空位</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">        consumeItem(item);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>这是一个cpp实例</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProducerConsumer</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ProducerConsumer</span>(<span class="type">int</span> maxSize) : <span class="built_in">maxSize_</span>(maxSize), <span class="built_in">running_</span>(<span class="literal">true</span>) {}</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">startProducers</span><span class="params">(<span class="type">int</span> numProducers)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numProducers; ++i) {</span><br><span class="line">            producers_.<span class="built_in">emplace_back</span>(&amp;ProducerConsumer::producer, <span class="keyword">this</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">startConsumers</span><span class="params">(<span class="type">int</span> numConsumers)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numConsumers; ++i) {</span><br><span class="line">            consumers_.<span class="built_in">emplace_back</span>(&amp;ProducerConsumer::consumer, <span class="keyword">this</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span> </span>{</span><br><span class="line">        running_ = <span class="literal">false</span>;</span><br><span class="line">        cv_.<span class="built_in">notify_all</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;producer : producers_) {</span><br><span class="line">            producer.<span class="built_in">join</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;consumer : consumers_) {</span><br><span class="line">            consumer.<span class="built_in">join</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (running_) {</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">            cv_.<span class="built_in">wait</span>(lk, [&amp;] { <span class="keyword">return</span> buffer_.<span class="built_in">size</span>() &lt; maxSize_ || !running_; });</span><br><span class="line">            <span class="keyword">if</span> (!running_) <span class="keyword">break</span>;</span><br><span class="line">            buffer_.<span class="built_in">push</span>(res_[(index++) % res_.<span class="built_in">size</span>()]);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"Producer pushed: "</span> &lt;&lt; res_[(index - <span class="number">1</span>) % res_.<span class="built_in">size</span>()] &lt;&lt; std::endl;</span><br><span class="line">            cv_.<span class="built_in">notify_all</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (running_) {</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">            cv_.<span class="built_in">wait</span>(lk, [&amp;] { <span class="keyword">return</span> !buffer_.<span class="built_in">empty</span>() || !running_; });</span><br><span class="line">            <span class="keyword">if</span> (!running_ &amp;&amp; buffer_.<span class="built_in">empty</span>()) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (!buffer_.<span class="built_in">empty</span>()) {</span><br><span class="line">                <span class="keyword">auto</span> front = buffer_.<span class="built_in">front</span>();</span><br><span class="line">                buffer_.<span class="built_in">pop</span>();</span><br><span class="line">                std::cout &lt;&lt; <span class="string">"Consumer got: "</span> &lt;&lt; front &lt;&lt; std::endl;</span><br><span class="line">            }</span><br><span class="line">            cv_.<span class="built_in">notify_all</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> std::array&lt;std::string, 5&gt; res_{<span class="string">"awd"</span>, <span class="string">"1"</span>, <span class="string">"awdjkgdfh"</span>, <span class="string">"encounter"</span>, <span class="string">"dwadawd"</span>};</span><br><span class="line">    std::queue&lt;std::string&gt; buffer_;</span><br><span class="line">    std::condition_variable cv_;</span><br><span class="line">    std::mutex mtx_;</span><br><span class="line">    <span class="type">int</span> maxSize_;</span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; running_;</span><br><span class="line">    std::vector&lt;std::thread&gt; producers_;</span><br><span class="line">    std::vector&lt;std::thread&gt; consumers_;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">ProducerConsumer <span class="title">pc</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    pc.<span class="built_in">startProducers</span>(<span class="number">3</span>);</span><br><span class="line">    pc.<span class="built_in">startConsumers</span>(<span class="number">3</span>);</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">    pc.<span class="built_in">stop</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>生产者消费者问题展示了多线程编程中的同步与互斥的重要性。通过使用信号量、互斥锁和条件变量等机制，可以有效地管理进程之间的协作，确保数据的一致性与完整性。该模型不仅适用于单一生产者和消费者，也可以扩展到多个生产者和消费者的场景中，为并发编程提供了重要的理论基础和实践指导。</p>
<h3 id="读者写者问题"><a href="#读者写者问题" class="headerlink" title="读者写者问题"></a>读者写者问题</h3><p>读者写者问题是操作系统中的经典同步问题，涉及多个进程对共享资源的访问控制。其主要目标是确保在读者和写者之间实现有效的互斥，以避免数据不一致性。</p>
<h4 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h4><p>在读者写者问题中，有两类进程：</p>
<ul>
<li><strong>读者进程</strong>：只读取共享数据，不修改它。</li>
<li><strong>写者进程</strong>：可以读取和修改共享数据。</li>
</ul>
<h4 id="主要要求"><a href="#主要要求" class="headerlink" title="主要要求"></a>主要要求</h4><ol>
<li><strong>允许多个读者同时进行读操作</strong>：多个读者可以并行访问共享资源而不会发生冲突。</li>
<li><strong>只允许一个写者进行写操作</strong>：在任何写操作进行时，必须确保没有其他读者或写者同时访问该资源。</li>
<li><strong>互斥访问</strong>：在写者执行写操作之前，必须等待所有当前的读者和写者完成他们的操作。</li>
</ol>
<h4 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h4><h5 id="1-读者优先"><a href="#1-读者优先" class="headerlink" title="1. 读者优先"></a>1. 读者优先</h5><p>在这种策略下，系统优先允许读者访问共享资源。若有持续不断的读者请求，可能会导致写者饿死，即无法获得执行机会。这种策略简单易实现，但在高并发情况下可能导致写入延迟。</p>
<h5 id="2-写者优先"><a href="#2-写者优先" class="headerlink" title="2. 写者优先"></a>2. 写者优先</h5><p>此策略确保写者能够尽快执行其操作。在这种情况下，如果有待处理的写请求，则后续的读请求将被阻塞。这种策略可以减少写者的饥饿现象，但可能导致读者的延迟。</p>
<h4 id="解决方案示例"><a href="#解决方案示例" class="headerlink" title="解决方案示例"></a>解决方案示例</h4><p>一种常见的解决方案是使用信号量来控制对共享资源的访问。信号量提供了两种基本操作：</p>
<ul>
<li><strong>P（proberen）</strong>：请求资源，若资源不可用则阻塞。</li>
<li><strong>V（verhogen）</strong>：释放资源，唤醒等待的进程。</li>
</ul>
<p>以下是一个简化的伪代码示例：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化信号量</span></span><br><span class="line">Semaphore readCountMutex = <span class="number">1</span>; <span class="comment">// 控制读计数器</span></span><br><span class="line">Semaphore resourceMutex = <span class="number">1</span>;   <span class="comment">// 控制对共享资源的访问</span></span><br><span class="line">Semaphore writeMUtex = <span class="number">1</span>;   <span class="comment">// 用于实现"写优先"</span></span><br><span class="line"><span class="type">int</span> readCount = <span class="number">0</span>;             <span class="comment">// 当前读取进程数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读者进程</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">reader</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) {</span><br><span class="line">        P(writeMutex);</span><br><span class="line">        P(readCountMutex);          <span class="comment">// 获取读计数器锁</span></span><br><span class="line">        <span class="keyword">if</span> (readCount == <span class="number">1</span>) {</span><br><span class="line">            P(resourceMutex);       <span class="comment">// 第一个读者获取资源锁</span></span><br><span class="line">        }</span><br><span class="line">        readCount++;</span><br><span class="line">        V(readCountMutex);          <span class="comment">// 释放读计数器锁</span></span><br><span class="line">        V(writeMutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行读取操作</span></span><br><span class="line"></span><br><span class="line">        P(readCountMutex);          <span class="comment">// 获取读计数器锁</span></span><br><span class="line">        readCount--;</span><br><span class="line">        <span class="keyword">if</span> (readCount == <span class="number">0</span>) {</span><br><span class="line">            V(resourceMutex);       <span class="comment">// 最后一个读者释放资源锁</span></span><br><span class="line">        }</span><br><span class="line">        V(readCountMutex);          <span class="comment">// 释放读计数器锁</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写者进程</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">writer</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)  {</span><br><span class="line">        P(writeMutex);</span><br><span class="line">        P(resourceMutex);           <span class="comment">// 获取资源锁</span></span><br><span class="line">        <span class="comment">// 执行写入操作</span></span><br><span class="line">        V(resourceMutex);           <span class="comment">// 释放资源锁</span></span><br><span class="line">        V(writeMutex);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>如果对上面的伪代码没有概念的话，下面是一个cpp的实例</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReaderWriter</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reader</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> ( <span class="literal">true</span> ) {</span><br><span class="line">            {</span><br><span class="line">                <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">( writeMutex )</span></span>;</span><br><span class="line">                <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">countLock</span><span class="params">( readCountMutex )</span></span>;</span><br><span class="line">                <span class="keyword">if</span> ( readCount == <span class="number">0</span> ) {</span><br><span class="line">                    readCountCond.<span class="built_in">wait</span>(</span><br><span class="line">                        countLock, [<span class="keyword">this</span>]() { <span class="keyword">return</span> !isWriting; } );</span><br><span class="line">                }</span><br><span class="line">                readCount++;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行读取操作</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">"Reader is reading..."</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">            {</span><br><span class="line">                <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">countLock</span><span class="params">( readCountMutex )</span></span>;</span><br><span class="line">                readCount--;</span><br><span class="line">                <span class="keyword">if</span> ( readCount == <span class="number">0</span> ) {</span><br><span class="line">                    readCountCond.<span class="built_in">notify_all</span>();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 模拟读取操作时间</span></span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>( std::chrono::<span class="built_in">milliseconds</span>( <span class="number">500</span> ) );</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">writer</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> ( <span class="literal">true</span> ) {</span><br><span class="line">            {</span><br><span class="line">                <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">( writeMutex )</span></span>;</span><br><span class="line">                <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">countLock</span><span class="params">( readCountMutex )</span></span>;</span><br><span class="line">                isWriting = <span class="literal">true</span>;</span><br><span class="line">                readCountCond.<span class="built_in">wait</span>(</span><br><span class="line">                    countLock, [<span class="keyword">this</span>]() { <span class="keyword">return</span> readCount == <span class="number">0</span>; } );  <span class="comment">// 保证没有读者线程来干扰</span></span><br><span class="line">                                                                       <span class="comment">// 假设当前线程是阻塞的，isWriting不会影响到读线程</span></span><br><span class="line">                                                                       <span class="comment">// 这样就保证在读者线程全部读完之前都不会被写线程影响</span></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行写入操作</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">"Writer is writing..."</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">            {</span><br><span class="line">                <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">countLock</span><span class="params">( readCountMutex )</span></span>;</span><br><span class="line">                isWriting = <span class="literal">false</span>;</span><br><span class="line">                readCountCond.<span class="built_in">notify_all</span>();</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 模拟写入操作时间</span></span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>( std::chrono::<span class="built_in">milliseconds</span>( <span class="number">1000</span> ) );</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::mutex readCountMutex;             <span class="comment">// 控制读计数器</span></span><br><span class="line">    std::mutex resourceMutex;              <span class="comment">// 控制对共享资源的访问</span></span><br><span class="line">    std::mutex writeMutex;                 <span class="comment">// 用于实现"写优先"</span></span><br><span class="line">    <span class="type">int</span> readCount  = <span class="number">0</span>;                    <span class="comment">// 当前读取进程数量</span></span><br><span class="line">    <span class="type">bool</span> isWriting = <span class="literal">false</span>;                <span class="comment">// 标志是否正在写</span></span><br><span class="line">    std::condition_variable readCountCond; <span class="comment">// 读计数变量</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    ReaderWriter rw;</span><br><span class="line">    <span class="function">std::thread <span class="title">readerThread1</span><span class="params">(&amp;ReaderWriter::reader, &amp;rw)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">readerThread2</span><span class="params">(&amp;ReaderWriter::reader, &amp;rw)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">writerThread</span><span class="params">(&amp;ReaderWriter::writer, &amp;rw)</span></span>;</span><br><span class="line"></span><br><span class="line">    readerThread1.<span class="built_in">join</span>();</span><br><span class="line">    readerThread2.<span class="built_in">join</span>();</span><br><span class="line">    writerThread.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="哲学家问题"><a href="#哲学家问题" class="headerlink" title="哲学家问题"></a>哲学家问题</h3><h4 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h4><p>在这个模型中：</p>
<ul>
<li><strong>哲学家</strong>：每位哲学家可以进行两种活动：思考和吃饭。</li>
<li><strong>餐具</strong>：每位哲学家面前有两根筷子（或餐叉），分别位于其左侧和右侧。要吃饭，哲学家必须同时拿起左边和右边的筷子。</li>
</ul>
<h4 id="主要挑战"><a href="#主要挑战" class="headerlink" title="主要挑战"></a>主要挑战</h4><ul>
<li><strong>死锁</strong>：如果每位哲学家同时拿起左边的筷子，然后等待右边的筷子，就会导致所有哲学家都在等待，形成死锁。</li>
<li><strong>资源竞争</strong>：哲学家之间对筷子的竞争可能导致资源耗尽。</li>
</ul>
<h4 id="死锁分析"><a href="#死锁分析" class="headerlink" title="死锁分析"></a>死锁分析</h4><p>死锁的产生通常满足以下四个条件：</p>
<ol>
<li><strong>互斥</strong>：至少有一个资源必须处于非共享模式，即一次只能由一个进程使用。</li>
<li><strong>保持并等待</strong>：一个进程至少持有一个资源，并等待获取其他资源。</li>
<li><strong>不剥夺</strong>：已经分配给进程的资源在该进程释放之前，不能被其他进程强制剥夺。</li>
<li><strong>循环等待</strong>：存在一种进程的循环等待关系。</li>
</ol>
<p>在哲学家就餐问题中，如果每位哲学家都先拿起左侧的筷子，就会出现循环等待，从而导致死锁。</p>
<h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="1-增加限制"><a href="#1-增加限制" class="headerlink" title="1. 增加限制"></a>1. 增加限制</h5><p>比如最多允许四个哲学家同时进餐。这样可以保证至少一个哲学家是可以拿到左右两只筷子。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = {<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>};</span><br><span class="line">semaphore mutex = <span class="number">1</span>; <span class="comment">// 互斥取筷子</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Run</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) {</span><br><span class="line">        P(mutex);</span><br><span class="line">        P(chopstick[i]); <span class="comment">// take left</span></span><br><span class="line">        P(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]); <span class="comment">// take right</span></span><br><span class="line">        V(mutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Eatting ....</span></span><br><span class="line"></span><br><span class="line">        V(chopstick[i]); <span class="comment">// drop left</span></span><br><span class="line">        V(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]); <span class="comment">// drop right</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Thinking ...</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h5 id="2-改变获取顺序"><a href="#2-改变获取顺序" class="headerlink" title="2. 改变获取顺序"></a>2. 改变获取顺序</h5><p>要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。</p>
<h5 id="3-资源分级"><a href="#3-资源分级" class="headerlink" title="3. 资源分级"></a>3. 资源分级</h5><p>仅当一个哲学家左右两只筷子都可用时才允许他抓起筷子。</p>
<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>管程（Monitor）是操作系统和并发编程中的一种同步机制，用于管理对共享资源的访问。它通过封装共享变量和操作这些变量的过程，提供了一种高效且易于使用的方式来解决并发问题。</p>
<h4 id="管程的定义"><a href="#管程的定义" class="headerlink" title="管程的定义"></a>管程的定义</h4><p>管程是一种高级同步原语，它将共享数据结构（如变量）和对这些数据结构的操作封装在一个模块中。管程确保在任一时刻只有一个进程可以访问这些共享资源，从而实现互斥访问。</p>
<h4 id="主要特征"><a href="#主要特征" class="headerlink" title="主要特征"></a>主要特征</h4><ol>
<li>局部管程的数据只能被局部于管程的过程所访问</li>
<li>一个进程只有通过调用管程内的过程才能进入管程访问</li>
<li>每次仅允许一个进程在管程内执行某个内部过程</li>
</ol>
<h4 id="管程的组成"><a href="#管程的组成" class="headerlink" title="管程的组成"></a>管程的组成</h4><ul>
<li><strong>共享变量</strong>：管程内定义的共享数据。</li>
<li><strong>过程</strong>：对共享数据进行操作的一组函数或方法。</li>
<li><strong>条件变量</strong>：用于实现进程间同步的机制，允许进程在某些条件下被阻塞或唤醒。</li>
<li><strong>初始化语句</strong>：用于设置共享变量初始值的代码。</li>
</ul>
<h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><p>条件变量是管程中重要的组成部分，用于实现更复杂的同步机制。它们提供了两个基本操作：</p>
<ul>
<li>**wait(c)**：调用该操作的进程被阻塞，并释放管程，直到其他进程执行signal(c)唤醒它。</li>
<li>**signal(c)**：唤醒在条件变量c上等待的一个进程。如果没有进程在等待，则该信号被丢弃。</li>
</ul>
<h4 id="管程与信号量的比较"><a href="#管程与信号量的比较" class="headerlink" title="管程与信号量的比较"></a>管程与信号量的比较</h4><p>虽然管程和信号量都能解决并发问题，但它们之间有显著区别：</p>
<ul>
<li><strong>封装性</strong>：管程将所有相关的同步操作集中在一起，而信号量则可能导致同步代码分散在多个地方。</li>
<li><strong>易用性</strong>：由于互斥和同步机制由编译器处理，使用管程通常比使用信号量更简单、更安全。</li>
<li><strong>错误率</strong>：由于管程内部管理复杂性，程序员不需要手动处理互斥，降低了出错的概率。</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h4><p>死锁可以被定义为：一组进程中的每个进程都在等待一个事件，而这个事件只能由该组中的其他进程触发。当这种情况发生时，所有相关进程都将无限期地等待下去，无法继续执行。简单来说，就是每个进程都在等待其他进程释放它所需的资源，而这些资源又被其他进程占用，从而形成了一个循环等待的状态<br>死锁、死循环和饥饿是并发编程中常见的三种现象，它们虽然都与进程的执行状态有关，但各自的定义、原因和影响有所不同。</p>
<h4 id="进程死锁、饥饿、死循环的区别"><a href="#进程死锁、饥饿、死循环的区别" class="headerlink" title="进程死锁、饥饿、死循环的区别"></a>进程死锁、饥饿、死循环的区别</h4><h5 id="1-死锁"><a href="#1-死锁" class="headerlink" title="1. 死锁"></a>1. 死锁</h5><p><strong>定义</strong>：死锁是指两个或多个进程因相互等待对方持有的资源而导致的僵局状态。在这种情况下，所有相关进程都无法继续执行。</p>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>循环等待</strong>：每个进程都在等待其他进程释放它所需的资源。</li>
<li><strong>阻塞状态</strong>：所有参与死锁的进程都处于阻塞状态，无法向前推进。</li>
</ul>
<p><strong>示例</strong>：进程A持有资源1并请求资源2，而进程B持有资源2并请求资源1，导致两者相互等待。</p>
<h5 id="2-死循环"><a href="#2-死循环" class="headerlink" title="2. 死循环"></a>2. 死循环</h5><p><strong>定义</strong>：死循环是指某个进程在执行过程中陷入一个无限循环，无法正常结束或跳出该循环。通常是因为程序逻辑错误或故意设计的逻辑。</p>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>逻辑错误</strong>：可能由于代码中的错误导致条件永远不满足。</li>
<li><strong>不一定阻塞</strong>：死循环的进程可能仍在运行，但无法完成其预定任务。</li>
</ul>
<p><strong>示例</strong>：一个程序在检查某个条件时，条件始终为假，导致其不断重复执行同一段代码。</p>
<h5 id="3-饥饿"><a href="#3-饥饿" class="headerlink" title="3. 饥饿"></a>3. 饥饿</h5><p><strong>定义</strong>：饥饿是指某个进程由于长期得不到所需资源而无法向前推进。饥饿通常是由于调度策略不当或资源分配不均造成的。</p>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>单一影响</strong>：可能只有一个进程经历饥饿，而其他进程正常运行。</li>
<li><strong>可处于不同状态</strong>：饥饿的进程可以处于阻塞状态（如等待I/O设备）或就绪状态（长期得不到CPU时间）。</li>
</ul>
<p><strong>示例</strong>：在短作业优先（SJF）调度算法中，如果有大量短作业不断到达，长作业可能会一直得不到处理，从而导致饥饿。</p>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><table>
<thead>
<tr>
<th>特征</th>
<th>死锁</th>
<th>死循环</th>
<th>饥饿</th>
</tr>
</thead>
<tbody><tr>
<td>定义</td>
<td>互相等待对方资源，无法执行</td>
<td>陷入无限循环，无法结束</td>
<td>长期得不到所需资源</td>
</tr>
<tr>
<td>状态</td>
<td>所有相关进程均阻塞</td>
<td>进程仍在运行但无效</td>
<td>可能处于阻塞或就绪状态</td>
</tr>
<tr>
<td>影响范围</td>
<td>多个进程</td>
<td>单个进程</td>
<td>单一或多个进程</td>
</tr>
<tr>
<td>解决方法</td>
<td>检测与恢复、预防措施</td>
<td>修正代码逻辑</td>
<td>改善调度策略</td>
</tr>
</tbody></table>
<h4 id="死锁产生必要的条件"><a href="#死锁产生必要的条件" class="headerlink" title="死锁产生必要的条件"></a>死锁产生必要的条件</h4><ol>
<li>互斥条件：资源不能被多个进程同时使用，即某个资源只能被一个进程占有。</li>
<li>占有且等待：一个进程持有至少一个资源，并正在请求其他资源。</li>
<li>不可剥夺条件：已经分配给某个进程的资源在该进程完成之前不能被强制剥夺。</li>
<li>循环等待条件：存在一个进程集合，其中每个进程都在等待下一个进程所持有的资源，从而形成一个环路</li>
</ol>
<h4 id="什么时候会发生死锁"><a href="#什么时候会发生死锁" class="headerlink" title="什么时候会发生死锁"></a>什么时候会发生死锁</h4><ol>
<li><p><strong>资源竞争</strong>：当多个进程需要共享有限的资源（如打印机、数据库连接等），并且这些资源只能被一个进程占用时，竞争可能导致死锁。例如，如果两个进程各自持有一个资源并请求对方的资源，就会形成死锁。</p>
</li>
<li><p><strong>请求与保持条件</strong>：如果一个进程已经持有某些资源，并且在请求其他资源时被阻塞，这种情况下就可能导致死锁。例如，进程A持有资源R1并请求资源R2，而进程B持有资源R2并请求资源R1，这样双方都在等待对方释放所需的资源，从而导致死锁。</p>
</li>
<li><p><strong>不可剥夺条件</strong>：当一个进程持有某个资源时，其他进程无法强制剥夺该资源，必须等到持有者主动释放。这种条件使得即使系统中存在可用资源，依然可能因为某些进程未释放其占有的资源而导致死锁。</p>
</li>
<li><p><strong>循环等待条件</strong>：如果存在一组进程，其中每个进程都在等待下一个进程所持有的资源，就形成了一个循环等待的状态。这是死锁发生的关键条件之一。例如，若P1等待P2持有的资源，而P2又在等待P1持有的资源，就会形成循环等待。</p>
</li>
<li><p><strong>不当的进程推进顺序</strong>：如果进程请求和释放资源的顺序不当，也可能导致死锁。例如，两个线程分别申请两个互斥锁，但获取顺序不一致，可能导致两个线程互相等待对方释放锁，从而产生死锁。</p>
</li>
</ol>
<h4 id="死锁的处理策略"><a href="#死锁的处理策略" class="headerlink" title="死锁的处理策略"></a>死锁的处理策略</h4><h5 id="1-预防死锁"><a href="#1-预防死锁" class="headerlink" title="1. 预防死锁"></a>1. 预防死锁</h5><p>预防死锁是通过破坏死锁产生的四个必要条件中的一个或多个来避免死锁的发生。具体方法包括：</p>
<ul>
<li><p><strong>破坏互斥条件</strong>：在某些情况下，可以尝试让资源不被独占，例如使用共享资源的方式，但这在实际应用中通常不可行。</p>
</li>
<li><p><strong>破坏请求与保持条件</strong>：不允许进程在持有某些资源的情况下请求其他资源。可以要求进程在请求新资源时释放已持有的资源。</p>
</li>
<li><p><strong>破坏不可剥夺条件</strong>：允许操作系统强制剥夺某些资源，以便将其分配给其他进程。</p>
</li>
<li><p><strong>破坏循环等待条件</strong>：为系统中的所有资源分配一个全局顺序，进程必须按照这个顺序请求资源，从而避免形成循环等待。</p>
</li>
</ul>
<h5 id="2-避免死锁"><a href="#2-避免死锁" class="headerlink" title="2. 避免死锁"></a>2. 避免死锁</h5><p>避免死锁是在资源动态分配过程中，通过算法确保系统不会进入不安全状态。常用的方法包括：</p>
<ul>
<li><p><strong>安全性算法</strong>：例如银行家算法，在分配资源前检查是否会导致系统进入不安全状态。如果会，则拒绝该请求。</p>
</li>
<li><p><strong>动态监控</strong>：实时监测系统状态，确保在任何时刻都不会形成循环等待。</p>
</li>
</ul>
<h5 id="3-检测与恢复"><a href="#3-检测与恢复" class="headerlink" title="3. 检测与恢复"></a>3. 检测与恢复</h5><p>检测与恢复策略允许死锁发生，但会定期检查系统中是否存在死锁。一旦检测到死锁，采取相应措施来解除死锁。常见的恢复方法包括：</p>
<ul>
<li><p><strong>进程撤销</strong>：选择一个或多个进程进行撤销，释放其占有的资源，从而打破死锁状态。</p>
</li>
<li><p><strong>回滚</strong>：将某些进程回滚到之前的状态，以释放资源并重新尝试执行。</p>
</li>
<li><p><strong>抢占</strong>：强制从某个持有者那里夺取资源并分配给其他需要该资源的进程。</p>
</li>
</ul>
<h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h5><table>
<thead>
<tr>
<th>处理策略</th>
<th>方法描述</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>预防</td>
<td>破坏四个必要条件中的至少一个</td>
<td>确保不会发生死锁</td>
<td>可能导致资源利用率低，效率下降</td>
</tr>
<tr>
<td>避免</td>
<td>动态监控和安全性算法，确保不进入不安全状态</td>
<td>灵活性高，能适应变化</td>
<td>实现复杂，需要预测未来资源需求</td>
</tr>
<tr>
<td>检测与恢复</td>
<td>定期检测死锁并采取措施解除</td>
<td>不影响正常运行，可以有效处理已发生的死锁</td>
<td>可能导致部分进程被撤销或回滚，造成损失</td>
</tr>
<tr>
<td>忽略</td>
<td>不采取任何措施，选择忽略死锁</td>
<td>实现简单，适合高性能需求</td>
<td>无法解决实际发生的死锁问题</td>
</tr>
</tbody></table>

        </div>

        

        
            <ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
                
                    <li class="tag-item mx-0.5">
                        <a href="/tags/408/">#408</a>&nbsp;
                    </li>
                
                    <li class="tag-item mx-0.5">
                        <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">#操作系统</a>&nbsp;
                    </li>
                
            </ul>
        

        
  <div class="recommended-article px-2 sm:px-6 md:px-8">
   <div class="recommended-desktop">
    <div class="recommended-article-header text-xl md:text-3xl font-bold mt-10">
     <i aria-hidden="true"></i><span>推荐阅读</span>
    </div>
    <div class="recommended-article-group"><a class="recommended-article-item" href="/2024/07/02/operating-system-1/" title="操作系统笔记01" rel="bookmark">
  <img src="/images/background_light.jpg" alt="操作系统笔记01" class="!max-w-none">
  <span class="title">操作系统笔记01</span>
</a><a class="recommended-article-item" href="/2024/03/20/gdb-3/" title="GDB使用指南-3" rel="bookmark">
  <img src="/images/background_light.jpg" alt="GDB使用指南-3" class="!max-w-none">
  <span class="title">GDB使用指南-3</span>
</a><a class="recommended-article-item" href="/2024/03/23/concurrency-programming-2/" title="并发编程-2" rel="bookmark">
  <img src="/images/background_light.jpg" alt="并发编程-2" class="!max-w-none">
  <span class="title">并发编程-2</span>
</a></div>
   </div>
   <div class="recommended-mobile">
   <div class="recommended-article-header text-xl md:text-3xl font-bold mt-10">
     <i aria-hidden="true"></i><span>推荐阅读</span>
   </div>
   <div class="recommended-article-group"><a class="recommended-article-item" href="/2024/07/02/operating-system-1/" title="操作系统笔记01" rel="bookmark">
  <img src="/images/background_light.jpg" alt="操作系统笔记01" class="!max-w-none">
  <span class="title">操作系统笔记01</span>
</a><a class="recommended-article-item" href="/2024/03/20/gdb-3/" title="GDB使用指南-3" rel="bookmark">
  <img src="/images/background_light.jpg" alt="GDB使用指南-3" class="!max-w-none">
  <span class="title">GDB使用指南-3</span>
</a></div>
   </div>
  </div>

        
            <div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
                
                
                    <div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
                        <a class="next"
                        rel="next"
                        href="/2024/10/04/dockerUsage/"
                        >
                            <span class="title flex justify-center items-center">
                                <span class="post-nav-title-item">docker常用命令</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex justify-center items-center">
                                <i class="fa-solid fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        


        
    </div>

    
        <div class="toc-content-container">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <div class="toc-title">On this page</div>
        <div class="page-title">操作系统02</div>
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B"><span class="nav-text">进程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-text">概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E6%88%90"><span class="nav-text">组成</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#PCB"><span class="nav-text">PCB</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%B9%E5%BE%81"><span class="nav-text">特征</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-text">进程的状态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%80%81"><span class="nav-text">创建态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%B1%E7%BB%AA%E6%80%81"><span class="nav-text">就绪态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%80%81"><span class="nav-text">运行态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E6%80%81"><span class="nav-text">阻塞态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%88%E6%AD%A2%E6%80%81"><span class="nav-text">终止态</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F"><span class="nav-text">进程的组织方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E5%BC%8F%E6%96%B9%E5%BC%8F"><span class="nav-text">链式方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E6%96%B9%E5%BC%8F"><span class="nav-text">索引方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-text">进程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E8%AF%AD"><span class="nav-text">原语</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="nav-text">原子性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3%E5%8E%9F%E8%AF%AD"><span class="nav-text">进程控制相关原语</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="nav-text">进程通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8"><span class="nav-text">共享存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%80%9A%E4%BF%A1"><span class="nav-text">消息通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1%EF%BC%88%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%EF%BC%89"><span class="nav-text">管道通信（循环队列）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5"><span class="nav-text">线程概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7"><span class="nav-text">属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-text">实现方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-text">多线程模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2"><span class="nav-text">线程状态与转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87%E4%B8%8E%E6%8E%A7%E5%88%B6"><span class="nav-text">线程的组织与控制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6"><span class="nav-text">处理机调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">基本概念</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="nav-text">进程调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E6%9C%BA"><span class="nav-text">时机</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E5%BC%8F"><span class="nav-text">方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%87%E6%8D%A2%E4%B8%8E%E8%BF%87%E7%A8%8B"><span class="nav-text">切换与过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%87%E6%8D%A2"><span class="nav-text">切换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%87%E7%A8%8B"><span class="nav-text">过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87"><span class="nav-text">调度算法的评价指标</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CPU%E5%88%A9%E7%94%A8%E7%8E%87"><span class="nav-text">CPU利用率</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E5%90%9E%E5%90%90%E9%87%8F"><span class="nav-text">系统吞吐量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%A8%E8%BD%AC%E6%97%B6%E9%97%B4"><span class="nav-text">周转时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4"><span class="nav-text">响应时间</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%92%8C%E4%BA%92%E6%96%A5"><span class="nav-text">进程同步和互斥</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="nav-text">互斥锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6"><span class="nav-text">信号量机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-text">生产者消费者问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-text">读者写者问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E9%97%AE%E9%A2%98"><span class="nav-text">哲学家问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%A1%E7%A8%8B"><span class="nav-text">管程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-text">死锁</span></a></li></ol></li></ol></li></ol>

    </div>
</div>
        </div>
    
</div>



                

            </div>

            

        </div>

        <div class="main-content-footer">
            <footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2022</span>
              -
            
            2025&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">Raven005</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        31 posts in total
                    </span>
                    
                        <span>
                            83.8k words in total
                        </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://cn.vercount.one/js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">VISITOR COUNT</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">TOTAL PAGE VIEWS</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.7.3</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="article-tools-list">
        <!-- TOC aside toggle -->
        
            <li class="right-bottom-tools page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-side-tools-container">
        <div class="side-tools-container">
    <ul class="hidden-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="visible-tools-list">
        <li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
            <li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fa-solid fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fa-solid fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>


    
<script src="/js/libs/Swup.min.js"></script>

<script src="/js/libs/SwupSlideTheme.min.js"></script>

<script src="/js/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>







<script src="/js/tools/imageViewer.js" type="module"></script>

<script src="/js/utils.js" type="module"></script>

<script src="/js/main.js" type="module"></script>

<script src="/js/layouts/navbarShrink.js" type="module"></script>

<script src="/js/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/layouts/categoryList.js" type="module"></script>



    
<script src="/js/tools/localSearch.js" type="module"></script>




    
<script src="/js/tools/codeBlock.js" type="module"></script>




    
<script src="/js/layouts/lazyload.js" type="module"></script>




    
<script src="/js/tools/runtime.js"></script>

    
<script src="/js/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/libs/Typed.min.js"></script>

  
<script src="/js/plugins/typed.js" type="module"></script>




    
<script src="/js/libs/mermaid.min.js"></script>

    
<script src="/js/plugins/mermaid.js"></script>









    
<script src="/js/tools/tocToggle.js" type="module" data-swup-reload-script=""></script>

<script src="/js/layouts/toc.js" type="module" data-swup-reload-script=""></script>

<script src="/js/plugins/tabs.js" type="module" data-swup-reload-script=""></script>




<script src="/js/libs/moment-with-locales.min.js" data-swup-reload-script=""></script>


<script src="/js/layouts/essays.js" type="module" data-swup-reload-script=""></script>




<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/miku.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":1}});</script></body>
</html>
