<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Raven&#39;s blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-03-13T08:32:08.141Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Raven005</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>操作系统02</title>
    <link href="http://example.com/2024/11/11/operating-system-2/"/>
    <id>http://example.com/2024/11/11/operating-system-2/</id>
    <published>2024-11-11T14:40:06.000Z</published>
    <updated>2025-03-13T08:32:08.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>进程是动态的，是程序的一次执行过程，同一个程序多次执行会对应多个进程</p><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2024/11/11/ZFzQMLamHjBE7Ob.png" alt="进程的组成.png"></p><p>程序段、数据段、PCB三部分组成了进程的实体（进程映像）<br>引入进程实体的概念后，可以把进程定义为：<br>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位</p><blockquote><p>注意： <code>PCB是进程存在的唯一标识</code></p></blockquote><h3 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h3><p>当进程被创建时，操作系统会为该进程分配一个<strong>唯一的、不重复</strong>的”身份证号” PID</p><p>操作系统要记录PID,进程所属用户ID，还要记录给进程分配了哪些资源、进程的运行情况<br>这些信息都被保存在一个数据结构<code>PCB</code>,即进程控制块，操作系统需要对各个并发运行的进程进行管理，<code>但凡管理时所需要的信息，都会被放在PCB中</code></p><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2024/11/11/9ZaJQ1iPj8C2VlA.png" alt="PCB.png"></p><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2024/11/11/cfoRVUtBn3hQq7K.png" alt="进程的特征.png"></p><p>程序是静态的，进程是动态的，动态性是进程最基本的特征</p><h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><pre class="mermaid">flowchart TD    A[创建态] --&gt;|系统完成创建进程的一系列工作| B[就绪态] --&gt;|进程被调度| C[运行态] --&gt;|进程运行结束,或者运行过程中遇到不可修复的错误| D[终止态]    C --&gt;|进程用'系统调用'的方式申请某种系统资源,或者请求等待某个事件发生 | E[阻塞态]    E --&gt;|申请的资源被分配,或等待某个事件发生| B    C --&gt;|时间片到,或处理机被抢占| B    B --&gt;|挂起| F[就绪挂起]    F --&gt;|激活| B    E --&gt;|挂起| G[阻塞挂起]    G --&gt;|激活| E    A --&gt; F    G --&gt;|事件出现| F    C --&gt; F</pre><p>运行态–&gt;到阻塞态是一种进程自身作出的主动行为<br>阻塞态–&gt;就绪态是不是进程自身能控制的，是一种被动行为</p><blockquote><p>注意:</p><ul><li>不能由阻塞态直接转换为运行态，也不能由就绪态直接转换为阻塞态(<code>因为进入阻塞态是进程主动请求的，必然需要进程在运行时才能发出这种请求</code>)</li><li>“挂起”和“阻塞”的区别，两种状态都是暂时不能获得CPU的服务，但挂起态是将进程映像调到外存去了，而阻塞态下进程映像还在内存中</li></ul></blockquote><h3 id="创建态"><a href="#创建态" class="headerlink" title="创建态"></a>创建态</h3><p>进程正在被创建时，它的状态是<code>创建态</code>，在这个阶段操作系统会为进程分配资源、初始化PCB</p><h3 id="就绪态"><a href="#就绪态" class="headerlink" title="就绪态"></a>就绪态</h3><p>当进程被创建完成后，便进入<code>就绪态</code>，处于就绪态的进程已经具备运行条件，但由于没有空闲CPU,就暂时不能运行</p><h3 id="运行态"><a href="#运行态" class="headerlink" title="运行态"></a>运行态</h3><p>如果一个进程此时在CPU上运行，那么这个进程处于<code>运行态</code></p><h3 id="阻塞态"><a href="#阻塞态" class="headerlink" title="阻塞态"></a>阻塞态</h3><p>在进程运行的过程中，可能会请求等待某个时间的发生(如等待某种系统资源分配，或者等待其他进程的响应)，在这个事件发生之前，进程无法继续往下执行，此时操作系统会让这个进程下CPU,并让他进入<code>阻塞态</code><br>当CPU空闲时，又会选择另一个<code>就绪态</code>进程上CPU运行</p><h3 id="终止态"><a href="#终止态" class="headerlink" title="终止态"></a>终止态</h3><p>一个进程可以执行exit系统调用，请求操作系统终止该进程，此时该进程会进入<code>终止态</code>，操作系统会让该进程下CPU,并回收内存空间等资源，最后还要回收该进程的PCB</p><h2 id="进程的组织方式"><a href="#进程的组织方式" class="headerlink" title="进程的组织方式"></a>进程的组织方式</h2><h3 id="链式方式"><a href="#链式方式" class="headerlink" title="链式方式"></a>链式方式</h3><ul><li>按照进程状态将PCB分为多个队列</li><li>操作系统持有指向各个队列的指针</li></ul><h3 id="索引方式"><a href="#索引方式" class="headerlink" title="索引方式"></a>索引方式</h3><ul><li>根据进程状态的不同，建立几张索引表</li><li>操作系统持有指向各个索引表的指针</li></ul><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="原语"><a href="#原语" class="headerlink" title="原语"></a>原语</h3><p>原语是一种特殊的程序，它的执行具有原自行。也就是说这段程序的运行必须一气呵成，不可中断</p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>可以用“关中断指令”和“开中断指令”实现原子性</p><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2024/10/13/eSvaALZ4ObCm8Uq.png" alt="原子性.png"></p><h3 id="进程控制相关原语"><a href="#进程控制相关原语" class="headerlink" title="进程控制相关原语"></a>进程控制相关原语</h3><h4 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h4><ol><li><p>创建原语</p><ul><li>申请空白PCB</li><li>为新进程分配所需资源</li><li>初始化PCB</li><li>将PCB插入就绪队列 创建态–&gt;就绪态</li></ul></li><li><p>引起进程创建的事件</p><ul><li>用户登录<ul><li>分时系统中，用户登录成功，系统会为其建立一个新进程</li><li>作业调度，多道批处理系统，有新的作业放入内存时，会为其建立一个新的进程</li><li>提供服务，用户向操作系统提出某些请求时，会新建一个进程处理该请求</li><li>应用请求，由用户进程主动请求创建一个子进程</li></ul></li></ul></li></ol><h4 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h4><ol><li><p>撤销原语</p><ul><li>从PCB集合中找到终止进程的PCB</li><li>若进程正在运行，立即剥夺CPU,将CPU分配给其他进程</li><li>终止其所有子进程</li><li>将该进程拥有的所有资源归还给父进程或操作系统</li></ul></li><li><p>引起进程终止的事件</p><ul><li>正常结束</li><li>异常结束</li><li>外界干预</li></ul></li></ol><h4 id="进程阻塞"><a href="#进程阻塞" class="headerlink" title="进程阻塞"></a>进程阻塞</h4><ol><li><p>进程的阻塞</p><ul><li>阻塞原语 运行态–&gt;阻塞态<ul><li>找到要阻塞的进程对应PCB</li><li>保护进程运行现场，将PCB状态信息设置为“阻塞态”，展示停止进程运行</li><li>将PCB插入相应事件的等待队列</li></ul></li><li>引起进程阻塞的事件<ul><li>需要等待系统分配某种资源</li><li>需要等待相互合作的其他进程完成工作</li></ul></li></ul></li><li><p>进程的唤醒</p><ul><li>唤醒原语<ul><li>在事件等待队列中找到PCB</li><li>将PCB从等待队列中移除，设置进程为就绪态</li><li>将PCB插入就绪队列，等待被调度</li></ul></li><li>引起进程唤醒的事件<ul><li>等待事件的发生</li></ul></li></ul></li></ol><h4 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h4><ol><li>切换原语<ul><li>将运行环境信息存入PCB</li><li>PCB移入相应队列</li><li>选择另一个进程执行，并更新其PCB</li><li>根据PCB恢复新进程所需的运行环境</li></ul></li><li>引起进程切换的事件<ul><li>当前进程时间片到</li><li>有更高优先级的进程到达</li><li>当前进程主动阻塞</li><li>当前进程终止</li></ul></li></ol><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><h3 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h3><ul><li>基于数据结构的共享: 比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种<strong>低级通信方式</strong></li><li>基于存储区的共享: 操作系统在内存中划出一块共享存储区，数据的形式、存放位置都由通信进程控制，而不是操作系统。这种共享方式速度很快，是一种<strong>高级通信方式</strong></li></ul><h3 id="消息通信"><a href="#消息通信" class="headerlink" title="消息通信"></a>消息通信</h3><ul><li>直接通信方式</li></ul><p>消息传送进程要指明接受进程的ID</p><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2024/10/19/qUKygHXkmvCuV9E.png" alt="直接通信.png"></p><ul><li>间接通信方式</li></ul><p>通过“信箱”间接的通信。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2024/10/19/BthUpkoEsmRxQDc.png" alt="间接通信.png"></p><h3 id="管道通信（循环队列）"><a href="#管道通信（循环队列）" class="headerlink" title="管道通信（循环队列）"></a>管道通信（循环队列）</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2024/10/19/2jDbBaEivdwr1Fy.png" alt="管道通信.png"></p><p>管道通信和共享存储在于管道通信的读写都是先进先出的</p><ol><li><p>管道只能采用<strong>半双工通信</strong>，某一之间段内只能采用半双工通信，某一时间段内只能实现单向的传输。如果要实现<strong>双向同时通信</strong>，则<strong>需要设置两个管道</strong></p></li><li><p>各进程要互斥访问管道（由操作系统实现）</p></li><li><p>当<strong>管道写满</strong>时，<strong>写进程</strong>将<strong>阻塞</strong>，知道读进程将管道中的数据取走，即可唤醒写进程</p></li><li><p>当<strong>管道读空</strong>时，<strong>读进程</strong>将<strong>阻塞</strong>，知道写进程往管道写入数据，即可唤醒读进程</p></li><li><p>管道中的数据一旦被读出，就彻底消失。因此，当多个进程读同一个管道时，可能会错乱。对此，通常有两种解决方案</p><ol><li><strong>一个管道允许多个写进程，一个读进程</strong></li><li>允许有<strong>多个写进程，多个读进程</strong>，但系统会让各个读进程轮流从管道中读数据(linux)</li></ol></li></ol><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h3><p>线程是一个基本的CPU执行单元，也是程序执行流的最小单位</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li>线程是处理机调度的基本单位</li><li>多CPU计算机中，各个县城可占用不同的CPU</li><li>每个线程都有一个线程ID、线程控制块(TCB)</li><li>线程也有就绪、阻塞、运行三种基本状态</li><li>线程几乎不拥有系统资源</li><li>同一进程的不同线程间共享进程的资源</li><li>由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预</li><li>同一进程中的线程切换，不会引起进程切换</li><li>不同进程中的线程切换，会引起进程切换</li><li>切换同进程内的线程，系统开销很小</li><li>切换进程，系统开销比较大</li></ul><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><h4 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2024/10/19/PHROKcFw2eoZ6Mz.png" alt="用户级线程.png"></p><h4 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a>内核级线程</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2024/10/19/TNZQCUxvphPtOSk.png" alt="内核级线程.png"></p><h3 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h3><h4 id="一对一模型"><a href="#一对一模型" class="headerlink" title="一对一模型"></a>一对一模型</h4><p>每个用户级线程都对应一个内核级线程</p><ul><li><p>优点</p><ul><li><strong>提高了并发性</strong>：当一个线程进行阻塞系统调用时，其他线程可以继续执行。</li><li><strong>更好的并行性</strong>：在多处理器架构中，多线程可在多核处理机上并行执行。</li></ul></li><li><p>缺点</p><ul><li><strong>资源消耗较高</strong>：由于每个用户级线程都需要一个内核级线程来对应，这可能会增加系统的开销和复杂度。</li></ul></li></ul><h4 id="多对一模型"><a href="#多对一模型" class="headerlink" title="多对一模型"></a>多对一模型</h4><p>在多线程的多对一模型中，多个用户级线程被映射到一个内核级线程上,且一个进程只被分配一个内核级线程上</p><ul><li><p>优点</p><ul><li><strong>资源管理效率高</strong>：由于线程管理主要由用户空间的线程库处理，不需要切换到核心态，这使得该模型相对高效。</li><li><strong>减少开销</strong>：与一对一模型相比，多对一模型减少了内核级别的上下文切换次数，从而降低了系统开销。</li></ul></li><li><p>缺点</p><ul><li><strong>资源竞争严重</strong>：当一个用户级线程进行阻塞系统调用时，所有其他用户级线程都会被阻塞。</li></ul></li></ul><h4 id="多对多模型"><a href="#多对多模型" class="headerlink" title="多对多模型"></a>多对多模型</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2024/10/19/8oBOAwD32GZ9qN6.png" alt="多对多模型.png"></p><h3 id="线程状态与转换"><a href="#线程状态与转换" class="headerlink" title="线程状态与转换"></a>线程状态与转换</h3><pre class="mermaid">flowchart TDA[就绪] --&gt;|被调度程序选中| B[运行]B --&gt;|时间用完| AB --&gt;|等待某事件| C[阻塞]C --&gt;|等待的事件发生| A</pre><h3 id="线程的组织与控制"><a href="#线程的组织与控制" class="headerlink" title="线程的组织与控制"></a>线程的组织与控制</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2024/10/19/t1ZHYzvU3Ob9Sh6.png" alt="线程的组织与控制.png"></p><h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>调度器通过选择就绪队列中的一个进程并将其分配给CPU来实现这一目标。这使得多个进程能够在有限的硬件资源下并发执行，从而提高系统的整体性能和响应速度</p><ul><li><p><strong>分类与层次</strong>：调度可以根据不同的标准进行分类，通常分为三个层次：</p><ul><li><strong>高级调度（作业调度）</strong>：决定哪些作业或任务被加载到系统中。</li><li><strong>中级调度（内存调度）</strong>：管理进程在主存中的驻留和交换。</li><li><strong>低级调度（进程调度或时间片轮转）</strong>：决定当前CPU时间片由哪个进程使用</li></ul></li></ul><table><thead><tr><th>调度类别</th><th>要做什么</th><th>发生地</th><th>发生频率</th><th>对进程状态的影响</th></tr></thead><tbody><tr><td>高级调度(作业调度)</td><td>按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程</td><td>外存-&gt;内存(面向作业)</td><td>最低</td><td>无-&gt;创建态-&gt;就绪态</td></tr><tr><td>中级调度(内存调度)</td><td>按照某种规则，从挂起队列中选择合适的进程将其数据回调内存</td><td>外存-&gt;内存(面向进程)</td><td>中等</td><td>挂起态-&gt;就绪态(阻塞挂起-&gt;阻塞态)</td></tr><tr><td>低级调度(进程调度)</td><td>按照某种规则，从就绪队列中选择一个进程为其分配处理机</td><td>内存-&gt;CPU</td><td>最高</td><td>就绪态-&gt;运行态</td></tr></tbody></table><h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><p>进程调度（低级调度）就是按照某种算法从就绪队列中选择一个进程为其分配进程</p><h3 id="时机"><a href="#时机" class="headerlink" title="时机"></a>时机</h3><p>需要进行进程调度与切换的情况</p><ul><li><p>当前运行的进程<code>主动放弃</code>处理机</p><ul><li>进程正常终止</li><li>运行过程中发生异常</li><li>进程主动请求阻塞</li></ul></li><li><p>当前运行的进程<code>被动放</code>弃处理机</p><ul><li>分给进程的时间片用完</li><li>有更紧急的事需要处理(I/O中断)</li><li>有更高优先级的进程进入就绪队列</li></ul></li><li><p>不能进行进程调度与切换情况</p><ul><li>在处理中断的过程中</li><li>进程在操作系统内核临界区中,但是进程在普通临界区中是可以进行调度、切换的</li><li>在原子操作过程中。原子操作不可中断，要一气呵成</li></ul></li></ul><h2 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h2><p>非剥夺调度方式(非抢占式)</p><ul><li>一旦某个进程获得了CPU的控制权，它就会一直运行，直到该进程主动放弃CPU（例如，因为等待I/O操作完成或因为进程结束）。在此期间，即使有更高优先级的进程到达，也不会中断当前进程的执行。</li></ul><p>剥夺调度式(抢占方式)</p><ul><li>指操作系统可以在任何时刻中断当前正在运行的进程，并将CPU分配给另一个进程。这种中断通常发生在时间片用完、更高优先级的进程到达或某些特定事件发生时。</li></ul><h2 id="切换与过程"><a href="#切换与过程" class="headerlink" title="切换与过程"></a>切换与过程</h2><blockquote><p>注意<br>频繁的进程调度、切换会让整个操作系统效率降低，使系统大部分时间都花在进程切换上，属于进程执行的时间减少了</p></blockquote><h3 id="切换"><a href="#切换" class="headerlink" title="切换"></a>切换</h3><p>“狭义的进程调度”与“进程切换的区别”</p><ul><li>狭义的进程调度指的是从就绪队列中选中一个要运行的进程</li><li>进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程</li></ul><p>“广义的进程调度”包含了选择一个进程和进程切换两个步骤</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>进程的切换主要完成:</p><ul><li>对原来运行进程各种数据的保存</li><li>对新的进程各种数据的恢复</li></ul><h2 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a>调度算法的评价指标</h2><h3 id="CPU利用率"><a href="#CPU利用率" class="headerlink" title="CPU利用率"></a>CPU利用率</h3><p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -2.059ex;" xmlns="http://www.w3.org/2000/svg" width="19.85ex" height="5.285ex" role="img" focusable="false" viewBox="0 -1426 8773.6 2336"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">利</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">用</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">率</text></g></g><g data-mml-node="mo" transform="translate(3277.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(4333.6,0)"><g data-mml-node="mrow" transform="translate(220,676)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">忙</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">绿</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g></g><g data-mml-node="mrow" transform="translate(720,-710)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">总</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g></g><rect width="4200" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container></p><h3 id="系统吞吐量"><a href="#系统吞吐量" class="headerlink" title="系统吞吐量"></a>系统吞吐量</h3><p>单位时间内完成的作业数量</p><p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -2.059ex;" xmlns="http://www.w3.org/2000/svg" width="37.949ex" height="5.285ex" role="img" focusable="false" viewBox="0 -1426 16773.6 2336"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">系</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">统</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">吞</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">吐</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">量</text></g></g><g data-mml-node="mo" transform="translate(5277.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(6333.6,0)"><g data-mml-node="mrow" transform="translate(220,676)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">总</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">共</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">完</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">成</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">了</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">多</text></g><g data-mml-node="mi" transform="translate(6000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">少</text></g><g data-mml-node="mi" transform="translate(7000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">道</text></g><g data-mml-node="mi" transform="translate(8000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">作</text></g><g data-mml-node="mi" transform="translate(9000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">业</text></g></g><g data-mml-node="mrow" transform="translate(1220,-710)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">总</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">共</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">花</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">了</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">多</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">少</text></g><g data-mml-node="mi" transform="translate(6000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(7000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g></g><rect width="10200" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container></p><h3 id="周转时间"><a href="#周转时间" class="headerlink" title="周转时间"></a>周转时间</h3><p>从作业被提交给系统开始，到作业完成为止的这段时间间隔</p><p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="48.267ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 21334 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(389,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">作</text></g><g data-mml-node="mi" transform="translate(1389,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">业</text></g><g data-mml-node="mo" transform="translate(2389,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(2778,0)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">周</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">转</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g></g><g data-mml-node="mo" transform="translate(7055.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(8111.6,0)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">作</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">业</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">完</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">成</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g></g><g data-mml-node="mo" transform="translate(14333.8,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(15334,0)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">作</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">业</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">提</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">交</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g></g></g></g></svg></mjx-container></p><p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -2.059ex;" xmlns="http://www.w3.org/2000/svg" width="37.949ex" height="5.285ex" role="img" focusable="false" viewBox="0 -1426 16773.6 2336"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">平</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">均</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">周</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">转</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g></g><g data-mml-node="mo" transform="translate(6277.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(7333.6,0)"><g data-mml-node="mrow" transform="translate(220,676)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">各</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">作</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">业</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">周</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">转</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(6000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g><g data-mml-node="mi" transform="translate(7000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">之</text></g><g data-mml-node="mi" transform="translate(8000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">和</text></g></g><g data-mml-node="mrow" transform="translate(3220,-710)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">作</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">业</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">数</text></g></g><rect width="9200" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container></p><p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -2.059ex;" xmlns="http://www.w3.org/2000/svg" width="69.614ex" height="5.285ex" role="img" focusable="false" viewBox="0 -1426 30769.6 2336"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">带</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">权</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">周</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">转</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g><g data-mml-node="mo" transform="translate(6277.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(7333.6,0)"><g data-mml-node="mrow" transform="translate(1220,676)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">作</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">业</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">周</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">转</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g></g><g data-mml-node="mrow" transform="translate(220,-710)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">作</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">业</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">实</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">际</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">运</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">行</text></g><g data-mml-node="mi" transform="translate(6000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(7000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g></g><rect width="8200" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(16051.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(17107.1,0)"><g data-mml-node="mrow" transform="translate(220,676)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">作</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">业</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">完</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">成</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g><g data-mml-node="mo" transform="translate(6222.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(7222.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">作</text></g><g data-mml-node="mi" transform="translate(8222.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">业</text></g><g data-mml-node="mi" transform="translate(9222.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">提</text></g><g data-mml-node="mi" transform="translate(10222.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">交</text></g><g data-mml-node="mi" transform="translate(11222.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(12222.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g></g><g data-mml-node="mrow" transform="translate(2831.2,-710)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">作</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">业</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">实</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">际</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">运</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">行</text></g><g data-mml-node="mi" transform="translate(6000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(7000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g></g><rect width="13422.4" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container></p><blockquote><p>注意<br>带权周转时间必然&gt;=1</p></blockquote><p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -2.059ex;" xmlns="http://www.w3.org/2000/svg" width="46.999ex" height="5.285ex" role="img" focusable="false" viewBox="0 -1426 20773.6 2336"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">平</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">均</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">带</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">权</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">周</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">转</text></g><g data-mml-node="mi" transform="translate(6000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(7000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g><g data-mml-node="mo" transform="translate(8277.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(9333.6,0)"><g data-mml-node="mrow" transform="translate(220,676)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">各</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">作</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">业</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">带</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">权</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">周</text></g><g data-mml-node="mi" transform="translate(6000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">转</text></g><g data-mml-node="mi" transform="translate(7000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(8000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g><g data-mml-node="mi" transform="translate(9000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">之</text></g><g data-mml-node="mi" transform="translate(10000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">和</text></g></g><g data-mml-node="mrow" transform="translate(4220,-710)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">作</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">业</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">数</text></g></g><rect width="11200" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container></p><h3 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h3><p>从用户提交请求到首次产生响应的时间</p><h2 id="进程同步和互斥"><a href="#进程同步和互斥" class="headerlink" title="进程同步和互斥"></a>进程同步和互斥</h2><h4 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h4><p>同步也叫直接制约关系，是指为完成某种任务而建立的两个或多个进程，这些进程是因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作</p><h4 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h4><p>我们把<code>一个时间段内只允许一个进程</code>使用的资源叫做<code>临界资源</code><br>进程互斥是指当一个进程访问某个临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源</p><p>对进程的互斥访问:</p><ul><li>进入区：负责检查是否可进入临界区，若可进入，则设置”正在访问临界资源标志”</li><li>临界区：访问临界资源的那段代码</li><li>退出区：负责解除“正在访问临界资源的标志”（解锁）</li><li>剩余区：其他处理</li></ul><blockquote><p>注意</p><ul><li>临界区是进程中访问临界资源的代码段</li><li>进入区和退出区是负责实现互斥的代码段</li><li>临界区可称为”临界段”</li></ul></blockquote><p>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则:</p><ol><li>空闲让进: 临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区</li><li>忙则等待: 当已有进程进入临界区时，其他试图进入临界区的进程必须等待</li><li>有限等待: 对请求访问的进程，应保证能在有限时间内进入临界区</li><li>让权等待: 当进程不能进入临界区，应立即释放处理机，防止进程忙等待</li></ol><h4 id="进程互斥的软件实现方法"><a href="#进程互斥的软件实现方法" class="headerlink" title="进程互斥的软件实现方法"></a>进程互斥的软件实现方法</h4><h5 id="单步标志法"><a href="#单步标志法" class="headerlink" title="单步标志法"></a>单步标志法</h5><p>单标志法的算法思想是：两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予。具体实现过程如下：</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> turn = <span class="number">0</span>; <span class="comment">//表示当前允许进入临界区的进程号</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P1</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">while</span>(turn != <span class="number">0</span>) { <span class="comment">// 进入区</span></span><br><span class="line">        <span class="comment">// critical section 临界区</span></span><br><span class="line">        turn = <span class="number">1</span>; <span class="comment">// 退出区</span></span><br><span class="line">        <span class="comment">// remainder seciont  剩余区</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P2</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">while</span>(turn != <span class="number">1</span>) {</span><br><span class="line">        <span class="comment">// critical section</span></span><br><span class="line">        turn = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// remainder seciont</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>对于turn表示当前允许进入临界区的进程号，而只有当前允许进入临界区的进程在访问了临界区之后，才会修改turn的值。也就是说，对于临界区的访问，一定是按p0→p1→p0→p1…这样轮流访问。</p><p>这种必须轮流访问带来的问题是，如果此时允许进入临界区的进程是P0，而P0一直不访问临界区，那么虽然此时临界区空闲，但是并不允许P1访问。因此对于单标志法，其违背了空闲让进的原则。</p><h5 id="双标志先检查法"><a href="#双标志先检查法" class="headerlink" title="双标志先检查法"></a>双标志先检查法</h5><p>双标志先检查法的算法思想是：设置一个布尔型数组flag[]，数组中各个元素用来标记各进程想进入临界区的意愿，比如flag[0] = true意味着0号进程p0现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志flag[i]设为true，之后开始访问临界区。</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>] = {<span class="literal">false</span>, <span class="literal">false</span>};</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P1</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">while</span>(flag[<span class="number">1</span>] );  <span class="comment">// 1</span></span><br><span class="line">    flag[<span class="number">0</span>] = <span class="literal">true</span>; <span class="comment">// 2</span></span><br><span class="line">    <span class="comment">//critical section // 3</span></span><br><span class="line">    flag[<span class="number">0</span>] = <span class="literal">false</span>; <span class="comment">// 4</span></span><br><span class="line">    <span class="comment">//remainder section</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P2</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">while</span>(flag[<span class="number">0</span>]); <span class="comment">// 5</span></span><br><span class="line">    flag[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 6</span></span><br><span class="line">    <span class="comment">//critical section // 7</span></span><br><span class="line">    flag[<span class="number">1</span>] = <span class="literal">false</span>; <span class="comment">// 8</span></span><br><span class="line">    <span class="comment">//remainder section</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p>需要注意的是，如果按照152637的顺序执行，p0和p1将会同时访问临界区。因此对于双标志先检查法，其违背了忙则等待的原则。</p><p>之所以造成这种问题，就是因为进入区的检查和上锁不是原子操作，在检查完的下一步还没上锁很有可能发生其他事件。</p><h5 id="双标志后检查法"><a href="#双标志后检查法" class="headerlink" title="双标志后检查法"></a>双标志后检查法</h5><p>双标志后检查法的思想是：既然先检查后上锁不行，那我就先上锁，然后在检查。</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>] = {<span class="literal">false</span>, <span class="literal">false</span>};</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P0</span><span class="params">()</span> {</span><br><span class="line">    flag[<span class="number">0</span>] = <span class="literal">true</span>; <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">while</span>(flag[<span class="number">1</span>]); <span class="comment">// 2</span></span><br><span class="line">    <span class="comment">//critical section // 3</span></span><br><span class="line">    flag[<span class="number">0</span>] = <span class="literal">false</span>; <span class="comment">// 4</span></span><br><span class="line">    <span class="comment">//remainder section</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P1</span><span class="params">()</span> {</span><br><span class="line">    flag[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 5</span></span><br><span class="line">    <span class="keyword">while</span>(flag[<span class="number">0</span>]); <span class="comment">// 6</span></span><br><span class="line">    <span class="comment">//critical section // 7</span></span><br><span class="line">    flag[<span class="number">1</span>] = <span class="literal">false</span>; <span class="comment">// 8</span></span><br><span class="line">    <span class="comment">//remainder section</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>需要注意的是，如果按照1526的顺序执行，p0和p1将都无法进入临界区。</p><p>因此双标志后检查法虽然解决了忙则等待的问题，但是又违背了空闲让进和有限等待原则，因为如果各进程都长期无法访问临界资源会产生饥饿现象。</p><h5 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h5><p>在双标志后检查法中，两个进程都争着想进入临界区，但是谁也不让谁，既然这样，那只需要有人礼让即可解决问题。</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>] = {<span class="literal">false</span>, <span class="literal">false</span>};</span><br><span class="line"><span class="type">int</span> turn = <span class="number">0</span>; <span class="comment">// 表示优先让哪个进程进入临界区</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P0</span><span class="params">()</span> {</span><br><span class="line">    flag[<span class="number">0</span>] = <span class="literal">true</span>; <span class="comment">// 1</span></span><br><span class="line">    turn = <span class="number">1</span>; <span class="comment">// 2  可以让对方先进入临界区</span></span><br><span class="line">    <span class="keyword">while</span>(flag[<span class="number">1</span>] &amp;&amp; turn == <span class="number">1</span>); <span class="comment">// 3</span></span><br><span class="line">    <span class="comment">//critical section // 4</span></span><br><span class="line">    flag[<span class="number">0</span>] = <span class="literal">false</span>; <span class="comment">// 5</span></span><br><span class="line">    <span class="comment">//remainder section</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P1</span><span class="params">()</span> {</span><br><span class="line">    flag[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 6</span></span><br><span class="line">    turn = <span class="number">0</span>; <span class="comment">// 7</span></span><br><span class="line">    <span class="keyword">while</span>(flag[<span class="number">0</span>] &amp;&amp; turn == <span class="number">0</span>); <span class="comment">// 8</span></span><br><span class="line">    <span class="comment">//critical section // 9</span></span><br><span class="line">    flag[<span class="number">1</span>] = <span class="literal">false</span>; <span class="comment">// 10</span></span><br><span class="line">    <span class="comment">//remainder section</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p>如果按照123678的顺序，则相当于串行执行，这种方式肯定可以执行。</p><p>如果按照162378的顺序，那么进程0表明自己想进入临界区，进程1表明自己想进入临界区，回到2步骤，0进程表示愿意先让给1进程执行，然后在检查1也有意愿进入临界区和自己已经让位的情况下，自己处于等待状态。这时候回到7步骤，1号进程也表示自己愿意先让给0进程执行，然后在检查0也有意愿进入临界区和自己已经让位的情况下，自己也处于等待状态。此时回到步骤3，0号进程发现turn被修改为0了，说明自己可以不用等待让位了，先行一步作为后回到步骤8，进程P1也顺利做完了。</p><p>尽管Peterson算法用软件方法解决了进程互斥问题，遵循了空闲让进、忙则等待、有限等待三个原则，但是依然未遵循让权等待原则。但是相较于前面三种算法，其本身已然是最好</p><h4 id="进程互斥的硬件实现方法"><a href="#进程互斥的硬件实现方法" class="headerlink" title="进程互斥的硬件实现方法"></a>进程互斥的硬件实现方法</h4><h5 id="中断屏蔽方法"><a href="#中断屏蔽方法" class="headerlink" title="中断屏蔽方法"></a>中断屏蔽方法</h5><h6 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h6><p>中断屏蔽是指在某个进程或中断处理程序进入临界区之前，暂时禁止系统接收新的中断请求。这样做的目的是确保当前进程在执行临界区代码时不会被其他中断处理程序打断，从而避免并发访问导致的数据不一致问题。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2024/11/02/Yj3DG4NtRFrImzf.png" alt="中断屏蔽方法.png"></p><h5 id="TestAndSet指令"><a href="#TestAndSet指令" class="headerlink" title="TestAndSet指令"></a>TestAndSet指令</h5><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2024/11/02/I3zMS9iCoHJnc6v.png" alt="TestAndSet.png"></p><p>优点：</p><ul><li>实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞，适用于多处理机环境</li></ul><p>缺点:</p><ul><li>忙等待：未获取锁的线程会不断循环等待，占用 CPU 资源，影响系统性能。</li><li>不适合长时间临界区：对于长时间的临界区访问，忙等待会导致 CPU 资源浪费。</li><li>多处理机环境：在多处理机系统中，TAS 指令只能确保当前处理器上的同步，无法阻止其他处理器上的线程访问共享资源。</li></ul><h5 id="swap指令"><a href="#swap指令" class="headerlink" title="swap指令"></a>swap指令</h5><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2024/11/02/ZuNwMVpD6YsLioq.png" alt="swap指令.png"></p><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>一个进程在进入临界区时应获得锁，在推出临界区时释放锁。函数<code>acquire</code>获得锁，函数<code>release</code>释放锁。</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">acquire() {</span><br><span class="line">    <span class="keyword">while</span> (!available);</span><br><span class="line">    available = <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line">release() {</span><br><span class="line">    available = <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><blockquote><p>注意<br>acquire() 和 release() 函数都是原子操作，因此互斥锁通常采用硬件机制实现</p></blockquote><p>特性：</p><ul><li><p>优点：</p><ul><li>等待期间不用切换进程上下文，多处理器系统中，若上锁的时间短，则等待代价很低</li></ul></li><li><p>缺点：</p><ul><li>需忙等，进程时间片用完才下处理机，违反“让权等待”</li><li>忙等待： 当有一个进程在临界区中，任何其他进程在进入临界区时必须连续循环调用<code>acquire()</code>。当多个进程共享统一CPU时，就浪费了CPU周期。</li></ul></li><li><p>常用于多处理器系统，一个核忙等，其他核照常工作，并快速释放临界区</p></li><li><p>不太适用于但处理机系统，忙等的过程中不可能解锁</p></li></ul><h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><p>信号量是一个整数值，通常用于表示可用资源的数量。它可以分为两种类型：</p><ul><li>整型信号量最初Dijkstra把整型信号量定义为一个用于表示资源数目的整型量S，它与一般的整型量不同，除初始化外，仅能通过两个标准原子操作（Atomic Operation）wait(S)和signal(S)操作可以描述为：</li></ul><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> S = <span class="number">1</span>; <span class="comment">// 表示当前系统中可用的资源数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> S)</span>: <span class="comment">// wait原语，相当于进入区</span></span><br><span class="line">    <span class="title function_">while</span><span class="params">(S&lt;=<span class="number">0</span>)</span>; <span class="comment">// 如果资源数不够就循环等待</span></span><br><span class="line">    S = S - <span class="number">1</span>; <span class="comment">// 如果资源数够，就占用一个资源</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal</span> <span class="params">(<span class="type">int</span> S)</span>: <span class="comment">// signal原语，相当于退出区</span></span><br><span class="line">    S = S + <span class="number">1</span>; <span class="comment">// 使用完资源后，在退出区释放资源</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div><ul><li>记录型信号量在整型信号量机制中的wait操作，只要是信号量S&lt;=0,就会不断测试。因此，该机制并未遵循“让权等待”准则，而是使进程处于“忙等”状态。记录型信号量机制则是一种不存在“忙等”现象的进程同步机制。但在采取了“让权等待”的策略后，又会出现多个进程等待访问同一个临界资源的情况。为此，在信号量机制中，除了需要一个用于代表资源数目的整型变量value外，还应该增加一个进程链表指针L，用于链接上述的所有等待进程。记录型信号量是由于它采用了记录型的数据结构而得名的。它所包含的上述两个数据项可以描述为：type semaphore=recordvalue:integerL:list of process;end相应的，wait(S)和signal(S)的操作可描述为</li></ul><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="type">int</span> value; <span class="comment">// 剩余资源数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">L</span>;</span> <span class="comment">// 等待队列</span></span><br><span class="line">} semaphore;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">wait</span><span class="params">(semaphore S)</span> {</span><br><span class="line">    S.value --;</span><br><span class="line">    <span class="keyword">if</span>(S.value &lt; <span class="number">0</span>) {</span><br><span class="line">        block(S.L); <span class="comment">// 如果资源数量不够，就用block将进程从运行态进入阻塞态，并把挂到信号量S的等待队列中</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal</span><span class="params">(semaphore S)</span> {</span><br><span class="line">    S.value ++;</span><br><span class="line">    <span class="keyword">if</span>(S.value &lt;= <span class="number">0</span>) {</span><br><span class="line">        wakeup(S.L); <span class="comment">// 释放资源后，若还有别的进程在等待这种资源，则使用wakeup唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h4 id="操作机制"><a href="#操作机制" class="headerlink" title="操作机制"></a>操作机制</h4><p>信号量机制主要通过两个操作来实现：</p><ul><li><p>P操作（wait）：<br>当进程想要进入临界区时，它会执行P操作，将信号量的值减1。<br>如果减1后信号量的值大于或等于0，进程可以继续执行；如果小于0，进程会被阻塞，进入等待队列。</p></li><li><p>V操作（signal）：<br>当进程离开临界区时，它会执行V操作，将信号量的值加1。<br>如果有其他进程在等待该信号量，则其中一个等待的进程将被唤醒。</p></li></ul><h4 id="实现进程互斥"><a href="#实现进程互斥" class="headerlink" title="实现进程互斥"></a>实现进程互斥</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2024/11/04/EbnIucekK2zmo6U.png" alt="信号量实现进程互斥.png"></p><ol><li><p><strong>定义信号量</strong>：</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>; <span class="comment">// 初始化互斥信号量</span></span><br></pre></td></tr></table></figure></div></li><li><p><strong>进入临界区前的操作（P操作）</strong>：<br>在进程要访问临界区之前，必须执行P（wait）操作以请求对资源的访问。这一操作会将信号量的值减1：</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P(mutex); <span class="comment">// 请求进入临界区</span></span><br></pre></td></tr></table></figure></div></li><li><p><strong>临界区代码</strong>：<br>进程在临界区内执行需要互斥访问的代码。此时，其他进程无法进入该区域。</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 临界区代码段</span></span><br></pre></td></tr></table></figure></div></li><li><p><strong>离开临界区后的操作（V操作）</strong>：<br>当进程完成对共享资源的访问后，必须执行V（signal）操作来释放资源，将信号量的值加1，从而允许其他等待的进程进入临界区：</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">V(mutex); <span class="comment">// 释放临界区</span></span><br></pre></td></tr></table></figure></div></li></ol><h5 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h5><p>以下是一个简单的示例，展示了如何使用信号量实现进程互斥：</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>; <span class="comment">// 初始化信号量为1</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">process1</span><span class="params">()</span> {</span><br><span class="line">    P(mutex); <span class="comment">// 请求进入临界区</span></span><br><span class="line">    <span class="comment">// 临界区代码段...</span></span><br><span class="line">    V(mutex); <span class="comment">// 离开临界区</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">process2</span><span class="params">()</span> {</span><br><span class="line">    P(mutex); <span class="comment">// 请求进入临界区</span></span><br><span class="line">    <span class="comment">// 临界区代码段...</span></span><br><span class="line">    V(mutex); <span class="comment">// 离开临界区</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h5 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h5><ul><li><strong>互斥性</strong>：通过将信号量初值设置为1，确保同一时间只能有一个进程进入临界区。</li><li><strong>阻塞与唤醒</strong>：如果一个进程在执行P操作时发现信号量值为0，则该进程会被阻塞，直到其他进程执行V操作并唤醒它。</li><li><strong>原子性</strong>：P和V操作通常被实现为原子操作，以防止中断，从而避免竞争条件。</li></ul><h4 id="实现进程同步"><a href="#实现进程同步" class="headerlink" title="实现进程同步"></a>实现进程同步</h4><ol><li><p><strong>分析同步需求</strong>：<br>确定哪些操作需要同步，即需要保证某些操作按顺序执行。例如，若进程P1的某个操作必须在进程P2的操作之前完成，则需要实现同步。</p></li><li><p><strong>设置同步信号量</strong>：<br>创建一个信号量，初始值设置为0。这个信号量用于控制两个或多个操作之间的顺序。</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">semaphore sync = <span class="number">0</span>; <span class="comment">// 初始化同步信号量为0</span></span><br></pre></td></tr></table></figure></div></li><li><p><strong>在“前操作”后执行V操作</strong>：<br>在需要确保先执行的操作完成后，调用V操作以释放信号量。</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前操作代码</span></span><br><span class="line">V(sync); <span class="comment">// 释放信号量</span></span><br></pre></td></tr></table></figure></div></li><li><p><strong>在“后操作”前执行P操作</strong>：<br>在需要确保后执行的代码之前，调用P操作以请求信号量。如果信号量值为0，则当前进程会被阻塞，直到其他进程释放该信号量。</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">P(sync); <span class="comment">// 请求信号量</span></span><br><span class="line"><span class="comment">// 后操作代码</span></span><br></pre></td></tr></table></figure></div></li></ol><h5 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h5><p>以下是一个简单示例，展示如何使用信号量实现两个进程之间的同步：</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">semaphore sync = <span class="number">0</span>; <span class="comment">// 初始化同步信号量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">process1</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// 执行前操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    V(sync); <span class="comment">// 完成前操作，释放信号量</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">process2</span><span class="params">()</span> {</span><br><span class="line">    P(sync); <span class="comment">// 请求信号量，等待process1完成前操作</span></span><br><span class="line">    <span class="comment">// 执行后操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h5 id="关键点-1"><a href="#关键点-1" class="headerlink" title="关键点"></a>关键点</h5><ul><li><strong>阻塞与唤醒</strong>：通过设置初始值为0，可以确保在执行后续操作之前，相关进程必须先完成其前置条件。</li><li><strong>避免竞争条件</strong>：使用信号量可以有效避免由于并发执行导致的数据不一致问题。</li></ul><p>通过以上步骤和机制，信号量能够有效地实现进程之间的同步，使得多个并发进程能够按照预定顺序有序地推进。</p><h4 id="信号量机制实现前驱关系"><a href="#信号量机制实现前驱关系" class="headerlink" title="信号量机制实现前驱关系"></a>信号量机制实现前驱关系</h4><p>信号量机制可以有效地处理进程之间的前驱关系，确保某些操作在其他操作之前完成。以下是信号量如何实现前驱关系的基本原理和步骤。</p><h5 id="前驱关系的定义"><a href="#前驱关系的定义" class="headerlink" title="前驱关系的定义"></a>前驱关系的定义</h5><p>前驱关系指的是在多个进程或操作中，某个操作的执行必须依赖于另一个操作的完成。例如，如果操作S1必须在操作S2之前完成，则可以表示为S1 -&gt; S2。</p><h5 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h5><ol><li><p><strong>设置信号量</strong>：<br>为每个需要同步的操作设置一个信号量，初始值为0。这表示该操作在执行之前必须等待其前驱操作完成。</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">semaphore a1 = <span class="number">0</span>; <span class="comment">// 用于S1 -&gt; S2</span></span><br><span class="line">semaphore a2 = <span class="number">0</span>; <span class="comment">// 用于S1 -&gt; S3</span></span><br></pre></td></tr></table></figure></div></li><li><p><strong>执行前驱操作并释放信号量</strong>：<br>在前驱操作（如S1）完成后，调用V操作释放相应的信号量，以通知其他进程可以继续执行。</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">S1</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// 执行S1的代码</span></span><br><span class="line">    V(a1); <span class="comment">// 通知S2可以执行</span></span><br><span class="line">    V(a2); <span class="comment">// 通知S3可以执行</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div></li><li><p><strong>在后续操作中请求信号量</strong>：<br>在每个后续操作（如S2和S3）开始之前，调用P操作请求相应的信号量。如果信号量值为0，进程将被阻塞，直到前驱操作完成并释放信号量。</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">S2</span><span class="params">()</span> {</span><br><span class="line">    P(a1); <span class="comment">// 等待S1完成</span></span><br><span class="line">    <span class="comment">// 执行S2的代码</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">S3</span><span class="params">()</span> {</span><br><span class="line">    P(a2); <span class="comment">// 等待S1完成</span></span><br><span class="line">    <span class="comment">// 执行S3的代码</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div></li><li><p><strong>继续后续操作</strong>：<br>后续操作（如S4、S5、S6等）也可以使用类似的方法进行同步，确保它们在适当的时候执行。</p></li></ol><h5 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h5><p>以下是一个完整示例，展示了如何使用信号量实现多个进程之间的前驱关系：</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">semaphore a1 = <span class="number">0</span>; <span class="comment">// S1 -&gt; S2</span></span><br><span class="line">semaphore a2 = <span class="number">0</span>; <span class="comment">// S1 -&gt; S3</span></span><br><span class="line">semaphore b1 = <span class="number">0</span>; <span class="comment">// S2 -&gt; S4</span></span><br><span class="line">semaphore b2 = <span class="number">0</span>; <span class="comment">// S2 -&gt; S5</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">S1</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// 执行S1的代码</span></span><br><span class="line">    V(a1); <span class="comment">// 通知S2可以执行</span></span><br><span class="line">    V(a2); <span class="comment">// 通知S3可以执行</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">S2</span><span class="params">()</span> {</span><br><span class="line">    P(a1); <span class="comment">// 等待S1完成</span></span><br><span class="line">    <span class="comment">// 执行S2的代码</span></span><br><span class="line">    V(b1); <span class="comment">// 通知S4可以执行</span></span><br><span class="line">    V(b2); <span class="comment">// 通知S5可以执行</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">S3</span><span class="params">()</span> {</span><br><span class="line">    P(a2); <span class="comment">// 等待S1完成</span></span><br><span class="line">    <span class="comment">// 执行S3的代码</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">S4</span><span class="params">()</span> {</span><br><span class="line">    P(b1); <span class="comment">// 等待S2完成</span></span><br><span class="line">    <span class="comment">// 执行S4的代码</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">S5</span><span class="params">()</span> {</span><br><span class="line">    P(b2); <span class="comment">// 等待S2完成</span></span><br><span class="line">    <span class="comment">// 执行S5的代码</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h3 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h3><p>生产者消费者问题是一个经典的进程同步问题，描述了两个进程（生产者和消费者）如何在共享缓冲区中安全地交互。以下是对该问题的详细介绍，包括其背景、问题描述、解决方案及实现方式。</p><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>在生产者消费者模型中，生产者负责生成数据并将其放入共享缓冲区，而消费者则从缓冲区中取出数据进行消费。关键在于要确保：</p><ul><li><strong>缓冲区不满</strong>：当缓冲区已满时，生产者必须等待，直到消费者消费了数据。</li><li><strong>缓冲区不空</strong>：当缓冲区为空时，消费者必须等待，直到生产者生成了数据。</li></ul><p>这种模型确保了生产者和消费者之间的协调，避免了数据丢失或错误读取的情况。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="使用信号量"><a href="#使用信号量" class="headerlink" title="使用信号量"></a>使用信号量</h5><p>信号量是一种用于进程间同步的机制，可以有效地解决生产者消费者问题。通常需要使用两个信号量：</p><ul><li><strong>freeSpace</strong>：表示缓冲区中可用的空位数量。</li><li><strong>usedSpace</strong>：表示缓冲区中已用的产品数量。</li></ul><h5 id="伪代码示例"><a href="#伪代码示例" class="headerlink" title="伪代码示例"></a>伪代码示例</h5><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">semaphore freeSpace = N; <span class="comment">// N为缓冲区大小</span></span><br><span class="line">semaphore usedSpace = <span class="number">0</span>; <span class="comment">// 初始时没有产品</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">producer</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        produceItem(); <span class="comment">// 生产一个产品</span></span><br><span class="line">        P(freeSpace); <span class="comment">// 请求一个空位</span></span><br><span class="line">        putItemIntoBuffer(); <span class="comment">// 将产品放入缓冲区</span></span><br><span class="line">        V(usedSpace); <span class="comment">// 增加已用产品计数</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">consumer</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        P(usedSpace); <span class="comment">// 请求一个已用产品</span></span><br><span class="line">        getItemFromBuffer(); <span class="comment">// 从缓冲区获取产品</span></span><br><span class="line">        V(freeSpace); <span class="comment">// 增加空位计数</span></span><br><span class="line">        consumeItem(); <span class="comment">// 消费该产品</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h5 id="使用互斥锁和条件变量"><a href="#使用互斥锁和条件变量" class="headerlink" title="使用互斥锁和条件变量"></a>使用互斥锁和条件变量</h5><p>在多生产者和多消费者的情况下，可以使用互斥锁和条件变量来实现更复杂的同步机制。互斥锁用于保护对共享资源的访问，而条件变量则用于在特定条件下阻塞和唤醒线程。</p><h5 id="伪代码示例-1"><a href="#伪代码示例-1" class="headerlink" title="伪代码示例"></a>伪代码示例</h5><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">mutex lock;</span><br><span class="line">condition_variable notFull, notEmpty;</span><br><span class="line"><span class="type">int</span> buffer[N]; <span class="comment">// 缓冲区</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 当前产品数量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">producer</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        produceItem();</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">while</span> (count == N) {</span><br><span class="line">            notFull.wait(lock); <span class="comment">// 等待直到有空位</span></span><br><span class="line">        }</span><br><span class="line">        buffer[count++] = item; <span class="comment">// 放入产品</span></span><br><span class="line">        notEmpty.notify_one(); <span class="comment">// 通知消费者有新产品</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">consumer</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) {</span><br><span class="line">            notEmpty.wait(lock); <span class="comment">// 等待直到有产品可消费</span></span><br><span class="line">        }</span><br><span class="line">        item = buffer[--count]; <span class="comment">// 获取产品</span></span><br><span class="line">        notFull.notify_one(); <span class="comment">// 通知生产者有空位</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">        consumeItem(item);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p>这是一个cpp实例</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProducerConsumer</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ProducerConsumer</span>(<span class="type">int</span> maxSize) : <span class="built_in">maxSize_</span>(maxSize), <span class="built_in">running_</span>(<span class="literal">true</span>) {}</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">startProducers</span><span class="params">(<span class="type">int</span> numProducers)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numProducers; ++i) {</span><br><span class="line">            producers_.<span class="built_in">emplace_back</span>(&amp;ProducerConsumer::producer, <span class="keyword">this</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">startConsumers</span><span class="params">(<span class="type">int</span> numConsumers)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numConsumers; ++i) {</span><br><span class="line">            consumers_.<span class="built_in">emplace_back</span>(&amp;ProducerConsumer::consumer, <span class="keyword">this</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span> </span>{</span><br><span class="line">        running_ = <span class="literal">false</span>;</span><br><span class="line">        cv_.<span class="built_in">notify_all</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;producer : producers_) {</span><br><span class="line">            producer.<span class="built_in">join</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;consumer : consumers_) {</span><br><span class="line">            consumer.<span class="built_in">join</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (running_) {</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">            cv_.<span class="built_in">wait</span>(lk, [&amp;] { <span class="keyword">return</span> buffer_.<span class="built_in">size</span>() &lt; maxSize_ || !running_; });</span><br><span class="line">            <span class="keyword">if</span> (!running_) <span class="keyword">break</span>;</span><br><span class="line">            buffer_.<span class="built_in">push</span>(res_[(index++) % res_.<span class="built_in">size</span>()]);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"Producer pushed: "</span> &lt;&lt; res_[(index - <span class="number">1</span>) % res_.<span class="built_in">size</span>()] &lt;&lt; std::endl;</span><br><span class="line">            cv_.<span class="built_in">notify_all</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (running_) {</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">            cv_.<span class="built_in">wait</span>(lk, [&amp;] { <span class="keyword">return</span> !buffer_.<span class="built_in">empty</span>() || !running_; });</span><br><span class="line">            <span class="keyword">if</span> (!running_ &amp;&amp; buffer_.<span class="built_in">empty</span>()) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (!buffer_.<span class="built_in">empty</span>()) {</span><br><span class="line">                <span class="keyword">auto</span> front = buffer_.<span class="built_in">front</span>();</span><br><span class="line">                buffer_.<span class="built_in">pop</span>();</span><br><span class="line">                std::cout &lt;&lt; <span class="string">"Consumer got: "</span> &lt;&lt; front &lt;&lt; std::endl;</span><br><span class="line">            }</span><br><span class="line">            cv_.<span class="built_in">notify_all</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> std::array&lt;std::string, 5&gt; res_{<span class="string">"awd"</span>, <span class="string">"1"</span>, <span class="string">"awdjkgdfh"</span>, <span class="string">"encounter"</span>, <span class="string">"dwadawd"</span>};</span><br><span class="line">    std::queue&lt;std::string&gt; buffer_;</span><br><span class="line">    std::condition_variable cv_;</span><br><span class="line">    std::mutex mtx_;</span><br><span class="line">    <span class="type">int</span> maxSize_;</span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; running_;</span><br><span class="line">    std::vector&lt;std::thread&gt; producers_;</span><br><span class="line">    std::vector&lt;std::thread&gt; consumers_;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">ProducerConsumer <span class="title">pc</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    pc.<span class="built_in">startProducers</span>(<span class="number">3</span>);</span><br><span class="line">    pc.<span class="built_in">startConsumers</span>(<span class="number">3</span>);</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">    pc.<span class="built_in">stop</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>生产者消费者问题展示了多线程编程中的同步与互斥的重要性。通过使用信号量、互斥锁和条件变量等机制，可以有效地管理进程之间的协作，确保数据的一致性与完整性。该模型不仅适用于单一生产者和消费者，也可以扩展到多个生产者和消费者的场景中，为并发编程提供了重要的理论基础和实践指导。</p><h3 id="读者写者问题"><a href="#读者写者问题" class="headerlink" title="读者写者问题"></a>读者写者问题</h3><p>读者写者问题是操作系统中的经典同步问题，涉及多个进程对共享资源的访问控制。其主要目标是确保在读者和写者之间实现有效的互斥，以避免数据不一致性。</p><h4 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h4><p>在读者写者问题中，有两类进程：</p><ul><li><strong>读者进程</strong>：只读取共享数据，不修改它。</li><li><strong>写者进程</strong>：可以读取和修改共享数据。</li></ul><h4 id="主要要求"><a href="#主要要求" class="headerlink" title="主要要求"></a>主要要求</h4><ol><li><strong>允许多个读者同时进行读操作</strong>：多个读者可以并行访问共享资源而不会发生冲突。</li><li><strong>只允许一个写者进行写操作</strong>：在任何写操作进行时，必须确保没有其他读者或写者同时访问该资源。</li><li><strong>互斥访问</strong>：在写者执行写操作之前，必须等待所有当前的读者和写者完成他们的操作。</li></ol><h4 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h4><h5 id="1-读者优先"><a href="#1-读者优先" class="headerlink" title="1. 读者优先"></a>1. 读者优先</h5><p>在这种策略下，系统优先允许读者访问共享资源。若有持续不断的读者请求，可能会导致写者饿死，即无法获得执行机会。这种策略简单易实现，但在高并发情况下可能导致写入延迟。</p><h5 id="2-写者优先"><a href="#2-写者优先" class="headerlink" title="2. 写者优先"></a>2. 写者优先</h5><p>此策略确保写者能够尽快执行其操作。在这种情况下，如果有待处理的写请求，则后续的读请求将被阻塞。这种策略可以减少写者的饥饿现象，但可能导致读者的延迟。</p><h4 id="解决方案示例"><a href="#解决方案示例" class="headerlink" title="解决方案示例"></a>解决方案示例</h4><p>一种常见的解决方案是使用信号量来控制对共享资源的访问。信号量提供了两种基本操作：</p><ul><li><strong>P（proberen）</strong>：请求资源，若资源不可用则阻塞。</li><li><strong>V（verhogen）</strong>：释放资源，唤醒等待的进程。</li></ul><p>以下是一个简化的伪代码示例：</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化信号量</span></span><br><span class="line">Semaphore readCountMutex = <span class="number">1</span>; <span class="comment">// 控制读计数器</span></span><br><span class="line">Semaphore resourceMutex = <span class="number">1</span>;   <span class="comment">// 控制对共享资源的访问</span></span><br><span class="line">Semaphore writeMUtex = <span class="number">1</span>;   <span class="comment">// 用于实现"写优先"</span></span><br><span class="line"><span class="type">int</span> readCount = <span class="number">0</span>;             <span class="comment">// 当前读取进程数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读者进程</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">reader</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) {</span><br><span class="line">        P(writeMutex);</span><br><span class="line">        P(readCountMutex);          <span class="comment">// 获取读计数器锁</span></span><br><span class="line">        <span class="keyword">if</span> (readCount == <span class="number">1</span>) {</span><br><span class="line">            P(resourceMutex);       <span class="comment">// 第一个读者获取资源锁</span></span><br><span class="line">        }</span><br><span class="line">        readCount++;</span><br><span class="line">        V(readCountMutex);          <span class="comment">// 释放读计数器锁</span></span><br><span class="line">        V(writeMutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行读取操作</span></span><br><span class="line"></span><br><span class="line">        P(readCountMutex);          <span class="comment">// 获取读计数器锁</span></span><br><span class="line">        readCount--;</span><br><span class="line">        <span class="keyword">if</span> (readCount == <span class="number">0</span>) {</span><br><span class="line">            V(resourceMutex);       <span class="comment">// 最后一个读者释放资源锁</span></span><br><span class="line">        }</span><br><span class="line">        V(readCountMutex);          <span class="comment">// 释放读计数器锁</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写者进程</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">writer</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)  {</span><br><span class="line">        P(writeMutex);</span><br><span class="line">        P(resourceMutex);           <span class="comment">// 获取资源锁</span></span><br><span class="line">        <span class="comment">// 执行写入操作</span></span><br><span class="line">        V(resourceMutex);           <span class="comment">// 释放资源锁</span></span><br><span class="line">        V(writeMutex);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p>如果对上面的伪代码没有概念的话，下面是一个cpp的实例</p><ul><li>读优先</li></ul><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WriterAndReader</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::mutex write_mutex;</span><br><span class="line">    std::mutex read_mutex;</span><br><span class="line">    std::condition_variable cv_read;</span><br><span class="line">    std::condition_variable cv_write;</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; read_count{<span class="number">0</span>}; <span class="comment">// 原子操作</span></span><br><span class="line">    std::string data;</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; index{<span class="number">0</span>};      <span class="comment">// 原子操作</span></span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; stop{<span class="literal">false</span>};</span><br><span class="line">    std::array&lt;std::string, 4&gt; res {<span class="string">"hello"</span>, <span class="string">"world"</span>, <span class="string">"hello"</span>, <span class="string">"cpp"</span>};</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (!stop) {</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">read_lock</span><span class="params">(read_mutex)</span></span>;</span><br><span class="line">            cv_read.<span class="built_in">wait</span>(read_lock, [<span class="keyword">this</span>]() { <span class="keyword">return</span> !data.<span class="built_in">empty</span>() || stop; });</span><br><span class="line">            <span class="keyword">if</span> (stop) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            read_count++;</span><br><span class="line">            read_lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">            std::cout &lt;&lt; <span class="string">"data is: "</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">            read_lock.<span class="built_in">lock</span>();</span><br><span class="line">            read_count--;</span><br><span class="line">            <span class="keyword">if</span> (read_count == <span class="number">0</span>) {</span><br><span class="line">                cv_write.<span class="built_in">notify_one</span>();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (!stop) {</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">write_lock</span><span class="params">(write_mutex)</span></span>;</span><br><span class="line">            cv_write.<span class="built_in">wait</span>(write_lock, [<span class="keyword">this</span>]() { <span class="keyword">return</span> read_count == <span class="number">0</span> || stop; });</span><br><span class="line">            <span class="keyword">if</span> (stop) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 原子操作确保 index 安全</span></span><br><span class="line">            <span class="type">int</span> current_index = index++;</span><br><span class="line">            data = res[current_index % <span class="number">4</span>];</span><br><span class="line">            cv_read.<span class="built_in">notify_all</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop_threads</span><span class="params">()</span> </span>{</span><br><span class="line">        stop = <span class="literal">true</span>;</span><br><span class="line">        cv_read.<span class="built_in">notify_all</span>();  <span class="comment">// 唤醒读者</span></span><br><span class="line">        cv_write.<span class="built_in">notify_all</span>(); <span class="comment">// 唤醒写者</span></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><ul><li>写优先</li></ul><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">readerwriter</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">readerwriter</span>() : <span class="built_in">readcount</span>(<span class="number">0</span>), <span class="built_in">iswriting</span>(<span class="literal">false</span>) {}</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reader</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            {</span><br><span class="line">                <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">                readcountcond_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() { <span class="keyword">return</span> !iswriting; }); <span class="comment">// 等待写者完成</span></span><br><span class="line">                readcount++;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行读取操作</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">"reader is reading... (readcount: "</span> &lt;&lt; readcount &lt;&lt; <span class="string">")"</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">            {</span><br><span class="line">                <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">                readcount--;</span><br><span class="line">                <span class="keyword">if</span> (readcount == <span class="number">0</span>) {</span><br><span class="line">                    writecond_.<span class="built_in">notify_one</span>(); <span class="comment">// 通知写者可以写入</span></span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 模拟读取操作时间</span></span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">writer</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            {</span><br><span class="line">                <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">                iswriting = <span class="literal">true</span>;</span><br><span class="line">                writecond_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() { <span class="keyword">return</span> readcount == <span class="number">0</span>; }); <span class="comment">// 等待所有读者完成</span></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行写入操作</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">"writer is writing..."</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">            {</span><br><span class="line">                <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">                iswriting = <span class="literal">false</span>;</span><br><span class="line">                readcountcond_.<span class="built_in">notify_all</span>(); <span class="comment">// 通知所有读者可以读取</span></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 模拟写入操作时间</span></span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1000</span>));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::mutex mtx_;</span><br><span class="line">    std::condition_variable readcountcond_;</span><br><span class="line">    std::condition_variable writecond_;</span><br><span class="line">    <span class="type">int</span> readcount;</span><br><span class="line">    <span class="type">bool</span> iswriting;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    readerwriter rw;</span><br><span class="line">    std::vector&lt;std::thread&gt; readers;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) {</span><br><span class="line">        readers.<span class="built_in">emplace_back</span>(&amp;readerwriter::reader, &amp;rw);</span><br><span class="line">    }</span><br><span class="line">    <span class="function">std::thread <span class="title">writerthread</span><span class="params">(&amp;readerwriter::writer, &amp;rw)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;reader : readers) {</span><br><span class="line">        reader.<span class="built_in">join</span>();</span><br><span class="line">    }</span><br><span class="line">    writerthread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="哲学家问题"><a href="#哲学家问题" class="headerlink" title="哲学家问题"></a>哲学家问题</h3><h4 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h4><p>在这个模型中：</p><ul><li><strong>哲学家</strong>：每位哲学家可以进行两种活动：思考和吃饭。</li><li><strong>餐具</strong>：每位哲学家面前有两根筷子（或餐叉），分别位于其左侧和右侧。要吃饭，哲学家必须同时拿起左边和右边的筷子。</li></ul><h4 id="主要挑战"><a href="#主要挑战" class="headerlink" title="主要挑战"></a>主要挑战</h4><ul><li><strong>死锁</strong>：如果每位哲学家同时拿起左边的筷子，然后等待右边的筷子，就会导致所有哲学家都在等待，形成死锁。</li><li><strong>资源竞争</strong>：哲学家之间对筷子的竞争可能导致资源耗尽。</li></ul><h4 id="死锁分析"><a href="#死锁分析" class="headerlink" title="死锁分析"></a>死锁分析</h4><p>死锁的产生通常满足以下四个条件：</p><ol><li><strong>互斥</strong>：至少有一个资源必须处于非共享模式，即一次只能由一个进程使用。</li><li><strong>保持并等待</strong>：一个进程至少持有一个资源，并等待获取其他资源。</li><li><strong>不剥夺</strong>：已经分配给进程的资源在该进程释放之前，不能被其他进程强制剥夺。</li><li><strong>循环等待</strong>：存在一种进程的循环等待关系。</li></ol><p>在哲学家就餐问题中，如果每位哲学家都先拿起左侧的筷子，就会出现循环等待，从而导致死锁。</p><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="1-增加限制"><a href="#1-增加限制" class="headerlink" title="1. 增加限制"></a>1. 增加限制</h5><p>比如最多允许四个哲学家同时进餐。这样可以保证至少一个哲学家是可以拿到左右两只筷子。</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = {<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>};</span><br><span class="line">semaphore mutex = <span class="number">1</span>; <span class="comment">// 互斥取筷子</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Run</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) {</span><br><span class="line">        P(mutex);</span><br><span class="line">        P(chopstick[i]); <span class="comment">// take left</span></span><br><span class="line">        P(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]); <span class="comment">// take right</span></span><br><span class="line">        V(mutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Eatting ....</span></span><br><span class="line"></span><br><span class="line">        V(chopstick[i]); <span class="comment">// drop left</span></span><br><span class="line">        V(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]); <span class="comment">// drop right</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Thinking ...</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h5 id="2-改变获取顺序"><a href="#2-改变获取顺序" class="headerlink" title="2. 改变获取顺序"></a>2. 改变获取顺序</h5><p>要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。</p><h5 id="3-资源分级"><a href="#3-资源分级" class="headerlink" title="3. 资源分级"></a>3. 资源分级</h5><p>仅当一个哲学家左右两只筷子都可用时才允许他抓起筷子。</p><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>管程（Monitor）是操作系统和并发编程中的一种同步机制，用于管理对共享资源的访问。它通过封装共享变量和操作这些变量的过程，提供了一种高效且易于使用的方式来解决并发问题。</p><h4 id="管程的定义"><a href="#管程的定义" class="headerlink" title="管程的定义"></a>管程的定义</h4><p>管程是一种高级同步原语，它将共享数据结构（如变量）和对这些数据结构的操作封装在一个模块中。管程确保在任一时刻只有一个进程可以访问这些共享资源，从而实现互斥访问。</p><h4 id="主要特征"><a href="#主要特征" class="headerlink" title="主要特征"></a>主要特征</h4><ol><li>局部管程的数据只能被局部于管程的过程所访问</li><li>一个进程只有通过调用管程内的过程才能进入管程访问</li><li>每次仅允许一个进程在管程内执行某个内部过程</li></ol><h4 id="管程的组成"><a href="#管程的组成" class="headerlink" title="管程的组成"></a>管程的组成</h4><ul><li><strong>共享变量</strong>：管程内定义的共享数据。</li><li><strong>过程</strong>：对共享数据进行操作的一组函数或方法。</li><li><strong>条件变量</strong>：用于实现进程间同步的机制，允许进程在某些条件下被阻塞或唤醒。</li><li><strong>初始化语句</strong>：用于设置共享变量初始值的代码。</li></ul><h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><p>条件变量是管程中重要的组成部分，用于实现更复杂的同步机制。它们提供了两个基本操作：</p><ul><li>**wait(c)**：调用该操作的进程被阻塞，并释放管程，直到其他进程执行signal(c)唤醒它。</li><li>**signal(c)**：唤醒在条件变量c上等待的一个进程。如果没有进程在等待，则该信号被丢弃。</li></ul><h4 id="管程与信号量的比较"><a href="#管程与信号量的比较" class="headerlink" title="管程与信号量的比较"></a>管程与信号量的比较</h4><p>虽然管程和信号量都能解决并发问题，但它们之间有显著区别：</p><ul><li><strong>封装性</strong>：管程将所有相关的同步操作集中在一起，而信号量则可能导致同步代码分散在多个地方。</li><li><strong>易用性</strong>：由于互斥和同步机制由编译器处理，使用管程通常比使用信号量更简单、更安全。</li><li><strong>错误率</strong>：由于管程内部管理复杂性，程序员不需要手动处理互斥，降低了出错的概率。</li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h4><p>死锁可以被定义为：一组进程中的每个进程都在等待一个事件，而这个事件只能由该组中的其他进程触发。当这种情况发生时，所有相关进程都将无限期地等待下去，无法继续执行。简单来说，就是每个进程都在等待其他进程释放它所需的资源，而这些资源又被其他进程占用，从而形成了一个循环等待的状态<br>死锁、死循环和饥饿是并发编程中常见的三种现象，它们虽然都与进程的执行状态有关，但各自的定义、原因和影响有所不同。</p><h4 id="进程死锁、饥饿、死循环的区别"><a href="#进程死锁、饥饿、死循环的区别" class="headerlink" title="进程死锁、饥饿、死循环的区别"></a>进程死锁、饥饿、死循环的区别</h4><h5 id="1-死锁"><a href="#1-死锁" class="headerlink" title="1. 死锁"></a>1. 死锁</h5><p><strong>定义</strong>：死锁是指两个或多个进程因相互等待对方持有的资源而导致的僵局状态。在这种情况下，所有相关进程都无法继续执行。</p><p><strong>特点</strong>：</p><ul><li><strong>循环等待</strong>：每个进程都在等待其他进程释放它所需的资源。</li><li><strong>阻塞状态</strong>：所有参与死锁的进程都处于阻塞状态，无法向前推进。</li></ul><p><strong>示例</strong>：进程A持有资源1并请求资源2，而进程B持有资源2并请求资源1，导致两者相互等待。</p><h5 id="2-死循环"><a href="#2-死循环" class="headerlink" title="2. 死循环"></a>2. 死循环</h5><p><strong>定义</strong>：死循环是指某个进程在执行过程中陷入一个无限循环，无法正常结束或跳出该循环。通常是因为程序逻辑错误或故意设计的逻辑。</p><p><strong>特点</strong>：</p><ul><li><strong>逻辑错误</strong>：可能由于代码中的错误导致条件永远不满足。</li><li><strong>不一定阻塞</strong>：死循环的进程可能仍在运行，但无法完成其预定任务。</li></ul><p><strong>示例</strong>：一个程序在检查某个条件时，条件始终为假，导致其不断重复执行同一段代码。</p><h5 id="3-饥饿"><a href="#3-饥饿" class="headerlink" title="3. 饥饿"></a>3. 饥饿</h5><p><strong>定义</strong>：饥饿是指某个进程由于长期得不到所需资源而无法向前推进。饥饿通常是由于调度策略不当或资源分配不均造成的。</p><p><strong>特点</strong>：</p><ul><li><strong>单一影响</strong>：可能只有一个进程经历饥饿，而其他进程正常运行。</li><li><strong>可处于不同状态</strong>：饥饿的进程可以处于阻塞状态（如等待I/O设备）或就绪状态（长期得不到CPU时间）。</li></ul><p><strong>示例</strong>：在短作业优先（SJF）调度算法中，如果有大量短作业不断到达，长作业可能会一直得不到处理，从而导致饥饿。</p><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><table><thead><tr><th>特征</th><th>死锁</th><th>死循环</th><th>饥饿</th></tr></thead><tbody><tr><td>定义</td><td>互相等待对方资源，无法执行</td><td>陷入无限循环，无法结束</td><td>长期得不到所需资源</td></tr><tr><td>状态</td><td>所有相关进程均阻塞</td><td>进程仍在运行但无效</td><td>可能处于阻塞或就绪状态</td></tr><tr><td>影响范围</td><td>多个进程</td><td>单个进程</td><td>单一或多个进程</td></tr><tr><td>解决方法</td><td>检测与恢复、预防措施</td><td>修正代码逻辑</td><td>改善调度策略</td></tr></tbody></table><h4 id="死锁产生必要的条件"><a href="#死锁产生必要的条件" class="headerlink" title="死锁产生必要的条件"></a>死锁产生必要的条件</h4><ol><li>互斥条件：资源不能被多个进程同时使用，即某个资源只能被一个进程占有。</li><li>占有且等待：一个进程持有至少一个资源，并正在请求其他资源。</li><li>不可剥夺条件：已经分配给某个进程的资源在该进程完成之前不能被强制剥夺。</li><li>循环等待条件：存在一个进程集合，其中每个进程都在等待下一个进程所持有的资源，从而形成一个环路</li></ol><h4 id="什么时候会发生死锁"><a href="#什么时候会发生死锁" class="headerlink" title="什么时候会发生死锁"></a>什么时候会发生死锁</h4><ol><li><p><strong>资源竞争</strong>：当多个进程需要共享有限的资源（如打印机、数据库连接等），并且这些资源只能被一个进程占用时，竞争可能导致死锁。例如，如果两个进程各自持有一个资源并请求对方的资源，就会形成死锁。</p></li><li><p><strong>请求与保持条件</strong>：如果一个进程已经持有某些资源，并且在请求其他资源时被阻塞，这种情况下就可能导致死锁。例如，进程A持有资源R1并请求资源R2，而进程B持有资源R2并请求资源R1，这样双方都在等待对方释放所需的资源，从而导致死锁。</p></li><li><p><strong>不可剥夺条件</strong>：当一个进程持有某个资源时，其他进程无法强制剥夺该资源，必须等到持有者主动释放。这种条件使得即使系统中存在可用资源，依然可能因为某些进程未释放其占有的资源而导致死锁。</p></li><li><p><strong>循环等待条件</strong>：如果存在一组进程，其中每个进程都在等待下一个进程所持有的资源，就形成了一个循环等待的状态。这是死锁发生的关键条件之一。例如，若P1等待P2持有的资源，而P2又在等待P1持有的资源，就会形成循环等待。</p></li><li><p><strong>不当的进程推进顺序</strong>：如果进程请求和释放资源的顺序不当，也可能导致死锁。例如，两个线程分别申请两个互斥锁，但获取顺序不一致，可能导致两个线程互相等待对方释放锁，从而产生死锁。</p></li></ol><h4 id="死锁的处理策略"><a href="#死锁的处理策略" class="headerlink" title="死锁的处理策略"></a>死锁的处理策略</h4><h5 id="1-预防死锁"><a href="#1-预防死锁" class="headerlink" title="1. 预防死锁"></a>1. 预防死锁</h5><p>预防死锁是通过破坏死锁产生的四个必要条件中的一个或多个来避免死锁的发生。具体方法包括：</p><ul><li><p><strong>破坏互斥条件</strong>：在某些情况下，可以尝试让资源不被独占，例如使用共享资源的方式，但这在实际应用中通常不可行。</p></li><li><p><strong>破坏请求与保持条件</strong>：不允许进程在持有某些资源的情况下请求其他资源。可以要求进程在请求新资源时释放已持有的资源。</p></li><li><p><strong>破坏不可剥夺条件</strong>：允许操作系统强制剥夺某些资源，以便将其分配给其他进程。</p></li><li><p><strong>破坏循环等待条件</strong>：为系统中的所有资源分配一个全局顺序，进程必须按照这个顺序请求资源，从而避免形成循环等待。</p></li></ul><h5 id="2-避免死锁"><a href="#2-避免死锁" class="headerlink" title="2. 避免死锁"></a>2. 避免死锁</h5><p>避免死锁是在资源动态分配过程中，通过算法确保系统不会进入不安全状态。常用的方法包括：</p><ul><li><p><strong>安全性算法</strong>：例如银行家算法，在分配资源前检查是否会导致系统进入不安全状态。如果会，则拒绝该请求。</p></li><li><p><strong>动态监控</strong>：实时监测系统状态，确保在任何时刻都不会形成循环等待。</p></li></ul><h5 id="3-检测与恢复"><a href="#3-检测与恢复" class="headerlink" title="3. 检测与恢复"></a>3. 检测与恢复</h5><p>检测与恢复策略允许死锁发生，但会定期检查系统中是否存在死锁。一旦检测到死锁，采取相应措施来解除死锁。常见的恢复方法包括：</p><ul><li><p><strong>进程撤销</strong>：选择一个或多个进程进行撤销，释放其占有的资源，从而打破死锁状态。</p></li><li><p><strong>回滚</strong>：将某些进程回滚到之前的状态，以释放资源并重新尝试执行。</p></li><li><p><strong>抢占</strong>：强制从某个持有者那里夺取资源并分配给其他需要该资源的进程。</p></li></ul><h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h5><table><thead><tr><th>处理策略</th><th>方法描述</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>预防</td><td>破坏四个必要条件中的至少一个</td><td>确保不会发生死锁</td><td>可能导致资源利用率低，效率下降</td></tr><tr><td>避免</td><td>动态监控和安全性算法，确保不进入不安全状态</td><td>灵活性高，能适应变化</td><td>实现复杂，需要预测未来资源需求</td></tr><tr><td>检测与恢复</td><td>定期检测死锁并采取措施解除</td><td>不影响正常运行，可以有效处理已发生的死锁</td><td>可能导致部分进程被撤销或回滚，造成损失</td></tr><tr><td>忽略</td><td>不采取任何措施，选择忽略死锁</td><td>实现简单，适合高性能需求</td><td>无法解决实际发生的死锁问题</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进程&lt;/h1&gt;&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;进程是</summary>
      
    
    
    
    <category term="考研" scheme="http://example.com/categories/%E8%80%83%E7%A0%94/"/>
    
    
    <category term="408" scheme="http://example.com/tags/408/"/>
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>docker常用命令</title>
    <link href="http://example.com/2024/10/04/dockerUsage/"/>
    <id>http://example.com/2024/10/04/dockerUsage/</id>
    <published>2024-10-04T01:54:36.000Z</published>
    <updated>2024-11-08T02:21:34.891Z</updated>
    
    <content type="html"><![CDATA[<p>Docker 是一个开源的容器化平台，允许开发者将应用程序及其依赖项打包到一个轻量级、可移植的容器中。以下是一些常用的 Docker 命令：</p><h3 id="1-镜像相关命令"><a href="#1-镜像相关命令" class="headerlink" title="1. 镜像相关命令"></a>1. 镜像相关命令</h3><ul><li><p><strong><code>docker pull &lt;image&gt;</code></strong>: 从 Docker Hub 或其他镜像仓库拉取镜像。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull ubuntu</span><br></pre></td></tr></table></figure></div></li><li><p><strong><code>docker images</code></strong>: 列出本地所有的镜像。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure></div></li><li><p><strong><code>docker rmi &lt;image&gt;</code></strong>: 删除指定的镜像。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi ubuntu</span><br></pre></td></tr></table></figure></div></li><li><p><strong><code>docker build -t &lt;tag&gt; .</code></strong>: 使用 Dockerfile 构建镜像，并指定标签。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t myapp:1.0 .</span><br></pre></td></tr></table></figure></div></li></ul><h3 id="2-容器相关命令"><a href="#2-容器相关命令" class="headerlink" title="2. 容器相关命令"></a>2. 容器相关命令</h3><ul><li><p><strong><code>docker run &lt;image&gt;</code></strong>: 运行一个容器。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it ubuntu</span><br></pre></td></tr></table></figure></div></li><li><p><strong><code>docker ps</code></strong>: 列出正在运行的容器。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure></div></li><li><p><strong><code>docker ps -a</code></strong>: 列出所有容器，包括已停止的。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure></div></li><li><p><strong><code>docker start &lt;container&gt;</code></strong>: 启动一个已停止的容器。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start mycontainer</span><br></pre></td></tr></table></figure></div></li><li><p><strong><code>docker stop &lt;container&gt;</code></strong>: 停止一个正在运行的容器。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop mycontainer</span><br></pre></td></tr></table></figure></div></li><li><p><strong><code>docker rm &lt;container&gt;</code></strong>: 删除一个容器。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> mycontainer</span><br></pre></td></tr></table></figure></div></li><li><p><strong><code>docker exec -it &lt;container&gt; &lt;command&gt;</code></strong>: 在运行的容器中执行命令。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mycontainer bash</span><br></pre></td></tr></table></figure></div></li></ul><h3 id="3-网络相关命令"><a href="#3-网络相关命令" class="headerlink" title="3. 网络相关命令"></a>3. 网络相关命令</h3><ul><li><p><strong><code>docker network ls</code></strong>: 列出所有网络。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network <span class="built_in">ls</span></span><br></pre></td></tr></table></figure></div></li><li><p><strong><code>docker network create &lt;network&gt;</code></strong>: 创建一个新的网络。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create mynetwork</span><br></pre></td></tr></table></figure></div></li><li><p><strong><code>docker network connect &lt;network&gt; &lt;container&gt;</code></strong>: 将容器连接到网络。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network connect mynetwork mycontainer</span><br></pre></td></tr></table></figure></div></li></ul><h3 id="4-卷相关命令"><a href="#4-卷相关命令" class="headerlink" title="4. 卷相关命令"></a>4. 卷相关命令</h3><ul><li><p><strong><code>docker volume ls</code></strong>: 列出所有卷。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume <span class="built_in">ls</span></span><br></pre></td></tr></table></figure></div></li><li><p><strong><code>docker volume create &lt;volume&gt;</code></strong>: 创建一个新的卷。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create myvolume</span><br></pre></td></tr></table></figure></div></li><li><p><strong><code>docker volume rm &lt;volume&gt;</code></strong>: 删除一个卷。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume <span class="built_in">rm</span> myvolume</span><br></pre></td></tr></table></figure></div></li></ul><h3 id="5-其他常用命令"><a href="#5-其他常用命令" class="headerlink" title="5. 其他常用命令"></a>5. 其他常用命令</h3><ul><li><p><strong><code>docker logs &lt;container&gt;</code></strong>: 查看容器的日志。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs mycontainer</span><br></pre></td></tr></table></figure></div></li><li><p><strong><code>docker inspect &lt;container&gt;</code></strong>: 查看容器的详细信息。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect mycontainer</span><br></pre></td></tr></table></figure></div></li><li><p><strong><code>docker system prune</code></strong>: 清理未使用的数据（包括停止的容器、未使用的网络、未使用的镜像等）。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker system prune</span><br></pre></td></tr></table></figure></div></li></ul><h3 id="6-Docker-Compose-命令"><a href="#6-Docker-Compose-命令" class="headerlink" title="6. Docker Compose 命令"></a>6. Docker Compose 命令</h3><ul><li><p><strong><code>docker-compose up</code></strong>: 启动 Docker Compose 定义的服务。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure></div></li><li><p><strong><code>docker-compose down</code></strong>: 停止并删除 Docker Compose 定义的服务。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose down</span><br></pre></td></tr></table></figure></div></li><li><p><strong><code>docker-compose ps</code></strong>: 列出 Docker Compose 定义的服务。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose ps</span><br></pre></td></tr></table></figure></div></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Docker 是一个开源的容器化平台，允许开发者将应用程序及其依赖项打包到一个轻量级、可移植的容器中。以下是一些常用的 Docker 命令：&lt;/p&gt;
&lt;h3 id=&quot;1-镜像相关命令&quot;&gt;&lt;a href=&quot;#1-镜像相关命令&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="docker" scheme="http://example.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>SQL事务</title>
    <link href="http://example.com/2024/09/22/SQLEvent/"/>
    <id>http://example.com/2024/09/22/SQLEvent/</id>
    <published>2024-09-22T09:28:24.000Z</published>
    <updated>2024-11-08T02:21:34.889Z</updated>
    
    <content type="html"><![CDATA[<p>在SQL中，事务（Transaction）是一组数据库操作的逻辑单元，这些操作要么全部成功执行，要么全部不执行。事务的主要目的是确保数据库的一致性和完整性，尤其是在并发访问和系统故障的情况下。</p><h3 id="事务的基本概念"><a href="#事务的基本概念" class="headerlink" title="事务的基本概念"></a>事务的基本概念</h3><ol><li><p><strong>事务的特性（ACID）</strong>:</p><ul><li><strong>原子性（Atomicity）</strong>: 事务中的所有操作要么全部成功执行，要么全部不执行。如果事务中的任何一个操作失败，整个事务都会回滚到初始状态。</li><li><strong>一致性（Consistency）</strong>: 事务执行前后，数据库必须保持一致性状态。事务不能违反数据库的完整性约束。</li><li><strong>隔离性（Isolation）</strong>: 并发执行的多个事务之间是相互隔离的，一个事务的执行不能被其他事务干扰。</li><li><strong>持久性（Durability）</strong>: 一旦事务成功提交，其结果将永久保存在数据库中，即使系统发生故障也不会丢失。</li></ul></li><li><p><strong>事务的控制语句</strong>:</p><ul><li><strong>BEGIN TRANSACTION</strong>: 开始一个事务。</li><li><strong>COMMIT</strong>: 提交事务，将所有操作永久保存到数据库中。</li><li><strong>ROLLBACK</strong>: 回滚事务，撤销所有未提交的操作。</li><li><strong>SAVEPOINT</strong>: 在事务中设置保存点，可以在回滚时只回滚到保存点。</li></ul></li></ol><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>; #开始事务</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="keyword">ROLLBACK</span>; #回滚事务</span><br><span class="line"><span class="keyword">SAVEPOINT</span> 回滚点; #添加回滚点</span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> 回滚点; # 回到指定回滚点</span><br><span class="line">...</span><br><span class="line"><span class="keyword">COMMIT</span>; #提交事务</span><br><span class="line"><span class="comment">-- 一旦提交，就无法进行回滚</span></span><br></pre></td></tr></table></figure></div><h3 id="事务的实例"><a href="#事务的实例" class="headerlink" title="事务的实例"></a>事务的实例</h3><p>假设我们有一个银行账户表 <code>accounts</code>，我们希望实现一个转账操作，从一个账户转钱到另一个账户。为了确保转账操作的原子性和一致性，我们需要使用事务。</p><h4 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a>表结构</h4><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> accounts (</span><br><span class="line">    account_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    balance <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><h4 id="插入初始数据"><a href="#插入初始数据" class="headerlink" title="插入初始数据"></a>插入初始数据</h4><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> accounts (account_id, balance) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1000.00</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> accounts (account_id, balance) <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="number">500.00</span>);</span><br></pre></td></tr></table></figure></div><h4 id="转账操作"><a href="#转账操作" class="headerlink" title="转账操作"></a>转账操作</h4><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 从账户1转出500元</span></span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">500.00</span> <span class="keyword">WHERE</span> account_id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 向账户2转入500元</span></span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">500.00</span> <span class="keyword">WHERE</span> account_id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 检查账户1的余额是否足够</span></span><br><span class="line">IF (<span class="keyword">SELECT</span> balance <span class="keyword">FROM</span> accounts <span class="keyword">WHERE</span> account_id <span class="operator">=</span> <span class="number">1</span>) <span class="operator">&lt;</span> <span class="number">0</span> <span class="keyword">THEN</span></span><br><span class="line">    <span class="keyword">ROLLBACK</span>;  <span class="comment">-- 如果余额不足，回滚事务</span></span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line">    <span class="keyword">COMMIT</span>;    <span class="comment">-- 否则，提交事务</span></span><br><span class="line"><span class="keyword">END</span> IF;</span><br></pre></td></tr></table></figure></div><p>在这个例子中，我们使用事务来确保转账操作的原子性。如果账户1的余额不足，事务将回滚，撤销所有的操作；否则，事务将提交，转账操作成功完成。</p><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><p>SQL标准定义了四种事务隔离级别，用于控制并发事务之间的相互影响：</p><ol><li><strong>读未提交（Read Uncommitted）</strong>: 允许一个事务读取另一个事务未提交的数据。可能会导致脏读、不可重复读和幻读。</li><li><strong>读已提交（Read Committed）</strong>: 允许一个事务读取另一个事务已提交的数据。可以避免脏读，但可能会导致不可重复读和幻读。</li><li><strong>可重复读（Repeatable Read）</strong>: 确保一个事务在执行期间多次读取同一数据时，结果是一致的。可以避免脏读和不可重复读，但可能会导致幻读。</li><li><strong>串行化（Serializable）</strong>: 最高的隔离级别，确保事务串行执行，完全避免脏读、不可重复读和幻读。</li></ol><h4 id="设置隔离级别"><a href="#设置隔离级别" class="headerlink" title="设置隔离级别"></a>设置隔离级别</h4><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br></pre></td></tr></table></figure></div><h3 id="事务的使用场景"><a href="#事务的使用场景" class="headerlink" title="事务的使用场景"></a>事务的使用场景</h3><ol><li><p><strong>银行转账</strong>:</p><ul><li>确保从一个账户转钱到另一个账户的操作是原子的，要么全部成功，要么全部失败。</li></ul></li><li><p><strong>订单处理</strong>:</p><ul><li>确保订单的创建、库存的更新和支付的处理是原子的，避免出现订单创建成功但库存未更新的情况。</li></ul></li><li><p><strong>数据一致性</strong>:</p><ul><li>确保多个相关操作的一致性，例如在插入新记录时，同时更新相关统计信息。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在SQL中，事务（Transaction）是一组数据库操作的逻辑单元，这些操作要么全部成功执行，要么全部不执行。事务的主要目的是确保数据库的一致性和完整性，尤其是在并发访问和系统故障的情况下。&lt;/p&gt;
&lt;h3 id=&quot;事务的基本概念&quot;&gt;&lt;a href=&quot;#事务的基本概念&quot; </summary>
      
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>SQL触发器</title>
    <link href="http://example.com/2024/09/22/SQLTrigger/"/>
    <id>http://example.com/2024/09/22/SQLTrigger/</id>
    <published>2024-09-22T09:01:34.000Z</published>
    <updated>2024-11-08T02:21:34.890Z</updated>
    
    <content type="html"><![CDATA[<p>在SQL中，触发器（Trigger）是一种特殊的存储过程，它在特定的数据库操作（如插入、更新或删除）发生时自动执行。触发器通常用于维护数据完整性、执行审计跟踪、记录日志等任务。触发器可以在表级别定义，并且可以与 <code>INSERT</code>、<code>UPDATE</code> 和 <code>DELETE</code> 操作相关联。</p><p>触发器所依附的表为基本表，当触发器表上发生<code>select/update/delete</code>操作时，会自动生成两个临时的表(<code>new/old</code>，只能由触发器使用)</p><p>比如:</p><ul><li>在<code>insert</code>操作时，会生成<code>new</code>表，记录插入的数据，<code>old</code>表则为空。</li><li>在<code>delete</code>操作时，会生成<code>new</code>表，记录删除的数据，<code>old</code>表记录被删除的数据。</li><li>在<code>update</code>操作时，会生成<code>new</code>表，记录更新的数据，<code>old</code>表记录更新前的数据。</li></ul><p>创建触发器</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> <span class="operator">&lt;</span>trigger_name<span class="operator">&gt;</span> [BEFORE<span class="operator">|</span>AFTER] [<span class="keyword">INSERT</span><span class="operator">|</span><span class="keyword">UPDATE</span><span class="operator">|</span><span class="keyword">DELETE</span>] <span class="keyword">ON</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span><span class="operator">/</span><span class="operator">&lt;</span>view_name<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> [<span class="keyword">INSERT</span><span class="operator">|</span><span class="keyword">UPDATE</span><span class="operator">|</span><span class="keyword">DELETE</span> ] <span class="keyword">FROM</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span> <span class="keyword">WHERE</span> <span class="operator">&lt;</span><span class="keyword">condition</span><span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure></div><p><code>FOR EACH ROW</code> 表示针对每一行都会生效，无论哪行进行指定操作都会执行触发器</p><p>查看触发器</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TRIGGERS;</span><br></pre></td></tr></table></figure></div><p>删除触发器</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> <span class="operator">&lt;</span>trigger_name<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure></div><h3 id="触发器的基本概念"><a href="#触发器的基本概念" class="headerlink" title="触发器的基本概念"></a>触发器的基本概念</h3><ol><li><p><strong>触发器的类型</strong>:</p><ul><li><strong>BEFORE 触发器</strong>: 在触发操作（如插入、更新或删除）之前执行。</li><li><strong>AFTER 触发器</strong>: 在触发操作之后执行。</li><li><strong>INSTEAD OF 触发器</strong>: 用于视图，替代触发操作执行。</li></ul></li><li><p><strong>触发器的创建</strong>:</p><ul><li>使用 <code>CREATE TRIGGER</code> 语句创建触发器。</li><li>触发器可以与 <code>INSERT</code>、<code>UPDATE</code> 和 <code>DELETE</code> 操作相关联。</li></ul></li><li><p><strong>触发器的优点</strong>:</p><ul><li><strong>自动执行</strong>: 触发器在特定事件发生时自动执行，无需手动调用。</li><li><strong>维护数据完整性</strong>: 触发器可以用于强制执行复杂的业务规则和约束。</li><li><strong>审计跟踪</strong>: 触发器可以用于记录对数据的修改，便于审计和追踪。</li></ul></li><li><p><strong>触发器的缺点</strong>:</p><ul><li><strong>性能开销</strong>: 触发器的执行会增加数据库操作的开销，尤其是在频繁操作的情况下。</li><li><strong>复杂性</strong>: 触发器的逻辑可能变得复杂，难以维护和调试。</li></ul></li></ol><h3 id="触发器的实例"><a href="#触发器的实例" class="headerlink" title="触发器的实例"></a>触发器的实例</h3><h4 id="实例1：插入操作触发器"><a href="#实例1：插入操作触发器" class="headerlink" title="实例1：插入操作触发器"></a>实例1：插入操作触发器</h4><p>假设我们有一个 <code>employees</code> 表，我们希望在每次插入新员工时，自动记录插入操作的时间。</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    hire_date DATETIME</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> audit_log (</span><br><span class="line">    log_id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    action <span class="type">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">    log_date DATETIME</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trg_employees_insert</span><br><span class="line">AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> employees</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> audit_log (action, log_date)</span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">&#x27;INSERT&#x27;</span>, NOW());</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure></div><p>在这个例子中，<code>trg_employees_insert</code> 触发器在每次向 <code>employees</code> 表插入新记录时自动执行，并将插入操作记录到 <code>audit_log</code> 表中。</p><h4 id="实例2：更新操作触发器"><a href="#实例2：更新操作触发器" class="headerlink" title="实例2：更新操作触发器"></a>实例2：更新操作触发器</h4><p>假设我们希望在每次更新 <code>employees</code> 表中的 <code>hire_date</code> 字段时，自动记录更新前后的值。</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trg_employees_update</span><br><span class="line">BEFORE <span class="keyword">UPDATE</span> <span class="keyword">ON</span> employees</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> audit_log (action, log_date)</span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">&#x27;UPDATE&#x27;</span>, NOW());</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure></div><p>在这个例子中，<code>trg_employees_update</code> 触发器在每次更新 <code>employees</code> 表中的记录时自动执行，并将更新操作记录到 <code>audit_log</code> 表中。</p><h4 id="实例3：删除操作触发器"><a href="#实例3：删除操作触发器" class="headerlink" title="实例3：删除操作触发器"></a>实例3：删除操作触发器</h4><p>假设我们希望在每次删除 <code>employees</code> 表中的记录时，自动记录删除操作。</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trg_employees_delete</span><br><span class="line">AFTER <span class="keyword">DELETE</span> <span class="keyword">ON</span> employees</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> audit_log (action, log_date)</span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">&#x27;DELETE&#x27;</span>, NOW());</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure></div><p>在这个例子中，<code>trg_employees_delete</code> 触发器在每次删除 <code>employees</code> 表中的记录时自动执行，并将删除操作记录到 <code>audit_log</code> 表中。</p><h3 id="触发器的使用场景"><a href="#触发器的使用场景" class="headerlink" title="触发器的使用场景"></a>触发器的使用场景</h3><ol><li><p><strong>数据完整性</strong>:</p><ul><li>触发器可以用于强制执行复杂的业务规则和约束，例如在插入或更新数据时检查数据的合法性。</li></ul></li><li><p><strong>审计跟踪</strong>:</p><ul><li>触发器可以用于记录对数据的修改，便于审计和追踪。</li></ul></li><li><p><strong>自动更新</strong>:</p><ul><li>触发器可以用于自动更新相关表中的数据，例如在插入新订单时自动更新库存表。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在SQL中，触发器（Trigger）是一种特殊的存储过程，它在特定的数据库操作（如插入、更新或删除）发生时自动执行。触发器通常用于维护数据完整性、执行审计跟踪、记录日志等任务。触发器可以在表级别定义，并且可以与 &lt;code&gt;INSERT&lt;/code&gt;、&lt;code&gt;UPDAT</summary>
      
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>SQL索引</title>
    <link href="http://example.com/2024/09/22/SQLIndex/"/>
    <id>http://example.com/2024/09/22/SQLIndex/</id>
    <published>2024-09-22T08:33:15.000Z</published>
    <updated>2024-11-08T02:21:34.890Z</updated>
    
    <content type="html"><![CDATA[<p>在SQL中，索引是一种数据结构，用于加速数据库表中数据的检索速度。索引类似于书籍的目录，可以帮助数据库系统快速定位到存储在表中的特定数据行，而不必扫描整个表。索引对于提高查询性能非常重要，尤其是在处理大型数据集时。</p><h3 id="索引的基本概念"><a href="#索引的基本概念" class="headerlink" title="索引的基本概念"></a>索引的基本概念</h3><ol><li><p><strong>索引的类型</strong>:</p><ul><li><strong>B-Tree 索引</strong>: 这是最常见的索引类型，适用于范围查询和排序操作。B-Tree（平衡树）索引能够保持数据的有序性，并且支持高效的插入、删除和查找操作。</li><li><strong>哈希索引</strong>: 适用于等值查询，但不支持范围查询。哈希索引通过哈希函数将索引键映射到存储位置，查询速度非常快，但不适合排序操作。</li><li><strong>全文索引</strong>: 用于全文搜索，支持对文本数据进行高效的搜索。</li><li><strong>空间索引</strong>: 用于地理空间数据，支持空间查询操作。</li></ul></li><li><p><strong>索引的创建</strong>:</p><ul><li>使用 <code>CREATE INDEX</code> 语句创建索引。例如：<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_name <span class="keyword">ON</span> table_name (column_name);</span><br></pre></td></tr></table></figure></div></li><li>可以为一个或多个列创建索引。例如：<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_name <span class="keyword">ON</span> table_name (column1, column2);</span><br></pre></td></tr></table></figure></div></li></ul></li><li><p><strong>索引的优点</strong>:</p><ul><li><strong>提高查询速度</strong>: 索引可以显著减少查询所需的时间，尤其是在大型表中。</li><li><strong>加速排序和分组操作</strong>: 索引可以加速 <code>ORDER BY</code> 和 <code>GROUP BY</code> 操作。</li><li><strong>唯一性约束</strong>: 索引可以用于强制列的唯一性，例如 <code>UNIQUE</code> 索引。</li></ul></li><li><p><strong>索引的缺点</strong>:</p><ul><li><strong>增加存储空间</strong>: 索引需要额外的存储空间。</li><li><strong>降低写操作的速度</strong>: 插入、更新和删除操作需要更新索引，因此会降低这些操作的速度。</li><li><strong>维护成本</strong>: 索引需要定期维护，以确保其有效性。</li></ul></li></ol><h3 id="索引的使用场景"><a href="#索引的使用场景" class="headerlink" title="索引的使用场景"></a>索引的使用场景</h3><ol><li><p><strong>主键索引</strong>:</p><ul><li>每个表通常都有一个主键索引，用于唯一标识表中的每一行。主键索引通常是唯一的，并且是自增的。</li><li>例如：<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div></li></ul></li><li><p><strong>唯一索引</strong>:</p><ul><li>用于确保列中的值是唯一的。</li><li>例如：<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX idx_email <span class="keyword">ON</span> employees (email);</span><br></pre></td></tr></table></figure></div></li></ul></li><li><p><strong>复合索引</strong>:</p><ul><li>在多个列上创建的索引，适用于多列查询。</li><li>例如：<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_name_department <span class="keyword">ON</span> employees (name, department);</span><br></pre></td></tr></table></figure></div></li></ul></li><li><p><strong>全文索引</strong>:</p><ul><li>用于全文搜索，适用于文本数据。</li><li>例如：<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> FULLTEXT INDEX idx_content <span class="keyword">ON</span> articles (content);</span><br></pre></td></tr></table></figure></div></li></ul></li></ol><h3 id="索引的维护"><a href="#索引的维护" class="headerlink" title="索引的维护"></a>索引的维护</h3><ol><li><p><strong>重建索引</strong>:</p><ul><li>当索引变得碎片化时，可以通过重建索引来提高性能。</li><li>例如：<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> INDEX idx_name <span class="keyword">ON</span> table_name REBUILD;</span><br></pre></td></tr></table></figure></div></li></ul></li><li><p><strong>删除索引</strong>:</p><ul><li>如果不再需要某个索引，可以将其删除以节省存储空间。</li><li>例如：<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX idx_name <span class="keyword">ON</span> table_name;</span><br></pre></td></tr></table></figure></div></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在SQL中，索引是一种数据结构，用于加速数据库表中数据的检索速度。索引类似于书籍的目录，可以帮助数据库系统快速定位到存储在表中的特定数据行，而不必扫描整个表。索引对于提高查询性能非常重要，尤其是在处理大型数据集时。&lt;/p&gt;
&lt;h3 id=&quot;索引的基本概念&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>SQL视图</title>
    <link href="http://example.com/2024/09/17/SQLView/"/>
    <id>http://example.com/2024/09/17/SQLView/</id>
    <published>2024-09-17T02:57:07.000Z</published>
    <updated>2024-11-08T02:21:34.890Z</updated>
    
    <content type="html"><![CDATA[<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>SQL 中的视图（View）是一个虚拟表，它基于一个或多个表的查询结果。视图本身不存储数据，而是存储查询的定义。当你查询视图时，数据库引擎会执行视图定义的查询，并返回结果。视图可以简化复杂的查询，提供数据的安全性，并隐藏底层表的复杂性。</p><h3 id="1-创建视图（CREATE-VIEW）"><a href="#1-创建视图（CREATE-VIEW）" class="headerlink" title="1. 创建视图（CREATE VIEW）"></a>1. 创建视图（CREATE VIEW）</h3><p>你可以使用 <code>CREATE VIEW</code> 语句来创建视图。视图的定义可以包含 <code>SELECT</code> 语句中的所有元素，如 <code>WHERE</code>、<code>GROUP BY</code>、<code>JOIN</code> 等。</p><h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> columns</span><br><span class="line"><span class="keyword">FROM</span> tables</span><br><span class="line"><span class="keyword">WHERE</span> conditions;</span><br></pre></td></tr></table></figure></div><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><p>假设我们有一个 <code>employees</code> 表和一个 <code>departments</code> 表，我们希望创建一个视图，显示每个员工的姓名、部门名称和工资：</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> employee_department_view <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> employees.employee_name, departments.department_name, employees.salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">JOIN</span> departments <span class="keyword">ON</span> employees.department_id <span class="operator">=</span> departments.department_id;</span><br></pre></td></tr></table></figure></div><h3 id="2-查询视图（SELECT）"><a href="#2-查询视图（SELECT）" class="headerlink" title="2. 查询视图（SELECT）"></a>2. 查询视图（SELECT）</h3><p>查询视图与查询表的方式相同。你可以像查询表一样查询视图。</p><h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employee_department_view;</span><br></pre></td></tr></table></figure></div><h3 id="3-更新视图（UPDATE-VIEW）"><a href="#3-更新视图（UPDATE-VIEW）" class="headerlink" title="3. 更新视图（UPDATE VIEW）"></a>3. 更新视图（UPDATE VIEW）</h3><p>在某些情况下，你可以通过视图更新底层表的数据。视图必须是可更新的，即视图的定义必须满足一定的条件（如没有 <code>GROUP BY</code>、<code>HAVING</code>、<code>DISTINCT</code> 等）。</p><h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> employee_department_view</span><br><span class="line"><span class="keyword">SET</span> salary <span class="operator">=</span> <span class="number">6000</span></span><br><span class="line"><span class="keyword">WHERE</span> employee_name <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span>;</span><br></pre></td></tr></table></figure></div><h3 id="4-删除视图（DROP-VIEW）"><a href="#4-删除视图（DROP-VIEW）" class="headerlink" title="4. 删除视图（DROP VIEW）"></a>4. 删除视图（DROP VIEW）</h3><p>你可以使用 <code>DROP VIEW</code> 语句删除视图。</p><h4 id="语法：-1"><a href="#语法：-1" class="headerlink" title="语法："></a>语法：</h4><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> view_name;</span><br></pre></td></tr></table></figure></div><h4 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h4><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> employee_department_view;</span><br></pre></td></tr></table></figure></div><h3 id="5-修改视图（ALTER-VIEW）"><a href="#5-修改视图（ALTER-VIEW）" class="headerlink" title="5. 修改视图（ALTER VIEW）"></a>5. 修改视图（ALTER VIEW）</h3><p>在某些数据库系统中，你可以使用 <code>ALTER VIEW</code> 语句修改视图的定义。</p><h4 id="语法：-2"><a href="#语法：-2" class="headerlink" title="语法："></a>语法：</h4><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> columns</span><br><span class="line"><span class="keyword">FROM</span> tables</span><br><span class="line"><span class="keyword">WHERE</span> conditions;</span><br></pre></td></tr></table></figure></div><h4 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h4><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> employee_department_view <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> employees.employee_name, departments.department_name, employees.salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">JOIN</span> departments <span class="keyword">ON</span> employees.department_id <span class="operator">=</span> departments.department_id</span><br><span class="line"><span class="keyword">WHERE</span> employees.salary <span class="operator">&gt;</span> <span class="number">5000</span>;</span><br></pre></td></tr></table></figure></div><h3 id="6-视图的优点"><a href="#6-视图的优点" class="headerlink" title="6. 视图的优点"></a>6. 视图的优点</h3><ul><li>简化查询:视图可以将复杂的查询封装起来，简化用户的查询操作。</li><li>数据安全:视图可以限制用户只能访问特定的数据，从而提高数据的安全性。</li><li>数据独立性:视图可以隐藏底层表的复杂性，使用户无需了解底层表的结构。</li><li>逻辑数据分组:视图可以将多个表的数据逻辑上组合在一起，方便用户进行数据分析。</li></ul><h3 id="7-视图的缺点"><a href="#7-视图的缺点" class="headerlink" title="7. 视图的缺点"></a>7. 视图的缺点</h3><ul><li>性能问题:视图的查询性能可能不如直接查询底层表，尤其是在视图定义复杂的情况下。</li><li>更新限制:视图的更新操作受到限制，不是所有的视图都可以进行更新操作。</li><li>存储开销:虽然视图本身不存储数据，但视图的定义会占用存储空间。</li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CreatE</span> <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span> 子查询语句 [<span class="keyword">WITH</span> <span class="keyword">CHECK</span> OPTION]</span><br></pre></td></tr></table></figure></div><p><code>WITH CHECK OPTION</code>是指当创建后，如果更新视图中的数据，是否要满足子查询中的条件表达式，不满足将无法插入，创建后，我们就可以使用<code>SELECT</code>来直接查询视图上的数据，因此还能在视图上的基础导出其他视图</p><ol><li>若视图是由两个以上的基本表导出的，则此视图不允许更新</li><li>若视图的字段来自地段表达式或常数，则不允许对此视图执行<code>INSERT</code>或<code>UPDATE</code>操作，但允许执行<code>DELETE</code>操作</li><li>若视图的字段来自集函数，则此视图不允许更新</li><li>若视图定义中含有<code>GROUP BY</code>或<code>HAVING</code>，则不允许更新</li><li>若视图定义中含有<code>DISTINCT</code>短语，则不允许更新</li><li>若视图定义中含有嵌套查询，并且内层查询的<code>FROM</code>子句中涉及的表也是导出该图的基本表，则此视图不允许更新。<br>例如将成绩在平均成绩以上的元组定义成一个视图<code>GOOD_SC</code>:</li></ol><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> GOOD_SC <span class="keyword">AS</span> <span class="keyword">SELECT</span> Sno, Cno, Grade <span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> Grade <span class="operator">&gt;</span> (<span class="keyword">SElECt</span> <span class="built_in">AVG</span>(Grade) <span class="keyword">FROM</span> SC);</span><br></pre></td></tr></table></figure></div><p>导出视图<code>GOOD_SC</code>的基本表是<code>SC</code>表，内层查询中涉及的基本表也是<code>SC</code>，所以视图<code>GOOD_SC</code>是不允许更新的</p><ol start="7"><li>一个不允许更新的视图上定义的视图也不允许更新</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;视图&quot;&gt;&lt;a href=&quot;#视图&quot; class=&quot;headerlink&quot; title=&quot;视图&quot;&gt;&lt;/a&gt;视图&lt;/h2&gt;&lt;p&gt;SQL 中的视图（View）是一个虚拟表，它基于一个或多个表的查询结果。视图本身不存储数据，而是存储查询的定义。当你查询视图时，数据库引擎会</summary>
      
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>SQL语句</title>
    <link href="http://example.com/2024/09/17/SQLGRammar/"/>
    <id>http://example.com/2024/09/17/SQLGRammar/</id>
    <published>2024-09-17T02:01:46.000Z</published>
    <updated>2024-11-08T02:21:34.890Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库定义语言-DDL"><a href="#数据库定义语言-DDL" class="headerlink" title="数据库定义语言(DDL)"></a>数据库定义语言(DDL)</h2><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database <span class="operator">&lt;</span>database_name<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></div><p>为了支持中文，我们需要在创建的时候可以修改编码格式</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="operator">&lt;</span>database_name<span class="operator">&gt;</span> <span class="keyword">DEFAULT</span> CHARSET utf8 <span class="keyword">COLLATE</span> utf8_general_ci</span><br></pre></td></tr></table></figure></div><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span>(列名 数据类型[列级约束条件],</span><br><span class="line">                          列名 数据类型[列级约束条件],</span><br><span class="line">                          ...</span><br><span class="line">                          [, 表级约束条件])</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="SQL数据类型"><a href="#SQL数据类型" class="headerlink" title="SQL数据类型"></a>SQL数据类型</h3><h4 id="数值类型-Numeric-Types"><a href="#数值类型-Numeric-Types" class="headerlink" title="数值类型 (Numeric Types)"></a>数值类型 (Numeric Types)</h4><ol><li><p><strong>整数类型</strong>：</p><ul><li><code>TINYINT</code>: 存储很小的整数，通常范围是 <code>-128</code> 到 <code>127</code>。</li><li><code>SMALLINT</code>: 存储较小的整数，通常范围是 <code>-32768</code> 到 <code>32767</code>。</li><li><code>MEDIUMINT</code>: MySQL 特有的类型，适合存储中等大小的整数。</li><li><code>INT</code> 或 <code>INTEGER</code>: 存储普通大小的整数，通常范围是 <code>-2147483648</code> 到 <code>2147483647</code>。</li><li><code>BIGINT</code>: 存储非常大的整数，通常范围是 <code>-9223372036854775808</code> 到 <code>9223372036854775807</code>。</li><li><code>UNSIGNED</code>: 以上整数类型可以加上此属性以存储非负整数，范围从 <code>0</code> 开始。</li></ul></li><li><p><strong>小数类型</strong>：</p><ul><li><code>DECIMAL</code> 或 <code>NUMERIC</code>: 用于存储精确的小数，格式为 <code>DECIMAL(M, D)</code>，其中 <code>M</code> 是数字总长度，<code>D</code> 是小数点后的位数。</li><li><code>FLOAT</code>: 用于存储浮点数，可能丢失精度。</li><li><code>DOUBLE</code> 或 <code>REAL</code>: 用于存储更高精度的浮点数。</li></ul></li><li><p><strong>位类型</strong>：</p><ul><li><code>BIT</code>: 用于存储位字段值。</li></ul></li></ol><h4 id="字符串类型-String-Types"><a href="#字符串类型-String-Types" class="headerlink" title="字符串类型 (String Types)"></a>字符串类型 (String Types)</h4><ol><li><p><strong>定长字符串</strong>：</p><ul><li><code>CHAR(n)</code>: 存储定长的字符串，其中 <code>n</code> 是字符串的最大长度。如果输入的字符串长度不够，会用空格填充。</li></ul></li><li><p><strong>变长字符串</strong>：</p><ul><li><code>VARCHAR(n)</code>: 存储变长的字符串，其中 <code>n</code> 是字符串的最大长度。</li><li><code>BINARY(n)</code> 和 <code>VARBINARY(n)</code>: 分别存储定长和变长的二进制字符串。</li></ul></li><li><p><strong>大对象类型</strong>：</p><ul><li><code>TEXT</code>: 用于存储较大的文本数据。</li><li><code>BLOB</code>: 用于存储较大的二进制数据。</li><li><code>MEDIUMTEXT</code> 和 <code>MEDIUMBLOB</code>: MySQL 特有的类型，用于存储中等大小的文本或二进制数据。</li><li><code>LONGTEXT</code> 和 <code>LONGBLOB</code>: MySQL 特有的类型，用于存储非常大的文本或二进制数据。</li></ul></li></ol><h4 id="日期-时间类型-Date-Time-Types"><a href="#日期-时间类型-Date-Time-Types" class="headerlink" title="日期&#x2F;时间类型 (Date&#x2F;Time Types)"></a>日期&#x2F;时间类型 (Date&#x2F;Time Types)</h4><ol><li><p><strong>日期类型</strong>：</p><ul><li><code>DATE</code>: 存储日期值。</li><li><code>TIME</code>: 存储时间值。</li><li><code>YEAR</code>: MySQL 特有的类型，用于存储四位数的年份。</li></ul></li><li><p><strong>日期时间类型</strong>：</p><ul><li><code>DATETIME</code>: 存储日期和时间值，支持的范围通常是 <code>1000-01-01 00:00:00</code> 至 <code>9999-12-31 23:59:59</code>。</li><li><code>TIMESTAMP</code>: 存储日期和时间值，并且在插入或更新时可以自动设置为当前的日期和时间。</li><li><code>INTERVAL</code>: PostgreSQL 特有的类型，用于存储时间间隔。</li></ul></li></ol><h4 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h4><ol><li><p><strong>枚举类型</strong>：</p><ul><li><code>ENUM(&#39;value1&#39;, &#39;value2&#39;, ... )</code>: 存储一系列预先定义的值中的一个。</li></ul></li><li><p><strong>集合类型</strong>：</p><ul><li><code>SET(&#39;value1&#39;, &#39;value2&#39;, ... )</code>: 存储一系列预先定义的值中的一个或多个值。</li></ul></li><li><p><strong>JSON 类型</strong>：</p><ul><li><code>JSON</code>: MySQL 8.0 之后支持的类型，用于存储 JSON 文档。</li></ul></li><li><p><strong>空间类型</strong>：</p><ul><li><code>POINT</code>, <code>LINESTRING</code>, <code>POLYGON</code>, <code>MULTIPOINT</code>, <code>MULTILINESTRING</code>, <code>MULTIPOLYGON</code>, <code>GEOMETRYCOLLECTION</code>: 用于存储地理空间数据。</li></ul></li></ol><h3 id="列级约束条件"><a href="#列级约束条件" class="headerlink" title="列级约束条件"></a>列级约束条件</h3><p>有六种:主键(Primary Key),非空(NotNull)&#x2F;空值null, 默认(Default),外键(外键约束),唯一键(Unique Key),检查约束(Check)(MySql不支持)、默认Default。</p><h3 id="表级约束条件"><a href="#表级约束条件" class="headerlink" title="表级约束条件"></a>表级约束条件</h3><p>有四种：主键、外键、唯一、检查</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">CONSTRAINT</span> <span class="operator">&lt;</span>外键名<span class="operator">&gt;</span>] <span class="keyword">FOREIGN</span> KEY 字段名 [..., 字段名<span class="number">2</span>, ...] <span class="keyword">REFERENCES</span> <span class="operator">&lt;</span>主表名<span class="operator">&gt;</span> 主键列<span class="number">1</span> [, 主键列<span class="number">2</span>, ...]</span><br></pre></td></tr></table></figure></div><p>现在来创建三个表</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> study(sid <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> name <span class="type">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> sex ENUM(<span class="string">&#x27;male&#x27;</span>, <span class="string">&#x27;female&#x27;</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;male&#x27;</span>);</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> teacher(tid <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> name <span class="type">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> teach (</span><br><span class="line">    tid <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    sid <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> f_tid <span class="keyword">FOREIGN</span> KEY (tid) <span class="keyword">REFERENCES</span> teacher(tid)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- mysql&gt; CREATE TABLE teach(tid int not null, sid int not null);</span></span><br><span class="line"><span class="comment">-- mysql&gt; ALTER TABLE teach</span></span><br><span class="line"><span class="comment">--     -&gt; ADD CONSTRAINT f_tid</span></span><br><span class="line"><span class="comment">--     -&gt; FOREIGN KEY(tid)</span></span><br><span class="line"><span class="comment">--     -&gt; REFERENCES teacher(tid);</span></span><br></pre></td></tr></table></figure></div><h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><p>如果我们想要修改表结构，可以通过<code>alter table</code>进行修改</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名[<span class="keyword">ADD</span> 新列名 数据类型[列级约束条件]]</span><br><span class="line">                [<span class="keyword">DROP</span> <span class="keyword">COLUMN</span> 列名[restrict<span class="operator">|</span>cascade]]</span><br><span class="line">                [<span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> 列名 数据类型]</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> 表名[restrict<span class="operator">|</span>cascade]</span><br></pre></td></tr></table></figure></div><h2 id="数据库操作语言-DML"><a href="#数据库操作语言-DML" class="headerlink" title="数据库操作语言(DML)"></a>数据库操作语言(DML)</h2><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 <span class="keyword">VALUES</span>(值<span class="number">1</span>, 值<span class="number">2</span>, ...)</span><br></pre></td></tr></table></figure></div><p>如果插入的数据与列一一对应，那么可以省略列名，但是如果希望向指定列上插入数据，就需要给出列名</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名(列名<span class="number">1</span>, 列名<span class="number">2</span>, ...) <span class="keyword">VALUES</span>(值<span class="number">1</span>, 值<span class="number">2</span>, ...)</span><br></pre></td></tr></table></figure></div><p>也可以一次性向数据库中插入多条数据</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名(列名<span class="number">1</span>, 列名<span class="number">2</span>, ...) <span class="keyword">VALUES</span>(值<span class="number">1</span>, 值<span class="number">2</span>, ...), (值<span class="number">1</span>, 值<span class="number">2</span>, ...)</span><br></pre></td></tr></table></figure></div><h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> 表名 <span class="keyword">SET</span> 列名 <span class="operator">=</span> 值, 列名 <span class="operator">=</span> 值, ... <span class="keyword">WHERE</span> 条件</span><br></pre></td></tr></table></figure></div><blockquote><p>注意，SQL语句中等于判断是<code>=</code></p></blockquote><pre><code>如果忘记加where来限定条件，那么将使得整个表的数据都被修改</code></pre><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>删除全部数据</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名</span><br></pre></td></tr></table></figure></div><p>删除指定数据</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件</span><br></pre></td></tr></table></figure></div><h2 id="数据库查询语言DQL"><a href="#数据库查询语言DQL" class="headerlink" title="数据库查询语言DQL"></a>数据库查询语言DQL</h2><h3 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h3><p>只需要在一张表中查找数据，使用<code>select</code>语句即可</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">-- 指定查询某一列数据</span></span><br><span class="line"><span class="keyword">SELECT</span> 列名[, 列名] <span class="keyword">FROM</span> 表名</span><br><span class="line"><span class="comment">-- 会以别名来显示此列</span></span><br><span class="line"><span class="keyword">SELECT</span> 列名 <span class="keyword">AS</span> 别名 <span class="keyword">FROM</span> 表名</span><br><span class="line"><span class="comment">-- 查询所有列的数据</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名</span><br><span class="line"><span class="comment">-- 只查询不重复的值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 列名 <span class="keyword">FROM</span> 表名</span><br><span class="line"><span class="comment">-- 使用where来限定条件</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="常用查询条件"><a href="#常用查询条件" class="headerlink" title="常用查询条件"></a>常用查询条件</h3><ul><li>一般的比较运算符<code>=, &gt;, &lt;, &lt;=, &gt;=, !=</code></li><li>是否会在集合中<code>in, not in</code></li><li>字符模糊匹配<code>like, not like</code></li><li>多重条件连接查询<code>and, or, not</code></li></ul><h3 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 列名 <span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span></span><br></pre></td></tr></table></figure></div><p>ASC 升序 DESC 降序 默认为升序</p><p>添加多个排序</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 列名<span class="number">1</span> <span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>, 列名<span class="number">2</span> <span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span></span><br></pre></td></tr></table></figure></div><p>会先按照列名1进行排序，再按照列名2进行排序</p><h3 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h3><p>SQL 中的聚集函数（Aggregate Functions）用于对一组值执行计算，并返回单个值。这些函数通常用于对表中的数据进行汇总和分析。以下是一些常见的 SQL 聚集函数：</p><h4 id="1-COUNT"><a href="#1-COUNT" class="headerlink" title="1. COUNT()"></a>1. <code>COUNT()</code></h4><ul><li><strong>用途</strong>：计算表中行的数量或满足特定条件的行的数量。</li><li><strong>示例</strong>：<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> employees;  <span class="comment">-- 计算 employees 表中的总行数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> department) <span class="keyword">FROM</span> employees;  <span class="comment">-- 计算 employees 表中不同部门的数量</span></span><br></pre></td></tr></table></figure></div></li></ul><h4 id="2-SUM"><a href="#2-SUM" class="headerlink" title="2. SUM()"></a>2. <code>SUM()</code></h4><ul><li><strong>用途</strong>：计算某一列值的总和。</li><li><strong>示例</strong>：<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(salary) <span class="keyword">FROM</span> employees;  <span class="comment">-- 计算 employees 表中所有员工的总工资</span></span><br></pre></td></tr></table></figure></div></li></ul><h4 id="3-AVG"><a href="#3-AVG" class="headerlink" title="3. AVG()"></a>3. <code>AVG()</code></h4><ul><li><strong>用途</strong>：计算某一列值的平均值。</li><li><strong>示例</strong>：<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">FROM</span> employees;  <span class="comment">-- 计算 employees 表中所有员工的平均工资</span></span><br></pre></td></tr></table></figure></div></li></ul><h4 id="4-MIN"><a href="#4-MIN" class="headerlink" title="4. MIN()"></a>4. <code>MIN()</code></h4><ul><li><strong>用途</strong>：返回某一列的最小值。</li><li><strong>示例</strong>：<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(salary) <span class="keyword">FROM</span> employees;  <span class="comment">-- 返回 employees 表中最低的工资</span></span><br></pre></td></tr></table></figure></div></li></ul><h4 id="5-MAX"><a href="#5-MAX" class="headerlink" title="5. MAX()"></a>5. <code>MAX()</code></h4><ul><li><strong>用途</strong>：返回某一列的最大值。</li><li><strong>示例</strong>：<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(salary) <span class="keyword">FROM</span> employees;  <span class="comment">-- 返回 employees 表中最高的工资</span></span><br></pre></td></tr></table></figure></div></li></ul><h4 id="6-GROUP-CONCAT"><a href="#6-GROUP-CONCAT" class="headerlink" title="6. GROUP_CONCAT()"></a>6. <code>GROUP_CONCAT()</code></h4><ul><li><strong>用途</strong>：将某一列的值连接成一个字符串，通常用于将分组后的值合并。</li><li><strong>示例</strong>：<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department, GROUP_CONCAT(name) <span class="keyword">FROM</span> employees <span class="keyword">GROUP</span> <span class="keyword">BY</span> department;  <span class="comment">-- 将每个部门的员工名字连接成一个字符串</span></span><br></pre></td></tr></table></figure></div></li></ul><h4 id="7-VARIANCE-和-STDDEV"><a href="#7-VARIANCE-和-STDDEV" class="headerlink" title="7. VARIANCE() 和 STDDEV()"></a>7. <code>VARIANCE()</code> 和 <code>STDDEV()</code></h4><ul><li><strong>用途</strong>：计算某一列值的方差和标准差。</li><li><strong>示例</strong>：<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> VARIANCE(salary) <span class="keyword">FROM</span> employees;  <span class="comment">-- 计算 employees 表中工资的方差</span></span><br><span class="line"><span class="keyword">SELECT</span> STDDEV(salary) <span class="keyword">FROM</span> employees;  <span class="comment">-- 计算 employees 表中工资的标准差</span></span><br></pre></td></tr></table></figure></div></li></ul><h4 id="8-BIT-AND-BIT-OR-BIT-XOR"><a href="#8-BIT-AND-BIT-OR-BIT-XOR" class="headerlink" title="8. BIT_AND(), BIT_OR(), BIT_XOR()"></a>8. <code>BIT_AND()</code>, <code>BIT_OR()</code>, <code>BIT_XOR()</code></h4><ul><li><strong>用途</strong>：对某一列的值执行按位与、按位或、按位异或操作。</li><li><strong>示例</strong>：<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> BIT_AND(flags) <span class="keyword">FROM</span> employees;  <span class="comment">-- 对 employees 表中的 flags 列执行按位与操作</span></span><br></pre></td></tr></table></figure></div></li></ul><h4 id="使用聚集函数的注意事项："><a href="#使用聚集函数的注意事项：" class="headerlink" title="使用聚集函数的注意事项："></a>使用聚集函数的注意事项：</h4><ul><li><strong>NULL 值</strong>：聚集函数通常会忽略 <code>NULL</code> 值。例如，<code>SUM()</code> 函数不会将 <code>NULL</code> 值计入总和。</li><li><strong>GROUP BY 子句</strong>：聚集函数通常与 <code>GROUP BY</code> 子句一起使用，以便对数据进行分组并计算每个组的汇总值。</li><li><strong>HAVING 子句</strong>：用于过滤分组后的结果，通常与 <code>GROUP BY</code> 子句一起使用。</li></ul><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department, <span class="built_in">AVG</span>(salary) <span class="keyword">AS</span> avg_salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">AVG</span>(salary) <span class="operator">&gt;</span> <span class="number">50000</span>;</span><br></pre></td></tr></table></figure></div><p>这个查询会计算每个部门的平均工资，并只返回平均工资大于 50000 的部门。</p><h3 id="分组分页查询"><a href="#分组分页查询" class="headerlink" title="分组分页查询"></a>分组分页查询</h3><p>通过<code>group by</code>来对查询结果进行分组，需要结合聚集函数一起使用</p><p>在 MySQL 中，分组分页查询通常涉及使用 <code>GROUP BY</code> 子句对数据进行分组，然后使用 <code>LIMIT</code> 子句对结果进行分页。以下是详细解释和示例：</p><h4 id="1-GROUP-BY-子句"><a href="#1-GROUP-BY-子句" class="headerlink" title="1. GROUP BY 子句"></a>1. <code>GROUP BY</code> 子句</h4><p><code>GROUP BY</code> 子句用于将数据按照一个或多个列进行分组。通常与聚集函数（如 <code>COUNT</code>, <code>SUM</code>, <code>AVG</code>, <code>MIN</code>, <code>MAX</code> 等）一起使用，以便对每个组进行汇总计算。</p><h4 id="2-LIMIT-子句"><a href="#2-LIMIT-子句" class="headerlink" title="2. LIMIT 子句"></a>2. <code>LIMIT</code> 子句</h4><p><code>LIMIT</code> 子句用于限制查询结果的行数。通常用于分页查询，通过指定起始行和返回的行数来实现分页。</p><h4 id="示例：分组分页查询"><a href="#示例：分组分页查询" class="headerlink" title="示例：分组分页查询"></a>示例：分组分页查询</h4><p>假设我们有一个 <code>orders</code> 表，结构如下：</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> orders (</span><br><span class="line">    order_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    customer_id <span class="type">INT</span>,</span><br><span class="line">    order_date <span class="type">DATE</span>,</span><br><span class="line">    amount <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><p>我们希望按 <code>customer_id</code> 分组，并计算每个客户的订单总金额，然后对结果进行分页。</p><h4 id="查询每个客户的订单总金额"><a href="#查询每个客户的订单总金额" class="headerlink" title="查询每个客户的订单总金额"></a>查询每个客户的订单总金额</h4><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customer_id, <span class="built_in">SUM</span>(amount) <span class="keyword">AS</span> total_amount</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> customer_id;</span><br></pre></td></tr></table></figure></div><h4 id="分页查询每个客户的订单总金额"><a href="#分页查询每个客户的订单总金额" class="headerlink" title="分页查询每个客户的订单总金额"></a>分页查询每个客户的订单总金额</h4><p>假设我们希望每页显示 10 个客户，查询第 2 页的数据（即第 11 到第 20 个客户）：</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customer_id, <span class="built_in">SUM</span>(amount) <span class="keyword">AS</span> total_amount</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> customer_id</span><br><span class="line">LIMIT <span class="number">10</span> <span class="keyword">OFFSET</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure></div><h4 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h4><ul><li>**<code>LIMIT 10 OFFSET 10</code>**：<ul><li><code>LIMIT 10</code> 表示每页显示 10 行。</li><li><code>OFFSET 10</code> 表示从第 11 行开始（因为 <code>OFFSET</code> 是从 0 开始计数的）。</li><li><code>LIMIT 起始位置, 数量</code></li></ul></li></ul><h4 id="使用变量进行分页"><a href="#使用变量进行分页" class="headerlink" title="使用变量进行分页"></a>使用变量进行分页</h4><p>如果你希望动态地指定页码和每页的行数，可以使用变量：</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="variable">@page_number</span> <span class="operator">=</span> <span class="number">2</span>;  <span class="comment">-- 页码，从 1 开始</span></span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@page_size</span> <span class="operator">=</span> <span class="number">10</span>;   <span class="comment">-- 每页的行数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> customer_id, <span class="built_in">SUM</span>(amount) <span class="keyword">AS</span> total_amount</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> customer_id</span><br><span class="line">LIMIT <span class="variable">@page_size</span> <span class="keyword">OFFSET</span> ((<span class="variable">@page_number</span> <span class="operator">-</span> <span class="number">1</span>) <span class="operator">*</span> <span class="variable">@page_size</span>);</span><br></pre></td></tr></table></figure></div><h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><ol><li><strong>性能问题</strong>：分组和分页查询可能会影响性能，尤其是在处理大量数据时。可以考虑使用索引来优化查询。</li><li><strong><code>HAVING</code> 子句</strong>：如果你需要在分组后对结果进行过滤，可以使用 <code>HAVING</code> 子句。例如，只显示订单总金额大于 1000 的客户：<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customer_id, <span class="built_in">SUM</span>(amount) <span class="keyword">AS</span> total_amount</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> customer_id</span><br><span class="line"><span class="keyword">HAVING</span> total_amount <span class="operator">&gt;</span> <span class="number">1000</span></span><br><span class="line">LIMIT <span class="number">10</span> <span class="keyword">OFFSET</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure></div></li></ol><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><p>多表查询是同时查询两个或两个以上的表，多表查询会通过连接转换为单表查询</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表<span class="number">1</span>, 表<span class="number">2</span></span><br></pre></td></tr></table></figure></div><p>直接这样查询会得到两张笛卡尔积，也就是每一项数据和另一张表的每一项数据都结合一次，会产生庞大的数据</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表<span class="number">1</span>, 表<span class="number">2</span> <span class="keyword">WHERE</span> 条件</span><br></pre></td></tr></table></figure></div><p>这样只会从笛卡尔积的结果中得到满足条件的数据</p><h3 id="自身连接查询"><a href="#自身连接查询" class="headerlink" title="自身连接查询"></a>自身连接查询</h3><p>自身连接就是将表自身和表进行笛卡尔积计算，得到结果，但是由于表名相同，因此要先起一个别名</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">AS</span> t1, 表<span class="number">1</span> <span class="keyword">AS</span> t2</span><br></pre></td></tr></table></figure></div><h3 id="外连接查询"><a href="#外连接查询" class="headerlink" title="外连接查询"></a>外连接查询</h3><p>SQL 中的外连接（Outer Join）用于从两个或多个表中获取数据，即使某些行在连接条件中没有匹配的行。外连接分为三种类型：左外连接（Left Outer Join）、右外连接（Right Outer Join）和全外连接（Full Outer Join）。  </p><p>假设我们现在有一张存储所有用户的表，还有一张用户详细信息的表，我们希望将这两张表结合到一起来查看完整数据</p><h4 id="1-左外连接（Left-Outer-Join）"><a href="#1-左外连接（Left-Outer-Join）" class="headerlink" title="1. 左外连接（Left Outer Join）"></a>1. 左外连接（Left Outer Join）</h4><p>左外连接返回左表中的所有行，即使右表中没有匹配的行。如果右表中没有匹配的行，结果集中对应右表的列将为 <code>NULL</code>。</p><h5 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h5><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> columns</span><br><span class="line"><span class="keyword">FROM</span> left_table</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> right_table</span><br><span class="line"><span class="keyword">ON</span> left_table.column <span class="operator">=</span> right_table.column;</span><br></pre></td></tr></table></figure></div><h5 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h5><p>假设有两个表 <code>employees</code> 和 <code>departments</code>：</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees (</span><br><span class="line">    employee_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    employee_name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    department_id <span class="type">INT</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> departments (</span><br><span class="line">    department_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    department_name <span class="type">VARCHAR</span>(<span class="number">100</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><p>我们希望获取所有员工及其所属部门的信息，包括那些没有部门的员工：</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employees.employee_name, departments.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments</span><br><span class="line"><span class="keyword">ON</span> employees.department_id <span class="operator">=</span> departments.department_id;</span><br></pre></td></tr></table></figure></div><h4 id="2-右外连接（Right-Outer-Join）"><a href="#2-右外连接（Right-Outer-Join）" class="headerlink" title="2. 右外连接（Right Outer Join）"></a>2. 右外连接（Right Outer Join）</h4><p>右外连接返回右表中的所有行，即使左表中没有匹配的行。如果左表中没有匹配的行，结果集中对应左表的列将为 <code>NULL</code>。</p><h5 id="语法：-1"><a href="#语法：-1" class="headerlink" title="语法："></a>语法：</h5><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> columns</span><br><span class="line"><span class="keyword">FROM</span> left_table</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> right_table</span><br><span class="line"><span class="keyword">ON</span> left_table.column <span class="operator">=</span> right_table.column;</span><br></pre></td></tr></table></figure></div><h5 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h5><p>我们希望获取所有部门及其员工的信息，包括那些没有员工的部门：</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employees.employee_name, departments.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments</span><br><span class="line"><span class="keyword">ON</span> employees.department_id <span class="operator">=</span> departments.department_id;</span><br></pre></td></tr></table></figure></div><h4 id="3-全外连接（Full-Outer-Join）"><a href="#3-全外连接（Full-Outer-Join）" class="headerlink" title="3. 全外连接（Full Outer Join）"></a>3. 全外连接（Full Outer Join）</h4><p>全外连接返回左表和右表中的所有行，即使它们在连接条件中没有匹配的行。如果某个表中没有匹配的行，结果集中对应另一个表的列将为 <code>NULL</code>。</p><h5 id="语法：-2"><a href="#语法：-2" class="headerlink" title="语法："></a>语法：</h5><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> columns</span><br><span class="line"><span class="keyword">FROM</span> left_table</span><br><span class="line"><span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> right_table</span><br><span class="line"><span class="keyword">ON</span> left_table.column <span class="operator">=</span> right_table.column;</span><br></pre></td></tr></table></figure></div><h5 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h5><p>我们希望获取所有员工和所有部门的信息，包括那些没有部门或没有员工的记录：</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employees.employee_name, departments.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> departments</span><br><span class="line"><span class="keyword">ON</span> employees.department_id <span class="operator">=</span> departments.department_id;</span><br></pre></td></tr></table></figure></div><h4 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a>注意事项：</h4><ul><li><strong>MySQL 不支持全外连接</strong>：MySQL 不直接支持 <code>FULL OUTER JOIN</code>，但可以通过 <code>UNION</code> 操作符来模拟全外连接。</li><li><strong>模拟全外连接</strong>：<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employees.employee_name, departments.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments</span><br><span class="line"><span class="keyword">ON</span> employees.department_id <span class="operator">=</span> departments.department_id</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> employees.employee_name, departments.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments</span><br><span class="line"><span class="keyword">ON</span> employees.department_id <span class="operator">=</span> departments.department_id;</span><br></pre></td></tr></table></figure></div></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>外连接允许你从两个或多个表中获取数据，即使某些行在连接条件中没有匹配的行。左外连接返回左表中的所有行，右外连接返回右表中的所有行，全外连接返回两个表中的所有行。通过合理使用外连接，你可以更灵活地处理数据关联和缺失情况。</p><h3 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h3><p>可以将查询的结果作为另一个查询的条件</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 列名 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> 列名 <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件);</span><br></pre></td></tr></table></figure></div><p>SQL 中的嵌套查询（Nested Query），也称为子查询（Subquery），是指在一个查询语句中嵌套另一个查询语句。子查询可以出现在 <code>SELECT</code>、<code>FROM</code>、<code>WHERE</code>、<code>HAVING</code> 等子句中，用于从数据库中获取更复杂的数据。</p><h4 id="1-子查询的基本概念"><a href="#1-子查询的基本概念" class="headerlink" title="1. 子查询的基本概念"></a>1. 子查询的基本概念</h4><p>子查询是一个完整的 <code>SELECT</code> 语句，它可以返回一个标量值（单个值）、一个行、一个列或一个表。子查询通常用括号 <code>()</code> 括起来，并且可以嵌套在主查询的各个部分。</p><h4 id="2-子查询的类型"><a href="#2-子查询的类型" class="headerlink" title="2. 子查询的类型"></a>2. 子查询的类型</h4><p>根据子查询返回的结果类型，子查询可以分为以下几种类型：</p><h5 id="2-1-标量子查询（Scalar-Subquery）"><a href="#2-1-标量子查询（Scalar-Subquery）" class="headerlink" title="2.1 标量子查询（Scalar Subquery）"></a>2.1 标量子查询（Scalar Subquery）</h5><p>标量子查询返回单个值（即一行一列）。它通常用于 <code>SELECT</code> 子句、<code>WHERE</code> 子句或 <code>HAVING</code> 子句中。</p><h6 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h6><p>假设我们有一个 <code>employees</code> 表和一个 <code>departments</code> 表，我们希望查询每个员工的姓名及其所属部门的名称：</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_name,</span><br><span class="line">       (<span class="keyword">SELECT</span> department_name</span><br><span class="line">        <span class="keyword">FROM</span> departments</span><br><span class="line">        <span class="keyword">WHERE</span> departments.department_id <span class="operator">=</span> employees.department_id) <span class="keyword">AS</span> department_name</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure></div><h5 id="2-2-行子查询（Row-Subquery）"><a href="#2-2-行子查询（Row-Subquery）" class="headerlink" title="2.2 行子查询（Row Subquery）"></a>2.2 行子查询（Row Subquery）</h5><p>行子查询返回一行数据（即多列）。它通常用于 <code>WHERE</code> 子句中。</p><h6 id="示例：-5"><a href="#示例：-5" class="headerlink" title="示例："></a>示例：</h6><p>假设我们希望查询工资最高的员工的姓名和工资：</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_name, salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> (salary, employee_id) <span class="operator">=</span> (<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(salary), employee_id</span><br><span class="line">                               <span class="keyword">FROM</span> employees);</span><br></pre></td></tr></table></figure></div><h5 id="2-3-列子查询（Column-Subquery）"><a href="#2-3-列子查询（Column-Subquery）" class="headerlink" title="2.3 列子查询（Column Subquery）"></a>2.3 列子查询（Column Subquery）</h5><p>列子查询返回一列数据（即多行一列）。它通常用于 <code>WHERE</code> 子句中。</p><h6 id="示例：-6"><a href="#示例：-6" class="headerlink" title="示例："></a>示例：</h6><p>假设我们希望查询所有工资高于平均工资的员工：</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_name, salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">FROM</span> employees);</span><br></pre></td></tr></table></figure></div><h5 id="2-4-表子查询（Table-Subquery）"><a href="#2-4-表子查询（Table-Subquery）" class="headerlink" title="2.4 表子查询（Table Subquery）"></a>2.4 表子查询（Table Subquery）</h5><p>表子查询返回一个表（即多行多列）。它通常用于 <code>FROM</code> 子句中。</p><h6 id="示例：-7"><a href="#示例：-7" class="headerlink" title="示例："></a>示例：</h6><p>假设我们希望查询每个部门的平均工资，并按平均工资排序：</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_name, avg_salary</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> department_id, <span class="built_in">AVG</span>(salary) <span class="keyword">AS</span> avg_salary</span><br><span class="line">      <span class="keyword">FROM</span> employees</span><br><span class="line">      <span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id) <span class="keyword">AS</span> dept_avg</span><br><span class="line"><span class="keyword">JOIN</span> departments <span class="keyword">ON</span> dept_avg.department_id <span class="operator">=</span> departments.department_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> avg_salary <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></div><h4 id="3-子查询的位置"><a href="#3-子查询的位置" class="headerlink" title="3. 子查询的位置"></a>3. 子查询的位置</h4><p>子查询可以出现在以下位置：</p><h5 id="3-1-SELECT-子句"><a href="#3-1-SELECT-子句" class="headerlink" title="3.1 SELECT 子句"></a>3.1 <code>SELECT</code> 子句</h5><p>子查询可以出现在 <code>SELECT</code> 子句中，用于计算每个行的特定值。</p><h6 id="示例：-8"><a href="#示例：-8" class="headerlink" title="示例："></a>示例：</h6><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_name,</span><br><span class="line">       salary,</span><br><span class="line">       (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">FROM</span> employees) <span class="keyword">AS</span> avg_salary</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure></div><h5 id="3-2-FROM-子句"><a href="#3-2-FROM-子句" class="headerlink" title="3.2 FROM 子句"></a>3.2 <code>FROM</code> 子句</h5><p>子查询可以出现在 <code>FROM</code> 子句中，用于生成一个临时表，供主查询使用。</p><h6 id="示例：-9"><a href="#示例：-9" class="headerlink" title="示例："></a>示例：</h6><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_name, avg_salary</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> department_id, <span class="built_in">AVG</span>(salary) <span class="keyword">AS</span> avg_salary</span><br><span class="line">      <span class="keyword">FROM</span> employees</span><br><span class="line">      <span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id) <span class="keyword">AS</span> dept_avg</span><br><span class="line"><span class="keyword">JOIN</span> departments <span class="keyword">ON</span> dept_avg.department_id <span class="operator">=</span> departments.department_id;</span><br></pre></td></tr></table></figure></div><h5 id="3-3-WHERE-子句"><a href="#3-3-WHERE-子句" class="headerlink" title="3.3 WHERE 子句"></a>3.3 <code>WHERE</code> 子句</h5><p>子查询可以出现在 <code>WHERE</code> 子句中，用于过滤数据。</p><h6 id="示例：-10"><a href="#示例：-10" class="headerlink" title="示例："></a>示例：</h6><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_name, salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">FROM</span> employees);</span><br></pre></td></tr></table></figure></div><h5 id="3-4-HAVING-子句"><a href="#3-4-HAVING-子句" class="headerlink" title="3.4 HAVING 子句"></a>3.4 <code>HAVING</code> 子句</h5><p>子查询可以出现在 <code>HAVING</code> 子句中，用于过滤分组后的数据。</p><h6 id="示例：-11"><a href="#示例：-11" class="headerlink" title="示例："></a>示例：</h6><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id, <span class="built_in">AVG</span>(salary) <span class="keyword">AS</span> avg_salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">AVG</span>(salary) <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">FROM</span> employees);</span><br></pre></td></tr></table></figure></div><h4 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4. 注意事项"></a>4. 注意事项</h4><ul><li><strong>性能问题</strong>：嵌套查询可能会影响性能，尤其是在处理大量数据时。可以考虑使用连接（Join）或其他优化方法来替代嵌套查询。</li><li><strong>相关子查询</strong>：相关子查询是指子查询依赖于外部查询的值。相关子查询通常会导致性能问题，因为它们会对外部查询的每一行执行一次子查询。</li></ul><h3 id="数据库控制语言DCL"><a href="#数据库控制语言DCL" class="headerlink" title="数据库控制语言DCL"></a>数据库控制语言DCL</h3><h4 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h4><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="operator">&lt;</span>username<span class="operator">&gt;</span> IDENTIFIED <span class="keyword">BY</span> <span class="operator">&lt;</span>password<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></div><p>也可以不带密码</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="operator">&lt;</span>username<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></div><h4 id="登录用户"><a href="#登录用户" class="headerlink" title="登录用户"></a>登录用户</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u &lt;username&gt; -p &lt;password&gt;</span><br></pre></td></tr></table></figure></div><h3 id="用户授权"><a href="#用户授权" class="headerlink" title="用户授权"></a>用户授权</h3><h4 id="1-GRANT"><a href="#1-GRANT" class="headerlink" title="1. GRANT"></a>1. <code>GRANT</code></h4><p><code>GRANT</code> 命令用于授予用户或角色对数据库对象（如表、视图、存储过程等）的访问权限。</p><h5 id="语法：-3"><a href="#语法：-3" class="headerlink" title="语法："></a>语法：</h5><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> privileges <span class="keyword">ON</span> object <span class="keyword">TO</span> user_or_role;</span><br></pre></td></tr></table></figure></div><h5 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h5><ul><li><code>privileges</code>：要授予的权限，可以是 <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, <code>ALL PRIVILEGES</code> 等。</li><li><code>object</code>：要授予权限的数据库对象，如表、视图、存储过程等。</li><li><code>user_or_role</code>：要授予权限的用户或角色。</li></ul><h5 id="示例：-12"><a href="#示例：-12" class="headerlink" title="示例："></a>示例：</h5><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 授予用户 &#x27;alice&#x27; 对表 &#x27;employees&#x27; 的 SELECT 权限</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> employees <span class="keyword">TO</span> alice;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 授予用户 &#x27;bob&#x27; 对表 &#x27;employees&#x27; 的所有权限</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> employees <span class="keyword">TO</span> bob;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 授予角色 &#x27;developers&#x27; 对数据库 &#x27;mydb&#x27; 的所有权限</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> DATABASE mydb <span class="keyword">TO</span> developers;</span><br></pre></td></tr></table></figure></div><h4 id="2-REVOKE"><a href="#2-REVOKE" class="headerlink" title="2. REVOKE"></a>2. <code>REVOKE</code></h4><p><code>REVOKE</code> 命令用于撤销用户或角色对数据库对象的访问权限。</p><h5 id="语法：-4"><a href="#语法：-4" class="headerlink" title="语法："></a>语法：</h5><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> privileges <span class="keyword">ON</span> object <span class="keyword">FROM</span> user_or_role;</span><br></pre></td></tr></table></figure></div><h5 id="参数说明：-1"><a href="#参数说明：-1" class="headerlink" title="参数说明："></a>参数说明：</h5><ul><li>**<code>privileges</code>**：要撤销的权限，可以是 <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, <code>ALL PRIVILEGES</code> 等。</li><li>**<code>object</code>**：要撤销权限的数据库对象，如表、视图、存储过程等。</li><li>**<code>user_or_role</code>**：要撤销权限的用户或角色。</li></ul><h5 id="示例：-13"><a href="#示例：-13" class="headerlink" title="示例："></a>示例：</h5><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 撤销用户 &#x27;alice&#x27; 对表 &#x27;employees&#x27; 的 SELECT 权限</span></span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> employees <span class="keyword">FROM</span> alice;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 撤销用户 &#x27;bob&#x27; 对表 &#x27;employees&#x27; 的所有权限</span></span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> employees <span class="keyword">FROM</span> bob;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 撤销角色 &#x27;developers&#x27; 对数据库 &#x27;mydb&#x27; 的所有权限</span></span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> DATABASE mydb <span class="keyword">FROM</span> developers;</span><br></pre></td></tr></table></figure></div><h4 id="3-DENY"><a href="#3-DENY" class="headerlink" title="3. DENY"></a>3. <code>DENY</code></h4><p><code>DENY</code> 命令用于显式拒绝用户或角色对数据库对象的访问权限。与 <code>REVOKE</code> 不同，<code>DENY</code> 会阻止用户通过角色或其他方式继承权限。</p><h5 id="语法：-5"><a href="#语法：-5" class="headerlink" title="语法："></a>语法：</h5><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DENY privileges <span class="keyword">ON</span> object <span class="keyword">TO</span> user_or_role;</span><br></pre></td></tr></table></figure></div><h5 id="参数说明：-2"><a href="#参数说明：-2" class="headerlink" title="参数说明："></a>参数说明：</h5><ul><li>**<code>privileges</code>**：要拒绝的权限，可以是 <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, <code>ALL PRIVILEGES</code> 等。</li><li>**<code>object</code>**：要拒绝权限的数据库对象，如表、视图、存储过程等。</li><li>**<code>user_or_role</code>**：要拒绝权限的用户或角色。</li></ul><h5 id="示例：-14"><a href="#示例：-14" class="headerlink" title="示例："></a>示例：</h5><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 拒绝用户 &#x27;alice&#x27; 对表 &#x27;employees&#x27; 的 SELECT 权限</span></span><br><span class="line">DENY <span class="keyword">SELECT</span> <span class="keyword">ON</span> employees <span class="keyword">TO</span> alice;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 拒绝用户 &#x27;bob&#x27; 对表 &#x27;employees&#x27; 的所有权限</span></span><br><span class="line">DENY <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> employees <span class="keyword">TO</span> bob;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 拒绝角色 &#x27;developers&#x27; 对数据库 &#x27;mydb&#x27; 的所有权限</span></span><br><span class="line">DENY <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> DATABASE mydb <span class="keyword">TO</span> developers;</span><br></pre></td></tr></table></figure></div><h4 id="4-CREATE-ROLE-和-DROP-ROLE"><a href="#4-CREATE-ROLE-和-DROP-ROLE" class="headerlink" title="4. CREATE ROLE 和 DROP ROLE"></a>4. <code>CREATE ROLE</code> 和 <code>DROP ROLE</code></h4><p><code>CREATE ROLE</code> 和 <code>DROP ROLE</code> 命令用于创建和删除角色。角色是一组权限的集合，可以授予用户或其他角色。</p><h5 id="语法：-6"><a href="#语法：-6" class="headerlink" title="语法："></a>语法：</h5><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> ROLE role_name;</span><br><span class="line"><span class="keyword">DROP</span> ROLE role_name;</span><br></pre></td></tr></table></figure></div><h5 id="示例：-15"><a href="#示例：-15" class="headerlink" title="示例："></a>示例：</h5><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建一个名为 &#x27;developers&#x27; 的角色</span></span><br><span class="line"><span class="keyword">CREATE</span> ROLE developers;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除名为 &#x27;developers&#x27; 的角色</span></span><br><span class="line"><span class="keyword">DROP</span> ROLE developers;</span><br></pre></td></tr></table></figure></div><h4 id="5-ALTER-ROLE"><a href="#5-ALTER-ROLE" class="headerlink" title="5. ALTER ROLE"></a>5. <code>ALTER ROLE</code></h4><p><code>ALTER ROLE</code> 命令用于修改角色的属性，如重命名角色、修改角色的默认配置等。</p><h5 id="语法：-7"><a href="#语法：-7" class="headerlink" title="语法："></a>语法：</h5><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> ROLE role_name <span class="keyword">WITH</span> options;</span><br></pre></td></tr></table></figure></div><h5 id="示例：-16"><a href="#示例：-16" class="headerlink" title="示例："></a>示例：</h5><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 重命名角色 &#x27;developers&#x27; 为 &#x27;devs&#x27;</span></span><br><span class="line"><span class="keyword">ALTER</span> ROLE developers RENAME <span class="keyword">TO</span> devs;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改角色 &#x27;devs&#x27; 的默认配置</span></span><br><span class="line"><span class="keyword">ALTER</span> ROLE devs <span class="keyword">WITH</span> LOGIN;</span><br></pre></td></tr></table></figure></div><h4 id="6-SET-ROLE"><a href="#6-SET-ROLE" class="headerlink" title="6. SET ROLE"></a>6. <code>SET ROLE</code></h4><p><code>SET ROLE</code> 命令用于在当前会话中切换角色。</p><h5 id="语法：-8"><a href="#语法：-8" class="headerlink" title="语法："></a>语法：</h5><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> ROLE role_name;</span><br></pre></td></tr></table></figure></div><h5 id="示例：-17"><a href="#示例：-17" class="headerlink" title="示例："></a>示例：</h5><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在当前会话中切换到角色 &#x27;developers&#x27;</span></span><br><span class="line"><span class="keyword">SET</span> ROLE developers;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据库定义语言-DDL&quot;&gt;&lt;a href=&quot;#数据库定义语言-DDL&quot; class=&quot;headerlink&quot; title=&quot;数据库定义语言(DDL)&quot;&gt;&lt;/a&gt;数据库定义语言(DDL)&lt;/h2&gt;&lt;h3 id=&quot;创建数据库&quot;&gt;&lt;a href=&quot;#创建数据库&quot; cla</summary>
      
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库设计规范</title>
    <link href="http://example.com/2024/09/15/DataBaseDesign/"/>
    <id>http://example.com/2024/09/15/DataBaseDesign/</id>
    <published>2024-09-15T07:47:19.000Z</published>
    <updated>2024-11-08T02:21:34.889Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库范式"><a href="#数据库范式" class="headerlink" title="数据库范式"></a>数据库范式</h2><p>数据库范式是一套用于设计关系数据库的规范化标准，其目的是减少数据冗余并提高数据的完整性和一致性。范式化是一种将数据库表设计成符合一定级别的过程，每个级别称为一个范式。通过范式化，可以减少数据存储中的冗余，同时避免潜在的数据不一致问题。</p><p>数据库范式通常分为六个级别，其中最常用的是前三范式（1NF、2NF、3NF）：</p><h3 id="1-第一范式-1NF"><a href="#1-第一范式-1NF" class="headerlink" title="1. 第一范式 (1NF)"></a>1. 第一范式 (1NF)</h3><p>   第一范式要求表中的每一列都是不可分割的原子值，即每个单元格中只包含一个值。这确保了表中的每一列都是单一的事实，而不是列表或集合。例如，如果有一个“联系方式”列包含了电话号码和电子邮件地址，则这样的设计就不符合第一范式。</p><h4 id="不符合1NF的例子："><a href="#不符合1NF的例子：" class="headerlink" title="不符合1NF的例子："></a>不符合1NF的例子：</h4><p>假设我们有一个<code>学生</code>表，记录学生的姓名和他们所选的课程：</p><table><thead><tr><th>学号</th><th>姓名</th><th>课程</th></tr></thead><tbody><tr><td>S001</td><td>张三</td><td>数学, 物理</td></tr><tr><td>S002</td><td>李四</td><td>英语</td></tr></tbody></table><p>这个表不是1NF，因为“课程”这一列包含了多个值（数学和物理），而1NF要求每一列都应该是原子的，即不可再分。</p><h4 id="符合1NF的例子："><a href="#符合1NF的例子：" class="headerlink" title="符合1NF的例子："></a>符合1NF的例子：</h4><p>为了使上述表符合1NF，我们可以将其拆分成两个表：</p><ul><li><strong>学生表</strong>：</li></ul><table><thead><tr><th>学号</th><th>姓名</th></tr></thead><tbody><tr><td>S001</td><td>张三</td></tr><tr><td>S002</td><td>李四</td></tr></tbody></table><ul><li><strong>选课表</strong>：</li></ul><table><thead><tr><th>学号</th><th>课程</th></tr></thead><tbody><tr><td>S001</td><td>数学</td></tr><tr><td>S001</td><td>物理</td></tr><tr><td>S002</td><td>英语</td></tr></tbody></table><h3 id="2-第二范式-2NF"><a href="#2-第二范式-2NF" class="headerlink" title="2. 第二范式 (2NF)"></a>2. 第二范式 (2NF)</h3><p>   第二范式建立在第一范式的基础上，要求所有的非主键字段完全依赖于主键。这意味着表中的非主键字段不能部分依赖于主键的一部分。例如，如果主键是一个复合键，那么所有非主键字段都必须依赖于整个复合键，而不仅仅是部分主键。</p><h4 id="不符合2NF的例子："><a href="#不符合2NF的例子：" class="headerlink" title="不符合2NF的例子："></a>不符合2NF的例子：</h4><p>假设我们有一个<code>员工</code>表，记录员工的基本信息以及部门信息：</p><table><thead><tr><th>员工ID</th><th>名字</th><th>部门名称</th><th>部门地址</th></tr></thead><tbody><tr><td>E001</td><td>王五</td><td>销售</td><td>北京</td></tr><tr><td>E002</td><td>赵六</td><td>技术</td><td>上海</td></tr></tbody></table><p>这里的问题在于，部门名称和部门地址是依赖于部门的，而不是单独依赖于员工ID。如果部门信息发生变化，就需要在每个员工记录中更新，这样容易导致数据不一致。</p><h4 id="符合2NF的例子："><a href="#符合2NF的例子：" class="headerlink" title="符合2NF的例子："></a>符合2NF的例子：</h4><p>为了使上述表符合2NF，我们需要将部门信息提取出来：</p><ul><li><strong>员工表</strong>：</li></ul><table><thead><tr><th>员工ID</th><th>名字</th><th>部门ID</th></tr></thead><tbody><tr><td>E001</td><td>王五</td><td>D001</td></tr><tr><td>E002</td><td>赵六</td><td>D002</td></tr></tbody></table><ul><li><strong>部门表</strong>：</li></ul><table><thead><tr><th>部门ID</th><th>部门名称</th><th>部门地址</th></tr></thead><tbody><tr><td>D001</td><td>销售</td><td>北京</td></tr><tr><td>D002</td><td>技术</td><td>上海</td></tr></tbody></table><h3 id="3-第三范式-3NF"><a href="#3-第三范式-3NF" class="headerlink" title="3. 第三范式 (3NF)"></a>3. 第三范式 (3NF)</h3><p>   第三范式进一步加强了第二范式的要求，它要求所有非主键字段直接依赖于主键，而不是通过另一个非主键字段间接依赖于主键（即避免传递依赖）。例如，如果存在一个表，其中一个非主键字段依赖于另一个非主键字段，那么就需要将它们分离到不同的表中。</p><h4 id="不符合3NF的例子："><a href="#不符合3NF的例子：" class="headerlink" title="不符合3NF的例子："></a>不符合3NF的例子：</h4><p>考虑以下一个学生-课程-教师的示例：</p><table><thead><tr><th>学号</th><th>课程编号</th><th>教师编号</th><th>教师姓名</th></tr></thead><tbody><tr><td>S001</td><td>C001</td><td>T001</td><td>刘老师</td></tr><tr><td>S002</td><td>C002</td><td>T002</td><td>陈老师</td></tr></tbody></table><p>在这个表中，教师姓名直接与学生关联，而没有直接依赖于主键（学号），而是依赖于教师编号。这是一个传递依赖的例子，因此不符合3NF。</p><h4 id="符合3NF的例子："><a href="#符合3NF的例子：" class="headerlink" title="符合3NF的例子："></a>符合3NF的例子：</h4><p>为了使上述表符合3NF，我们需要创建一个新的教师表：</p><ul><li><strong>学生表</strong>：</li></ul><table><thead><tr><th>学号</th><th>课程编号</th><th>教师编号</th></tr></thead><tbody><tr><td>S001</td><td>C001</td><td>T001</td></tr><tr><td>S002</td><td>C002</td><td>T002</td></tr></tbody></table><ul><li><strong>教师表</strong>：</li></ul><table><thead><tr><th>教师编号</th><th>教师姓名</th></tr></thead><tbody><tr><td>T001</td><td>刘老师</td></tr><tr><td>T002</td><td>陈老师</td></tr></tbody></table><p>除了这三个主要的范式之外，还有更高层次的范式：</p><h3 id="4-BCNF-Boys-Codd范式"><a href="#4-BCNF-Boys-Codd范式" class="headerlink" title="4. BCNF (Boys-Codd范式)"></a>4. BCNF (Boys-Codd范式)</h3><p>   BCNF范式要求每个决定因素都是一个超键。这意味着除了主键之外，没有任何其他字段可以决定任何非键字段。</p><h4 id="不符合BCNF的例子："><a href="#不符合BCNF的例子：" class="headerlink" title="不符合BCNF的例子："></a>不符合BCNF的例子：</h4><p>假设我们有一个<code>图书作者</code>表，记录书籍的信息以及作者的信息：</p><table><thead><tr><th>图书ID</th><th>书名</th><th>作者ID</th><th>作者名</th><th>作者国籍</th></tr></thead><tbody><tr><td>B001</td><td>梦幻森林</td><td>A001</td><td>小明</td><td>中国</td></tr><tr><td>B002</td><td>星际旅行</td><td>A002</td><td>小红</td><td>美国</td></tr><tr><td>B003</td><td>梦幻森林</td><td>A001</td><td>小明</td><td>中国</td></tr></tbody></table><p>在这个表中，<code>作者名</code>和<code>作者国籍</code>依赖于<code>作者ID</code>，而不是直接依赖于<code>图书ID</code>。此外，如果我们只改变某本书的作者信息，那么所有包含该作者的记录都需要更新。这表明存在部分依赖（<code>作者名</code>和<code>作者国籍</code>依赖于<code>作者ID</code>）和传递依赖（<code>作者国籍</code>依赖于<code>作者ID</code>），这使得该表不符合BCNF的要求。</p><h4 id="符合BCNF的例子："><a href="#符合BCNF的例子：" class="headerlink" title="符合BCNF的例子："></a>符合BCNF的例子：</h4><p>为了使上述表符合BCNF，我们需要将作者信息分离到另一个表中：</p><ul><li><strong>图书表</strong>：</li></ul><table><thead><tr><th>图书ID</th><th>书名</th><th>作者ID</th></tr></thead><tbody><tr><td>B001</td><td>梦幻森林</td><td>A001</td></tr><tr><td>B002</td><td>星际旅行</td><td>A002</td></tr><tr><td>B003</td><td>梦幻森林</td><td>A001</td></tr></tbody></table><ul><li><strong>作者表</strong>：</li></ul><table><thead><tr><th>作者ID</th><th>作者名</th><th>作者国籍</th></tr></thead><tbody><tr><td>A001</td><td>小明</td><td>中国</td></tr><tr><td>A002</td><td>小红</td><td>美国</td></tr></tbody></table><p>现在，<code>图书表</code>中的每一项都是基于<code>图书ID</code>和<code>作者ID</code>这两个组合键，而<code>作者表</code>中的每一项都是基于<code>作者ID</code>。在这种情况下，没有任何非平凡函数依赖涉及非候选键的情况，因此这两个表都符合BCNF的要求。</p><h3 id="5-第四范式-4NF"><a href="#5-第四范式-4NF" class="headerlink" title="5. 第四范式 (4NF)"></a>5. 第四范式 (4NF)</h3><p>   第四范式是在BCNF的基础上进一步消除非平凡的多值依赖。</p><h3 id="6-第五范式-5NF-："><a href="#6-第五范式-5NF-：" class="headerlink" title="6. 第五范式 (5NF)："></a>6. 第五范式 (5NF)：</h3><p>   第五范式，也被称为完美范式或PJ范式，关注的是关系模式在连接操作后的数据一致性。</p><p>范式化的过程通常涉及到将数据分解成多个相互关联的表，以确保每个表都有一个明确的主题或目的，并且表中的每个字段都直接依赖于主键。虽然遵循范式可以带来许多好处，但在实际应用中，有时候为了提高查询性能或其他原因，可能会选择不完全遵循这些范式，而是采用一定程度的反范式化（denormalization）。</p><h2 id="关于键"><a href="#关于键" class="headerlink" title="关于键:"></a>关于键:</h2><ul><li>超键(super key): 在关系中能唯一标识元组的属性集称为关系模式的超键<br>只要含有“学号”或者“身份证号”两个属性的集合就叫超键，例如R1（学号 性别）、R2（身份证号 身高）、R3（学号 身份证号）等等都可以称为超键！</li><li>候选键(candidate key): 不含有多余属性的超键称为候选键。也就是在候选键中，若再删除属性，就不是键了！<br>不含有多余的属性的超键，比如（学号）、（身份证号）都是候选键，又比如R1中学号这一个属性就可以唯一标识元组了，而有没有性别这一属性对是否唯一标识元组没有任何的影响！</li><li>主键(primary key): 用户选作元组标识的一个候选键程序主键<br>就是用户从很多候选键选出来的一个键就是主键，比如你要求学号是主键，那么身份证号就不可以是主键了</li><li>外键(foreign key)：如果关系模式R中属性K是其它模式的主键，那么k在模式R中称为外键。<br> 宿舍号就是学生信息表的外键</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据库范式&quot;&gt;&lt;a href=&quot;#数据库范式&quot; class=&quot;headerlink&quot; title=&quot;数据库范式&quot;&gt;&lt;/a&gt;数据库范式&lt;/h2&gt;&lt;p&gt;数据库范式是一套用于设计关系数据库的规范化标准，其目的是减少数据冗余并提高数据的完整性和一致性。范式化是一种将数据库</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>QT信号和槽</title>
    <link href="http://example.com/2024/08/27/QT-Signal/"/>
    <id>http://example.com/2024/08/27/QT-Signal/</id>
    <published>2024-08-27T02:23:12.000Z</published>
    <updated>2024-11-08T02:21:34.889Z</updated>
    
    <content type="html"><![CDATA[<h2 id="信号和槽"><a href="#信号和槽" class="headerlink" title="信号和槽"></a>信号和槽</h2><p>当我们需要一个界面通知另一个界面时，可以采用信号和槽机制。通过链接信号和槽，当一个界面发送信号时，链接该信号的槽会被响应，从而达到消息传递的目的。</p><p>我们先创建两个界面并为两个界面添加一个按钮，通过按钮的点击来实现界面的切换</p><p>主界面</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2024/08/27/TqclI9soy68uCfh.png"                      alt="mainpage.png"                ></p><p>先实现主界面的点击按钮功能，并在终端打印一条信息”show child dialog”<br>现在MainWindow的构造函数中添加信号和槽的逻辑连接</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(ui-&gt;showChildButton, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">showChildDialog</span>()));</span><br></pre></td></tr></table></figure></div><p>然后在MainWindow的头文件中添加槽函数，槽函数需要<code>slots</code>声明</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showChildDialog</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></div><p>接下来实现该函数</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::showChildDialog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;show child dialog&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>子界面<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2024/08/27/TlR6VLyQp5HhzvN.png"                      alt="subpage.png"                ></p><h2 id="不同的连接方式"><a href="#不同的连接方式" class="headerlink" title="不同的连接方式"></a>不同的连接方式</h2><p>上面我们使用的是qt4的连接方式，用SIGNAL和SLOT将信号和槽转化为字符串。但是这种方式存在一个问题，qt要求槽函数的参数不能超过信号定义的参数，比如我们用到的信号clicked(bool)参数就是bool，我们定义的槽函数showChildDialog()参数是不带参数的，可以连接成功，如果我们在连接的时候将showChildDialog()的参数写成三个，也可以连接成功</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// qt4 style 连接信号和槽</span></span><br><span class="line"><span class="built_in">connect</span>(ui-&gt;showChildButton, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>(<span class="type">bool</span>)), <span class="built_in">SLOT</span>(<span class="built_in">showChildDialog</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)));</span><br></pre></td></tr></table></figure></div><p>但是点击会没有反应，说明qt4 这种连接信号和槽的方式不做编译检查，只是将信号和槽函数转译成字符串。</p><p>推荐qt5的连接方式</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(_child_dialog, &amp;ChildDialog::showMainSig, <span class="keyword">this</span>, &amp;MainWindow::showMainDialog);</span><br><span class="line"><span class="built_in">connect</span>(_child_dialog, &amp;ChildDialog::showMainSig, <span class="keyword">this</span>, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_child_dialog-&gt;<span class="built_in">hide</span>();</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div><h2 id="实现界面切换"><a href="#实现界面切换" class="headerlink" title="实现界面切换"></a>实现界面切换</h2><p>在MainWindow类中，加入一个子界面类的指针，方便访问</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showChildDialog</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showMainDialog</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">    ChildDialog *_child_dialog;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p>然后改写槽函数，当单击按钮时弹出对话框</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::showChildDialog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _child_dialog-&gt;<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">hide</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这么做有一个问题就是可能会重复创建子窗口，但是Qt的对象树机制会保证父窗口回收时才回收子窗口，所以关闭子窗口只是隐藏了。<br>那么随着点击，久而久之窗口会越来越多。<br>我们想到的一个避免重复创建的办法就是在MainWindow的构造函数里创建好子界面，在槽函数中只控制子界面的显示即可。<br>但同时要注意在MainWindow的析构函数里回收子界面类对象。</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    _child_dialog = <span class="keyword">new</span> <span class="built_in">ChildDialog</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// qt4 style 连接信号和槽</span></span><br><span class="line">    <span class="comment">// connect(ui-&gt;showChildButton, SIGNAL(clicked(bool)), SLOT(showChildDialog()));</span></span><br><span class="line">    <span class="comment">// qt5 style(recommend)</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;showChildButton, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;MainWindow::showChildDialog);</span><br><span class="line">    <span class="comment">// connect(_child_dialog, &amp;ChildDialog::showMainSig, this, &amp;MainWindow::showMainDialog);</span></span><br><span class="line">    <span class="built_in">connect</span>(_child_dialog, &amp;ChildDialog::showMainSig, <span class="keyword">this</span>, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_child_dialog-&gt;<span class="built_in">hide</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">show</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">    <span class="keyword">if</span> (_child_dialog != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> _child_dialog;</span><br><span class="line">        _child_dialog = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这样我们频繁点击显示子界面按钮就不会重复创建窗口了。<br>那接下来实现点击主界面的按钮，显示子界面，并隐藏主窗口。<br>实现点击子界面的按钮，显示主窗口，并隐藏子界面。<br>先实现点击子界面按钮显示主窗口，我们可以在ChildDialog类修改下构造函数，使其接受一个QWidget指针，这个指针指向父窗口也就是MainWindow.<br>我们新增成员_parent用来存储MainWindow。<br>新增槽函数showMainWindow用来显示主窗口。</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ChildDialog</span> : <span class="keyword">public</span> QDialog</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showMainSig</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ChildDialog</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    ~<span class="built_in">ChildDialog</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showMainWindow</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::ChildDialog *ui;</span><br><span class="line">    QWidget *_parent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p>实现槽函数</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChildDialog::showMainWindow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">hide</span>();</span><br><span class="line">    <span class="function">emit <span class="title">showMainSig</span><span class="params">()</span></span>; <span class="comment">//发出信号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>在MainWindow连接这个信号</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    _child_dialog = <span class="keyword">new</span> <span class="built_in">ChildDialog</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// qt4 style 连接信号和槽</span></span><br><span class="line">    <span class="comment">// connect(ui-&gt;showChildButton, SIGNAL(clicked(bool)), SLOT(showChildDialog()));</span></span><br><span class="line">    <span class="comment">// qt5 style(recommend)</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;showChildButton, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;MainWindow::showChildDialog);</span><br><span class="line">    <span class="comment">// connect(_child_dialog, &amp;ChildDialog::showMainSig, this, &amp;MainWindow::showMainDialog);</span></span><br><span class="line">    <span class="built_in">connect</span>(_child_dialog, &amp;ChildDialog::showMainSig, <span class="keyword">this</span>, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_child_dialog-&gt;<span class="built_in">hide</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">show</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="连接信号"><a href="#连接信号" class="headerlink" title="连接信号"></a>连接信号</h3><p>上面的程序还可以进一步优化，因为Qt提供了信号连接信号的方式，也就是说我们可以把子界面的按钮点击信号和showMainSig信号连接起来。</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ChildDialog::<span class="built_in">ChildDialog</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QDialog</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::ChildDialog)</span><br><span class="line">    , _parent(parent)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;showMainWindow, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;ChildDialog::showMainSig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>将clicked和showMainSig两个信号连接起来，也可以实现消息的传递。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;信号和槽&quot;&gt;&lt;a href=&quot;#信号和槽&quot; class=&quot;headerlink&quot; title=&quot;信号和槽&quot;&gt;&lt;/a&gt;信号和槽&lt;/h2&gt;&lt;p&gt;当我们需要一个界面通知另一个界面时，可以采用信号和槽机制。通过链接信号和槽，当一个界面发送信号时，链接该信号的槽会被响应，从</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="C/C++" scheme="http://example.com/tags/C-C/"/>
    
    <category term="QT" scheme="http://example.com/tags/QT/"/>
    
  </entry>
  
  <entry>
    <title>asio-IOServicePool</title>
    <link href="http://example.com/2024/08/24/asio-IOServicePool/"/>
    <id>http://example.com/2024/08/24/asio-IOServicePool/</id>
    <published>2024-08-24T14:51:44.000Z</published>
    <updated>2024-11-08T02:21:34.890Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>IOServicePool</code>是一个用于管理多个<code>io_context</code>实例的多线程模型，每一个线程管理一个<code>io_context</code>，它的主要目的是在多线程环境中高效地分发和异步处理I&#x2F;O操作</p><h2 id="单线程和多线程对比"><a href="#单线程和多线程对比" class="headerlink" title="单线程和多线程对比"></a>单线程和多线程对比</h2><p>单线程模式图<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2024/08/24/1Kw5yAiT2DrJg3l.png"                      alt="单线程模型.png"                ></p><p>多线程模式图<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2024/08/24/j9vaAPC8WMzpce3.png"                      alt="IOServicePool.png"                ></p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li><p>每一个<code>io_context</code>跑在不同的线程里，所以同一个<code>socket</code>会被注册在同一个<code>io_context</code>里，它的回调函数也会被单独的一个线程回调，那么对于同一个<code>socket</code>，他的回调函数每次触发都是在同一个线程里，就不会有线程安全问题，网络io层面上的并发是线程安全的。</p></li><li><p>但是对于不同的<code>socket</code>，回调函数的触发可能是同一个线程(两个<code>socket</code>被分配到同一个<code>io_context</code>)，也可能不是同一个线程(两个<code>socket</code>被分配到不同的<code>io_context</code>里)。所以如果两个<code>socket</code>对应的上层逻辑处理，如果有交互或者访问共享区，会存在线程安全问题。比如<code>socket1</code>代表玩家1，<code>socket2</code>代表玩家2，玩家1和玩家2在逻辑层存在交互，比如两个玩家都在做工会任务，他们属于同一个工会，工会积分的增加就是共享区的数据，需要保证线程安全。可以通过加锁或者逻辑队列的方式解决安全问题，我们目前采取了后者。</p></li><li><p>多线程相比单线程，极大的提高了并发能力，因为单线程仅有一个<code>io_context</code>服务用来监听读写事件，就绪后回调函数在一个线程里串行调用, 如果一个回调函数的调用时间较长肯定会影响后续的函数调用，毕竟是穿行调用。而采用多线程方式，可以在一定程度上减少前一个逻辑调用影响下一个调用的情况，比如两个<code>socket</code>被部署到不同的<code>iocontext</code>上，但是当两个<code>socket</code>部署到同一个<code>iocontext</code>上时仍然存在调用时间影响的问题。不过我们已经通过逻辑队列的方式将网络线程和逻辑线程解耦合了，不会出现前一个调用时间影响下一个回调触发的问题。</p></li></ol><h2 id="IOServicePool实现"><a href="#IOServicePool实现" class="headerlink" title="IOServicePool实现"></a>IOServicePool实现</h2><p>IOServicePool本质上是一个线程池，基本功能就是根据构造函数传入的数量创建n个线程和iocontext，然后每个线程跑一个iocontext，这样就可以并发处理不同iocontext读写事件了。<br>声明如下：</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span></span></span><br><span class="line"><span class="comment">// 如果要使用这个线程池的话，</span></span><br><span class="line"><span class="comment">// 将CServer的io_context替换为AsioIOServicePool::GetInstance()-&gt;get_io_service()</span></span><br><span class="line"><span class="comment">// main函数需要给服务器创建一个io_context</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Singleton.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AsioIOServicePool</span> : <span class="keyword">public</span> Singleton&lt;AsioIOServicePool&gt; &#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&lt;AsioIOServicePool&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> IOService = boost::asio::io_context;</span><br><span class="line">    <span class="keyword">using</span> Work      = boost::asio::io_context::work;</span><br><span class="line">    <span class="keyword">using</span> WorkPtr   = std::unique_ptr&lt;Work&gt;;</span><br><span class="line">    ~<span class="built_in">AsioIOServicePool</span>();</span><br><span class="line">    <span class="built_in">AsioIOServicePool</span>( <span class="type">const</span> AsioIOServicePool &amp; )            = <span class="keyword">delete</span>;</span><br><span class="line">    AsioIOServicePool &amp;<span class="keyword">operator</span>=( <span class="type">const</span> AsioIOServicePool &amp; ) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    boost::<span class="function">asio::io_context &amp;<span class="title">get_io_service</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">AsioIOServicePool</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">size_t</span> thread_size = std::thread::hardware_concurrency() )</span></span>;</span><br><span class="line">    std::vector&lt;IOService&gt; _ioServices;</span><br><span class="line">    std::vector&lt;WorkPtr&gt; _works;</span><br><span class="line">    std::vector&lt;std::thread&gt; _threads;</span><br><span class="line">    std::<span class="type">size_t</span> _nextIOservice; <span class="comment">// 轮询索引</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>实现如下：</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">AsioIOServicePool::<span class="built_in">AsioIOServicePool</span>(<span class="type">size_t</span> thread_size)</span><br><span class="line">    : _ioServices(thread_size), _works(thread_size), _nextIOservice(<span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; thread_size; ++i) &#123;</span><br><span class="line">        _works[i] = std::<span class="built_in">make_unique</span>&lt;Work&gt;(<span class="built_in">Work</span>(_ioServices[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;IOService : _ioServices) &#123;</span><br><span class="line">        _threads.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>, &amp;IOService]() &#123; IOService.<span class="built_in">run</span>(); &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boost::<span class="function">asio::io_context &amp;<span class="title">AsioIOServicePool::get_io_service</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;service = _ioServices[_nextIOservice++ % _ioServices.<span class="built_in">size</span>()];</span><br><span class="line">    <span class="keyword">return</span> service;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AsioIOServicePool::Stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;work : _works) &#123;</span><br><span class="line">        work.<span class="built_in">reset</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;t : _threads) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AsioIOServicePool::~<span class="built_in">AsioIOServicePool</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;AsioIOServicePool destroyed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>这段代码实现了一个基于 <code>boost::asio</code> 的 I&#x2F;O 服务池（<code>AsioIOServicePool</code>），并使用了单例模式（通过 <code>Singleton&lt;AsioIOServicePool&gt;</code>）来确保全局只有一个实例。以下是对代码的详细解释：</p><h4 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AsioIOServicePool</span> : <span class="keyword">public</span> Singleton&lt;AsioIOServicePool&gt; &#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&lt;AsioIOServicePool&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> IOService = boost::asio::io_context;</span><br><span class="line">    <span class="keyword">using</span> Work      = boost::asio::io_context::work;</span><br><span class="line">    <span class="keyword">using</span> WorkPtr   = std::unique_ptr&lt;Work&gt;;</span><br><span class="line">    ~<span class="built_in">AsioIOServicePool</span>();</span><br><span class="line">    <span class="built_in">AsioIOServicePool</span>( <span class="type">const</span> AsioIOServicePool &amp; )            = <span class="keyword">delete</span>;</span><br><span class="line">    AsioIOServicePool &amp;<span class="keyword">operator</span>=( <span class="type">const</span> AsioIOServicePool &amp; ) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    boost::<span class="function">asio::io_context &amp;<span class="title">get_io_service</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">AsioIOServicePool</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">size_t</span> thread_size = std::thread::hardware_concurrency() )</span></span>;</span><br><span class="line">    std::vector&lt;IOService&gt; _ioServices;</span><br><span class="line">    std::vector&lt;WorkPtr&gt; _works;</span><br><span class="line">    std::vector&lt;std::thread&gt; _threads;</span><br><span class="line">    std::<span class="type">size_t</span> _nextIOservice; <span class="comment">// 轮询索引</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><ul><li><code>AsioIOServicePool</code> 继承自 <code>Singleton&lt;AsioIOServicePool&gt;</code>，确保它是单例的。</li><li><code>friend class Singleton&lt;AsioIOServicePool&gt;;</code>：允许 <code>Singleton</code> 类访问 <code>AsioIOServicePool</code> 的私有成员。</li><li>使用 <code>using</code> 别名定义了 <code>IOService</code>、<code>Work</code> 和 <code>WorkPtr</code>。</li><li>删除了拷贝构造函数和赋值操作符，防止对象被复制。</li><li><code>get_io_service()</code> 方法用于获取一个 <code>io_context</code> 实例。</li><li><code>Stop()</code> 方法用于停止所有 <code>io_context</code> 并等待线程结束。</li><li>私有构造函数 <code>AsioIOServicePool</code> 接受一个线程数量参数，默认为硬件并发数。</li><li>成员变量包括 <code>_ioServices</code>（<code>io_context</code> 数组）、<code>_works</code>（工作对象数组）、<code>_threads</code>（线程数组）和 <code>_nextIOservice</code>（轮询索引）。</li></ul><h4 id="实现文件"><a href="#实现文件" class="headerlink" title="实现文件"></a>实现文件</h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">AsioIOServicePool::<span class="built_in">AsioIOServicePool</span>(<span class="type">size_t</span> thread_size)</span><br><span class="line">    : _ioServices(thread_size), _works(thread_size), _nextIOservice(<span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; thread_size; ++i) &#123;</span><br><span class="line">        _works[i] = std::<span class="built_in">make_unique</span>&lt;Work&gt;(<span class="built_in">Work</span>(_ioServices[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;IOService : _ioServices) &#123;</span><br><span class="line">        _threads.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>, &amp;IOService]() &#123; IOService.<span class="built_in">run</span>(); &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>构造函数初始化 <code>_ioServices</code>、<code>_works</code> 和 <code>_nextIOservice</code>。</li><li>为每个 <code>io_context</code> 创建一个 <code>Work</code> 对象，防止 <code>io_context</code> 在没有工作时退出。</li><li>为每个 <code>io_context</code> 创建一个线程，并在该线程中运行 <code>io_context</code>。</li></ul><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">boost::<span class="function">asio::io_context &amp;<span class="title">AsioIOServicePool::get_io_service</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;service = _ioServices[_nextIOservice++ % _ioServices.<span class="built_in">size</span>()];</span><br><span class="line">    <span class="keyword">return</span> service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li><code>get_io_service()</code> 方法通过轮询方式返回一个 <code>io_context</code> 实例。</li></ul><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AsioIOServicePool::Stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;work : _works) &#123;</span><br><span class="line">        work.<span class="built_in">reset</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;t : _threads) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li><code>Stop()</code> 方法重置所有 <code>Work</code> 对象，使 <code>io_context</code> 可以退出。</li><li>等待所有线程结束。</li></ul><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AsioIOServicePool::~<span class="built_in">AsioIOServicePool</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;AsioIOServicePool destroyed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>析构函数输出一条消息，表示对象被销毁。</li></ul><h3 id="关于优雅退出"><a href="#关于优雅退出" class="headerlink" title="关于优雅退出"></a>关于优雅退出</h3><p>IOServicePool多线程服务器退出时，需要捕获退出信号如<code>SIGINT</code>、<code>SIGTERM</code>等，然后通知所有线程退出，然后等待线程结束，将退出信号和一个<code>io_context</code>绑定，当接收到退出信号时，我们将IOServicePool中的<code>io_context</code>退出，然后等待所有线程退出，最后销毁线程池。</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> pool = AsioIOServicePool::<span class="built_in">GetInstance</span>();</span><br><span class="line">        boost::asio::io_context  io_context;</span><br><span class="line">        boost::<span class="function">asio::signal_set <span class="title">signals</span><span class="params">(io_context, SIGINT, SIGTERM)</span></span>;</span><br><span class="line">        signals.<span class="built_in">async_wait</span>([&amp;io_context,pool](<span class="keyword">auto</span>, <span class="keyword">auto</span>) &#123;</span><br><span class="line">            io_context.<span class="built_in">stop</span>();</span><br><span class="line">            pool-&gt;<span class="built_in">Stop</span>();</span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="function">CServer <span class="title">s</span><span class="params">(io_context, <span class="number">10086</span>)</span></span>;</span><br><span class="line">        io_context.<span class="built_in">run</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&lt;code&gt;IOServicePool&lt;/code&gt;是一个用于管理多个&lt;code&gt;io_context&lt;/code&gt;实例的多线程模型，每一个</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="C/C++" scheme="http://example.com/tags/C-C/"/>
    
    <category term="网络编程" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    <category term="socket" scheme="http://example.com/tags/socket/"/>
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>protobuf的配置和使用</title>
    <link href="http://example.com/2024/08/01/protobuf-configuration/"/>
    <id>http://example.com/2024/08/01/protobuf-configuration/</id>
    <published>2024-08-01T02:59:34.000Z</published>
    <updated>2024-11-08T02:21:34.892Z</updated>
    
    <content type="html"><![CDATA[<h1 id="protobuf简介"><a href="#protobuf简介" class="headerlink" title="protobuf简介"></a>protobuf简介</h1><p>Protocol Buffers（简称 protobuf）是 Google 开发的一种数据交换格式。它是一种灵活、高效且自动化的结构化数据序列化方法，类似于 XML、JSON 和其他配置文件格式，但更小、更快、更简单。我们的逻辑是有类等抽象数据构成的，而tcp是面向字节流的，我们需要将类结构序列化为字符串来传输。</p><p>主要特点：</p><ol><li>语言无关：protobuf 支持多种编程语言，包括 C++、Java、Python 等，并且可以轻松地在不同语言之间进行通信。</li><li>平台无关：可以跨多个平台使用，无论是在 32 位还是 64 位系统上。</li><li>效率高：相比于 XML 或 JSON，protobuf 在序列化和反序列化时的性能更好，生成的数据也更紧凑。</li></ol><h1 id="编译protobuf"><a href="#编译protobuf" class="headerlink" title="编译protobuf"></a>编译protobuf</h1><p>如果是linux系统，可以直接从自己的包管理器下载protobuf</p><p>例如<code>archlinux</code></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S protobuf</span><br></pre></td></tr></table></figure></div><p>如果是windows系统，我们需要从<a class="link"   href="https://github.com/protocolbuffers/protobuf/releases" >官网 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>下载源代码进行编译</p><p><a class="link"   href="https://blog.csdn.net/weixin_42968757/article/details/120033598" >具体教程 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>当protobuf编译完成后，我们可以通过<code>protobuf --version</code>来检查是否安装成功</p><h1 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h1><ul><li>定义消息格式：首先需要定义消息的结构，这通常是通过 .proto 文件完成的。这些文件描述了你想要交换的数据的结构。</li></ul><p>我们先创建一个<code>msg.proto</code>文件，并且写入如下内容</p><div class="highlight-container" data-rel="Proto"><figure class="iseeu highlight proto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">message </span><span class="title class_">Book</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">   <span class="type">int32</span> pages = <span class="number">2</span>;</span><br><span class="line">   <span class="type">float</span> price = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这个文件用来定义我们需要发送的信息</p><ul><li>编译 .proto 文件：使用 Protocol Buffers 编译器（protoc），根据 .proto 文件生成特定语言的源代码</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --cpp_out=. ./msg.proto</span><br></pre></td></tr></table></figure></div><p>.&#x2F;msg.proto 表示msg.proto所在的位置，因为我们是在msg.proto所在文件夹中执行的protoc命令,所以是当前路径即可。<br>执行后，会看到当前目录生成了msg.pb.h和msg.pb.cc两个文件，这两个文件就是我们要用到的头文件和cpp文件。</p><ul><li>序列化与反序列化：使用生成的类来创建消息对象，并将这些对象序列化为字节流，或者从字节流中反序列化为对象。</li></ul><p>这里我们写一个测试函数</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_protobuf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Book book;</span><br><span class="line">    book.<span class="built_in">set_name</span>(<span class="string">&quot;CPP programing&quot;</span>);</span><br><span class="line">    book.<span class="built_in">set_pages</span>(<span class="number">100</span>);</span><br><span class="line">    book.<span class="built_in">set_price</span>(<span class="number">200</span>);</span><br><span class="line">    std::string bookstr;</span><br><span class="line">    book.<span class="built_in">SerializeToString</span>(&amp;bookstr);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;serialize str is &quot;</span> &lt;&lt; bookstr &lt;&lt; std::endl;</span><br><span class="line">    Book book2;</span><br><span class="line">    book2.<span class="built_in">ParseFromString</span>(bookstr);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;book2 name is &quot;</span> &lt;&lt; book2.<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot; price is &quot;</span></span><br><span class="line">        &lt;&lt; book2.<span class="built_in">price</span>() &lt;&lt; <span class="string">&quot; pages is &quot;</span> &lt;&lt; book2.<span class="built_in">pages</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>输出如下：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">serialize str is</span><br><span class="line">CPP programingdHC</span><br><span class="line">book2 name is CPP programing price is 200 pages is 100</span><br></pre></td></tr></table></figure></div><p>上面的demo中将book对象先序列化为字符串，再将字符串反序列化为book2对象。</p><h1 id="在网络中的应用"><a href="#在网络中的应用" class="headerlink" title="在网络中的应用"></a>在网络中的应用</h1><p>先为服务器定义一个用来通信的protobuf</p><div class="highlight-container" data-rel="Proto"><figure class="iseeu highlight proto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">message </span><span class="title class_">MsgData</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int32</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="type">string</span> data = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>id代表消息的编号，data代表消息的内容</p><p>接着修改服务器接收和发送数据的逻辑<br>当服务器收到数据并完成切包处理，将信息反序列化为具体要使用的结构，打印相关信息，然后再发送给客户端</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Data msgdata;</span><br><span class="line">std::string receive_data;</span><br><span class="line">msgdata.<span class="built_in">ParseFromString</span>( std::<span class="built_in">string</span>(</span><br><span class="line">    _recv_msg_node-&gt;_msg, _recv_msg_node-&gt;_total_len ) );</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Recv msg is: &quot;</span> &lt;&lt; msgdata.<span class="built_in">data</span>() &lt;&lt; std::endl;</span><br><span class="line">std::string return_str =</span><br><span class="line">    <span class="string">&quot;server has receive msg, msg data is  &quot;</span> + msgdata.<span class="built_in">data</span>();</span><br><span class="line">Data msgreturn;</span><br><span class="line">msgreturn.<span class="built_in">set_id</span>( msgdata.<span class="built_in">id</span>() );</span><br><span class="line">msgreturn.<span class="built_in">set_data</span>( msgdata.<span class="built_in">data</span>() );</span><br><span class="line">msgreturn.<span class="built_in">SerializeToString</span>( &amp;return_str );</span><br><span class="line"><span class="built_in">Send</span>( return_str );</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>同样，客户端在发送的时候也利用protobu进行消息序列化，然后发送给服务器</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Data msgdata;</span><br><span class="line">msgdata.<span class="built_in">set_id</span>( <span class="number">1001</span> );</span><br><span class="line">msgdata.<span class="built_in">set_data</span>( <span class="string">&quot;Hello world!&quot;</span> );</span><br><span class="line">std::string request;</span><br><span class="line">msgdata.<span class="built_in">SerializeToString</span>( &amp;request );</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;message id: &quot;</span> &lt;&lt; msgdata.<span class="built_in">id</span>()</span><br><span class="line">          &lt;&lt; <span class="string">&quot; content: &quot;</span> &lt;&lt; msgdata.<span class="built_in">data</span>() &lt;&lt; std::endl;</span><br><span class="line">boost::asio::<span class="built_in">write</span>(</span><br><span class="line">    sock, boost::asio::<span class="built_in">buffer</span>( request, request.<span class="built_in">length</span>() ) );</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h1 id="关于protbuf在CMake中的配置"><a href="#关于protbuf在CMake中的配置" class="headerlink" title="关于protbuf在CMake中的配置"></a>关于protbuf在CMake中的配置</h1><blockquote><p>注意一定要在编译参数中加入<code>-Wl,--copy-dt-needed-entries</code>，否则会报<a class="link"   href="https://linuxpip.org/how-to-fix-dso-missing-from-command-line" >DSO missing <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><div class="highlight-container" data-rel="Cmake"><figure class="iseeu highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS</span><br><span class="line">    <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -g -O2  -Wall -Wextra -Weffc++ -Werror=uninitialized  -Werror=return-type -Wconversion -Wsign-compare -Werror=unused-result -Werror=suggest-override -Wzero-as-null-pointer-constant -Wmissing-declarations -Wold-style-cast -Wnon-virtual-dtor -Wl,--copy-dt-needed-entries&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>关于对proto文件的配置，可以参考这个</p><div class="highlight-container" data-rel="Cmake"><figure class="iseeu highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取编译器</span></span><br><span class="line"><span class="keyword">find_program</span>(</span><br><span class="line">    PROTOC_CXX</span><br><span class="line">    protoc</span><br><span class="line">    DOC <span class="string">&quot;Protobuf Compiler (protoc)&quot;</span></span><br><span class="line">    REQUIRED</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要编译的 proto 文件</span></span><br><span class="line"><span class="keyword">file</span> (GLOB PROTO_SOURCE_FILES</span><br><span class="line">    <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/*.proto&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(PROTO_PATH    <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(PROTO_CXX_OUT <span class="string">&quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/gen_cxx&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">file</span>(<span class="keyword">MAKE_DIRECTORY</span> <span class="variable">$&#123;PROTO_CXX_OUT&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 protoc 处理 proto 文件</span></span><br><span class="line"><span class="keyword">foreach</span>(input_proto <span class="variable">$&#123;PROTO_SOURCE_FILES&#125;</span>)</span><br><span class="line">    <span class="keyword">get_filename_component</span>(DIR <span class="variable">$&#123;input_proto&#125;</span> DIRECTORY)</span><br><span class="line">    <span class="keyword">get_filename_component</span>(FILE_NAME <span class="variable">$&#123;input_proto&#125;</span> NAME_WE)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span>(OUTPUT_CXX_HEADER   <span class="string">&quot;$&#123;PROTO_CXX_OUT&#125;/$&#123;FILE_NAME&#125;.pb.h&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(OUTPUT_CXX_SOURCE   <span class="string">&quot;$&#123;PROTO_CXX_OUT&#125;/$&#123;FILE_NAME&#125;.pb.cc&quot;</span>)</span><br><span class="line">    <span class="keyword">list</span>(APPEND OUTPUT_SOURCES_CXX</span><br><span class="line">        <span class="variable">$&#123;OUTPUT_CXX_HEADER&#125;</span> <span class="variable">$&#123;OUTPUT_CXX_SOURCE&#125;</span>)</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_custom_command</span>(</span><br><span class="line">    OUTPUT  <span class="variable">$&#123;OUTPUT_SOURCES_CXX&#125;</span></span><br><span class="line">    <span class="keyword">COMMAND</span> <span class="variable">$&#123;PROTOC_CXX&#125;</span> --cpp_out=<span class="variable">$&#123;PROTO_CXX_OUT&#125;</span> --proto_path=<span class="variable">$&#123;PROTO_PATH&#125;</span> <span class="variable">$&#123;PROTO_SOURCE_FILES&#125;</span></span><br><span class="line">    DEPENDS <span class="variable">$&#123;PROTO_SOURCE_FILES&#125;</span></span><br><span class="line">    WORKING_DIRECTORY <span class="variable">$&#123;PROTO_PATH&#125;</span></span><br><span class="line">    COMMENT <span class="string">&quot;Generate Cpp Protobuf Source Files&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_custom_target</span>(</span><br><span class="line">    compile_cxx_protos</span><br><span class="line">    DEPENDS <span class="variable">$&#123;OUTPUT_SOURCES_CXX&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置生成源文件包含目录变量供上层引用</span></span><br><span class="line"><span class="keyword">set</span>(PROTO_GEN_CXX_INCLUDE_DIRS <span class="variable">$&#123;PROTO_CXX_OUT&#125;</span> PARENT_SCOPE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将生成的文件打包为库 proto_gen_cxx</span></span><br><span class="line"><span class="comment"># 程序可以链接到该库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(proto_gen_cxx <span class="variable">$&#123;OUTPUT_SOURCES_CXX&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(proto_gen_cxx protobuf)</span><br><span class="line"><span class="keyword">add_dependencies</span>(proto_gen_cxx compile_cxx_protos)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;protobuf简介&quot;&gt;&lt;a href=&quot;#protobuf简介&quot; class=&quot;headerlink&quot; title=&quot;protobuf简介&quot;&gt;&lt;/a&gt;protobuf简介&lt;/h1&gt;&lt;p&gt;Protocol Buffers（简称 protobuf）是 Google </summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="C/C++" scheme="http://example.com/tags/C-C/"/>
    
    <category term="网络编程" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    <category term="socket" scheme="http://example.com/tags/socket/"/>
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="protobuf" scheme="http://example.com/tags/protobuf/"/>
    
  </entry>
  
  <entry>
    <title>tcp粘包问题</title>
    <link href="http://example.com/2024/07/26/tcp-packet/"/>
    <id>http://example.com/2024/07/26/tcp-packet/</id>
    <published>2024-07-26T13:11:21.000Z</published>
    <updated>2024-11-08T02:21:34.892Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是粘包"><a href="#什么是粘包" class="headerlink" title="什么是粘包"></a>什么是粘包</h1><p>TCP粘包问题是指在使用TCP协议进行网络通信时，客户端和服务器之间发送的数据包可能会被TCP协议栈在底层进行合并或者拆分，导致客户端接收到的数据不再是单独、完整的数据包，而是多个数据包的内容被粘在一起或者多个数据包的内容被拆分到不同的接收缓冲区中。</p><h1 id="粘包原因"><a href="#粘包原因" class="headerlink" title="粘包原因"></a>粘包原因</h1><h2 id="1-因为TCP是面向字节流的协议"><a href="#1-因为TCP是面向字节流的协议" class="headerlink" title="1. 因为TCP是面向字节流的协议"></a>1. 因为TCP是面向字节流的协议</h2><p>传输的数据是以流的形式,而流数据是没有明确的开始结尾边界,所以 TCP 也没办法判断哪一段流属于一个消息;TCP协议是流式协议;所谓流式协议,即协议的内容是像流水一样的字节流,内容与内容之间没有明确的分界标志,需要认为手动地去给这些协议划分边界。</p><p>例如客户端每次发送N个字节给服务端，N取决于当前客户端的发送缓冲区是否有数据，比如发送缓冲区总大小为10个字节，当前有5个字节数据（例如上次要发送的数据‘loveu’）未发送完，那么此时只有5个字节的空闲空间，客户端调用发送接口发送“hello world!”其实就是只能发送“hello”给服务器，那么服务器一次性得到的数据就是“loveuhello”，而剩余的“world！”只能留给下一次发送，下一次服务器收到的就是“world！”</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2024/07/30/FLGRpuP6DyoK4vQ.png"                      alt="tlv1.png"                ></p><h2 id="2-数据发送和接收速率不匹配"><a href="#2-数据发送和接收速率不匹配" class="headerlink" title="2. 数据发送和接收速率不匹配"></a>2. 数据发送和接收速率不匹配</h2><p>如果发送方发送数据的速度比接收方处理数据的速度快，就可能导致多个消息被一次性读取。比如客户端1s内发送了两次“hello world！”，服务器过了2s才接收到数据，那一次性就会读出两个“hello world”</p><h2 id="3-tcp底层的安全和效率机制不允许字节数特别少的小包发送频率过高"><a href="#3-tcp底层的安全和效率机制不允许字节数特别少的小包发送频率过高" class="headerlink" title="3. tcp底层的安全和效率机制不允许字节数特别少的小包发送频率过高"></a>3. tcp底层的安全和效率机制不允许字节数特别少的小包发送频率过高</h2><p>tcp会在底层累计数据长度到一定大小才一起发送，比如连续发送1字节的数据要累计到多个字节才发送，可以了解下tcp底层的<a class="link"   href="https://blog.csdn.net/m0_61567378/article/details/130886149" >Nagle算法 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p><h1 id="处理粘包"><a href="#处理粘包" class="headerlink" title="处理粘包"></a>处理粘包</h1><p>处理粘包的方式主要采用应用层定义收发包格式的方式，这个过程俗称切包处理，常用的协议被称为<code>tlv</code>协议(消息id+消息长度+消息内容)</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2024/07/26/3q8MRKOo9YD7z4S.png"                      alt="tlv1.png"                ></p><p>为了方便理解，这里先简化发送格式，改成“消息长度+消息内容”的方式</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2024/07/26/blhFoOsUPANJQa2.png"                      alt="tlvsimple.png"                ></p><h2 id="消息节点"><a href="#消息节点" class="headerlink" title="消息节点"></a>消息节点</h2><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_LENGTH 1024 * 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAD_LENGTH 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Session</span>;</span><br><span class="line">    <span class="built_in">MsgNode</span>( <span class="type">char</span> *msg, <span class="type">short</span> max_len )</span><br><span class="line">        : _cur_len( <span class="number">0</span> ), _total_len( max_len + HEAD_LENGTH ) &#123;</span><br><span class="line">        _msg = <span class="keyword">new</span> <span class="type">char</span>[_total_len + <span class="number">1</span>]();     <span class="comment">// 这里➕1是为了存放&#x27;\0&#x27;</span></span><br><span class="line">        <span class="built_in">memcpy</span>( _msg, &amp;max_len, HEAD_LENGTH ); <span class="comment">// 留出两个字节存储消息头</span></span><br><span class="line">        <span class="built_in">mempcpy</span>( _msg + HEAD_LENGTH, msg, max_len ); <span class="comment">// 存储消息体</span></span><br><span class="line">        _msg[_total_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MsgNode</span>( <span class="type">short</span> max_len ) : _cur_len( <span class="number">0</span> ), _total_len( max_len ) &#123;</span><br><span class="line">        _msg = <span class="keyword">new</span> <span class="type">char</span>[_total_len + <span class="number">1</span>]();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>( _msg, <span class="number">0</span>, _total_len );</span><br><span class="line">        _cur_len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MsgNode</span>() &#123; <span class="keyword">delete</span>[] _msg; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">short</span> _cur_len;   <span class="comment">// 当前已处理的数据长度</span></span><br><span class="line">    <span class="type">short</span> _total_len; <span class="comment">// 数据的总长度</span></span><br><span class="line">    <span class="type">char</span> *_msg;       <span class="comment">// 存储的数据指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h2 id="Session的改进"><a href="#Session的改进" class="headerlink" title="Session的改进"></a>Session的改进</h2><p>为了能够对收到的数据进行切包处理，需要定义一个消息接收节点、一个bool变量表示头部信息是否处理完成，以及将处理好的头部先缓存起来的结构</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;MsgNode&gt; _recv_msg_node;  <span class="comment">//收到消息结构</span></span><br><span class="line"><span class="type">bool</span> _b_head_parse;                       <span class="comment">//是否处理完头部信息</span></span><br><span class="line">std::shared_ptr&lt;MsgNode&gt; _recv_head_node; <span class="comment">//收到头部结构</span></span><br></pre></td></tr></table></figure></div><h2 id="完善接收逻辑"><a href="#完善接收逻辑" class="headerlink" title="完善接收逻辑"></a>完善接收逻辑</h2><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::HandleRead</span><span class="params">( <span class="type">const</span> boost::system::error_code &amp;error,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> bytes_transferred, std::shared_ptr&lt;Session&gt; _self_shared )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( !error ) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">PrintRecvData</span>(_data, bytes_transferred);</span><br><span class="line">        std::<span class="function">chrono::seconds <span class="title">duration</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(duration);</span><br><span class="line">        <span class="comment">// 已经移动的字符串</span></span><br><span class="line">        <span class="type">int</span> copy_len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ( bytes_transferred &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="comment">// 判断头部是否处理</span></span><br><span class="line">            <span class="keyword">if</span> ( !_b_head_parse ) &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">NOTE:</span> step 1</span></span><br><span class="line">                <span class="comment">// 如果数据小于头部大小，先将数据放入_recv_head_node</span></span><br><span class="line">                <span class="keyword">if</span> ( bytes_transferred + _recv_head_node-&gt;_cur_len &lt;</span><br><span class="line">                     HEAD_LENGTH ) &#123;</span><br><span class="line">                    <span class="built_in">memcpy</span>( _recv_head_node-&gt;_msg + _recv_head_node-&gt;_cur_len,</span><br><span class="line">                        _data + copy_len, bytes_transferred );</span><br><span class="line">                    _recv_head_node-&gt;_cur_len += bytes_transferred;</span><br><span class="line">                    <span class="built_in">memset</span>( _data, <span class="number">0</span>, MAX_LENGTH );</span><br><span class="line">                    _socket.<span class="built_in">async_read_some</span>(</span><br><span class="line">                        boost::asio::<span class="built_in">buffer</span>( _data, MAX_LENGTH ),</span><br><span class="line">                        std::<span class="built_in">bind</span>( &amp;Session::HandleRead, <span class="keyword">this</span>,</span><br><span class="line">                            std::placeholders::_1, std::placeholders::_2,</span><br><span class="line">                            _self_shared ) );</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// <span class="doctag">NOTE:</span> step 2</span></span><br><span class="line">                <span class="comment">// 收到的数据比头部多，可能是多个逻辑包，要做切包处理</span></span><br><span class="line">                <span class="comment">// 头部剩余未复制的长度</span></span><br><span class="line">                <span class="type">int</span> head_remain = HEAD_LENGTH - _recv_head_node-&gt;_cur_len;</span><br><span class="line">                <span class="built_in">memcpy</span>( _recv_head_node-&gt;_msg + _recv_head_node-&gt;_cur_len,</span><br><span class="line">                    _data + copy_len, head_remain );</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新已处理的data长度和剩余未处理长度</span></span><br><span class="line">                copy_len += head_remain;</span><br><span class="line">                bytes_transferred -= head_remain;</span><br><span class="line">                <span class="comment">// 获取头部数据</span></span><br><span class="line">                <span class="type">short</span> data_len = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">memcpy</span>( &amp;data_len, _recv_head_node-&gt;_msg, HEAD_LENGTH );</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;data_len is: &quot;</span> &lt;&lt; data_len &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 头部非法长度</span></span><br><span class="line">                <span class="keyword">if</span> ( data_len &gt; HEAD_LENGTH ) &#123;</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;Invalid data length is: &quot;</span> &lt;&lt; data_len</span><br><span class="line">                              &lt;&lt; std::endl;</span><br><span class="line">                    _server-&gt;<span class="built_in">ClearSession</span>( _uuid );</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                _recv_msg_node = std::<span class="built_in">make_shared</span>&lt;MsgNode&gt;( data_len );</span><br><span class="line"></span><br><span class="line">                <span class="comment">// <span class="doctag">NOTE:</span> step 3</span></span><br><span class="line">                <span class="comment">// 消息的长度小于头部规定的长度，说明数据未收集全，则先将部分消息放到接收节点里</span></span><br><span class="line">                <span class="keyword">if</span> ( (<span class="type">int</span>)bytes_transferred &lt; data_len ) &#123;</span><br><span class="line">                    <span class="built_in">memcpy</span>( _recv_msg_node-&gt;_msg + _recv_msg_node-&gt;_cur_len,</span><br><span class="line">                        _data + copy_len, bytes_transferred );</span><br><span class="line">                    _recv_msg_node-&gt;_cur_len += bytes_transferred;</span><br><span class="line">                    <span class="built_in">memset</span>( _data, <span class="number">0</span>, MAX_LENGTH );</span><br><span class="line">                    _socket.<span class="built_in">async_read_some</span>(</span><br><span class="line">                        boost::asio::<span class="built_in">buffer</span>( _data, MAX_LENGTH ),</span><br><span class="line">                        std::<span class="built_in">bind</span>( &amp;Session::HandleRead, <span class="keyword">this</span>,</span><br><span class="line">                            std::placeholders::_1, std::placeholders::_2,</span><br><span class="line">                            _self_shared ) );</span><br><span class="line">                    <span class="comment">// 头部处理完成</span></span><br><span class="line">                    _b_head_parse = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">memcpy</span>( _recv_msg_node-&gt;_msg + _recv_msg_node-&gt;_cur_len,</span><br><span class="line">                    _data + copy_len, data_len );</span><br><span class="line"></span><br><span class="line">                _recv_msg_node-&gt;_cur_len += data_len;</span><br><span class="line">                copy_len += data_len;</span><br><span class="line">                bytes_transferred -= data_len;</span><br><span class="line">                _recv_msg_node-&gt;_msg[_recv_msg_node-&gt;_total_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Recv msg is: &quot;</span> &lt;&lt; _recv_msg_node-&gt;_msg</span><br><span class="line">                          &lt;&lt; std::endl;</span><br><span class="line">                <span class="comment">// use Send for testing</span></span><br><span class="line">                <span class="built_in">Send</span>( _recv_msg_node-&gt;_msg, _recv_msg_node-&gt;_total_len );</span><br><span class="line">                <span class="comment">// 继续轮询未处理的数据</span></span><br><span class="line">                _b_head_parse = <span class="literal">false</span>;</span><br><span class="line">                _recv_head_node-&gt;<span class="built_in">clear</span>();</span><br><span class="line">                <span class="keyword">if</span> ( bytes_transferred &lt;= <span class="number">0</span> ) &#123;</span><br><span class="line">                    <span class="built_in">memset</span>( _data, <span class="number">0</span>, MAX_LENGTH );</span><br><span class="line">                    _socket.<span class="built_in">async_read_some</span>(</span><br><span class="line">                        boost::asio::<span class="built_in">buffer</span>( _data, MAX_LENGTH ),</span><br><span class="line">                        std::<span class="built_in">bind</span>( &amp;Session::HandleRead, <span class="keyword">this</span>,</span><br><span class="line">                            std::placeholders::_1, std::placeholders::_2,</span><br><span class="line">                            _self_shared ) );</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// <span class="doctag">NOTE:</span> step 4</span></span><br><span class="line">            <span class="comment">// 已经处理完头部，处理上次未接收完的消息数据</span></span><br><span class="line">            <span class="comment">// 接收的数据仍不足剩余未处理的</span></span><br><span class="line">            <span class="type">int</span> remain_msg =</span><br><span class="line">                _recv_msg_node-&gt;_total_len - _recv_msg_node-&gt;_cur_len;</span><br><span class="line">            <span class="keyword">if</span> ( (<span class="type">int</span>)bytes_transferred &lt; remain_msg ) &#123;</span><br><span class="line">                <span class="built_in">memcpy</span>( _recv_msg_node-&gt;_msg + _recv_msg_node-&gt;_cur_len,</span><br><span class="line">                    _data + copy_len, bytes_transferred );</span><br><span class="line">                _recv_msg_node-&gt;_cur_len += bytes_transferred;</span><br><span class="line">                <span class="built_in">memset</span>( _data, <span class="number">0</span>, MAX_LENGTH );</span><br><span class="line">                _socket.<span class="built_in">async_read_some</span>(</span><br><span class="line">                    boost::asio::<span class="built_in">buffer</span>( _data, MAX_LENGTH ),</span><br><span class="line">                    std::<span class="built_in">bind</span>( &amp;Session::HandleRead, <span class="keyword">this</span>,</span><br><span class="line">                        std::placeholders::_1, std::placeholders::_2,</span><br><span class="line">                        _self_shared ) );</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">memcpy</span>( _recv_msg_node-&gt;_msg + _recv_msg_node-&gt;_cur_len,</span><br><span class="line">                _data + copy_len, remain_msg );</span><br><span class="line">            bytes_transferred -= remain_msg;</span><br><span class="line">            copy_len += remain_msg;</span><br><span class="line">            _recv_msg_node-&gt;_msg[_recv_msg_node-&gt;_total_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Recv msg is: &quot;</span> &lt;&lt; _recv_msg_node-&gt;_msg &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// use Send for testing</span></span><br><span class="line">            <span class="built_in">Send</span>( _recv_msg_node-&gt;_msg, _recv_msg_node-&gt;_total_len );</span><br><span class="line">            <span class="comment">// 继续轮询未处理的数据</span></span><br><span class="line">            _b_head_parse = <span class="literal">false</span>;</span><br><span class="line">            _recv_head_node-&gt;<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">if</span> ( bytes_transferred &lt;= <span class="number">0</span> ) &#123;</span><br><span class="line">                _socket.<span class="built_in">async_read_some</span>(</span><br><span class="line">                    boost::asio::<span class="built_in">buffer</span>( _data, MAX_LENGTH ),</span><br><span class="line">                    std::<span class="built_in">bind</span>( &amp;Session::HandleRead, <span class="keyword">this</span>,</span><br><span class="line">                        std::placeholders::_1, std::placeholders::_2,</span><br><span class="line">                        _self_shared ) );</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;handle read failed, code is: &quot;</span> &lt;&lt; error.<span class="built_in">value</span>()</span><br><span class="line">                  &lt;&lt; <span class="string">&quot; message is: &quot;</span> &lt;&lt; error.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line">        _server-&gt;<span class="built_in">ClearSession</span>( _uuid );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><ol><li><p><code>copy_len</code>：已经处理的数据长度，因为存在一次接收多个包的情况，所以copy_len的意义是在于记录已经处理的数据的长度</p></li><li><p>首先判断<code>_b_head_parse</code>是否为<code>false</code>，如果为<code>false</code>，则表示头部未处理，需要先处理头部。先判断接收的数据是否小于<code>HEAD_LENGTH</code>，如果小于则需要拷贝数据到<code>_recv_head_node</code>中，然后再读取剩余的数据。</p></li><li><p>如果受到的数据比头部数据多，可能是多个数据包，需要做切包处理。根据之前保留在<code>_recv_head_node</code>中的数据长度，计算出剩余未读取的头部长度，然后取出剩余头部长度保存在<code>_recv_head_node</code>中。然后通过<code>memcpy</code>从节点拷贝出数据写入short类型的<code>data_len</code>，并更新<code>copy_len</code>，进而得到消息长度， 然后再读取剩余的消息体。先判断接收到数据未处理部分的长度和总共要接收的数据长度大小，如果小于总共要接收的长度，说明消息体还没接收完，则将未处理的部分写入到<code>_recv_msg_node</code>里，回调读事件。否则说明消息体接收完全</p></li><li><p>将消息体数据接收到<code>_recv_msg_node</code>中，接收完全后返回给对端。当然存在多个逻辑包粘连，此时要判断<code>bytes_transferred</code>是否&lt;&#x3D;0，如果是则说明只有一个逻辑包，我们处理完了，继续监听读事件，就直接返回即可，否则说明有多个数据包粘连，就继续执行上述操作</p></li><li><p>因为存在<code>_b_head_parse</code>为<code>true</code>，就是包头接收并处理完的情况，但是包体未接收完，则再次出发读事件，此时就要继续进行上述操作</p></li></ol><p>总体流程如下</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2024/07/26/mr2BgQoTFJe4EYK.png"                      alt="dealHandRead.png"                ></p><h2 id="粘包测试"><a href="#粘包测试" class="headerlink" title="粘包测试"></a>粘包测试</h2><p>为了测试粘包，需要制造粘包产生的现象，可以让客户端发送的频率高一些，服务器接收的频率低一些，这样造成前后端收发数据不一致导致多个数据包在服务器tcp缓冲区滞留产生粘包现象。</p><p>测试粘包之前，在服务器的<code>Session</code>中添加打印二进制函数</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::PrintRecvData</span><span class="params">(<span class="type">char</span> *data, <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    std::string result = <span class="string">&quot;0x&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        std::string hexstr;</span><br><span class="line">        ss &lt;&lt; std::hex &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; <span class="built_in">int</span>(data[i]) &lt;&lt; std::endl;</span><br><span class="line">        ss &gt;&gt; hexstr;</span><br><span class="line">        result += hexstr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Recv raw data is: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>然后将这个函数放到HandleRead里，每次收到数据就调用这个函数打印接收到的最原始的数据，然后睡眠2秒再进行收发操作，用来延迟接收对端数据制造粘包，之后的逻辑不变</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::HandleRead</span><span class="params">( <span class="type">const</span> boost::system::error_code &amp;error,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> bytes_transferred, std::shared_ptr&lt;Session&gt; _self_shared )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( !error ) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">PrintRecvData</span>(_data, bytes_transferred);</span><br><span class="line">        std::<span class="function">chrono::seconds <span class="title">duration</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(duration);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>客户端代码实现收发分离</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> boost::asio::ip::tcp;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAX_LENGTH  = <span class="number">1024</span> * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> HEAD_LENGTH = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        boost::asio::io_context ioc;</span><br><span class="line">        <span class="function">tcp::endpoint <span class="title">remote_ep</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            boost::asio::ip::address::from_string( <span class="string">&quot;127.0.0.1&quot;</span> ), <span class="number">10086</span> )</span></span>;</span><br><span class="line">        <span class="function">tcp::socket <span class="title">sock</span><span class="params">( ioc )</span></span>;</span><br><span class="line">        boost::system::error_code ec = boost::asio::error::host_not_found;</span><br><span class="line">        sock.<span class="built_in">connect</span>( remote_ep, ec );</span><br><span class="line">        <span class="keyword">if</span> ( ec ) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;connect failed: &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>() &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::thread <span class="title">send_thread</span><span class="params">( [&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">while</span> ( <span class="literal">true</span> ) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                this_thread::sleep_for( std::chrono::milliseconds( <span class="number">1</span> ) );</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">const</span> <span class="type">char</span> *request_msg = <span class="string">&quot;Hello World!&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">size_t</span> request_len         = strlen( request_msg );</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">char</span> send_data[MAX_LENGTH] = &#123; <span class="number">0</span> &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">                memcpy( send_data, &amp;request_len, <span class="number">2</span> );</span></span></span><br><span class="line"><span class="params"><span class="function">                memcpy( send_data + <span class="number">2</span>, request_msg, request_len );</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">                boost::asio::write(</span></span></span><br><span class="line"><span class="params"><span class="function">                    sock, boost::asio::buffer( send_data, request_len + <span class="number">2</span> ) );</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125; )</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::thread <span class="title">recv_thread</span><span class="params">( [&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">while</span> ( <span class="literal">true</span> ) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                this_thread::sleep_for(std::chrono::milliseconds(<span class="number">1</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">                std::cout &lt;&lt; <span class="string">&quot;Begin to receive&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">char</span> reply_head[HEAD_LENGTH];</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">size_t</span> reply_length = boost::asio::read(</span></span></span><br><span class="line"><span class="params"><span class="function">                    sock, boost::asio::buffer( reply_head, HEAD_LENGTH ) );</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">short</span> msglen = <span class="number">0</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">                memcpy( &amp;msglen, reply_head, HEAD_LENGTH );</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">char</span> msg[MAX_LENGTH] = &#123; <span class="number">0</span> &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">size_t</span> msg_length    = boost::asio::read(</span></span></span><br><span class="line"><span class="params"><span class="function">                    sock, boost::asio::buffer( msg, msglen ) );</span></span></span><br><span class="line"><span class="params"><span class="function">                cout &lt;&lt; <span class="string">&quot;Reply is: &quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">                cout.write( msg, msg_length ) &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">                cout &lt;&lt; <span class="string">&quot;Reply length is: &quot;</span> &lt;&lt; msg_length &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125; )</span></span>;</span><br><span class="line"></span><br><span class="line">        send_thread.<span class="built_in">join</span>();</span><br><span class="line">        recv_thread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="built_in">catch</span> ( std::exception &amp;e ) &#123;</span><br><span class="line">        cerr &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>该服务虽然实现了粘包处理，但是服务器仍存在不足，比如当客户端和服务器处于不同平台时收发数据会出现异常，根本原因是未处理大小端模式的问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是粘包&quot;&gt;&lt;a href=&quot;#什么是粘包&quot; class=&quot;headerlink&quot; title=&quot;什么是粘包&quot;&gt;&lt;/a&gt;什么是粘包&lt;/h1&gt;&lt;p&gt;TCP粘包问题是指在使用TCP协议进行网络通信时，客户端和服务器之间发送的数据包可能会被TCP协议栈在底层进行合并或</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="C/C++" scheme="http://example.com/tags/C-C/"/>
    
    <category term="网络编程" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    <category term="socket" scheme="http://example.com/tags/socket/"/>
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://example.com/2024/07/13/singleton/"/>
    <id>http://example.com/2024/07/13/singleton/</id>
    <published>2024-07-12T16:57:35.000Z</published>
    <updated>2024-11-08T02:21:34.892Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个全局对象，这样有利于我们调整系统行为</p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><ul><li>一个类能返回一个对象的引用(永远都是同一个)和一个获得该实例的方法(必须是静态方法) <code>getInstance</code></li><li>调用这个方法时，如果类持有的引用不为空就返回这个引用。如果类保持的引用为空，就创建该类的实例返回这个实例的引用</li><li>将该类的构造函数定义为私有方法，这样其他处的代码就无法通过调用该类的构造函数来实例化该对象，只有通过该类的静态方法来实现唯一实例。</li></ul><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ol><li>懒汉式</li></ol><blockquote><p>这种lazyloading很明显，不要求线程安全，在多线程不能正常工作</p></blockquote><table><thead><tr><th>是否lazy初始化</th><th>是否多线程安全</th><th>实现难度</th></tr></thead><tbody><tr><td>是</td><td>否</td><td>易</td></tr></tbody></table><p>实现：局部静态变量方式</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleLazy</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingleLazy</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SingleLazy</span>(<span class="type">const</span> SingleLazy&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    SingleLazy&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SingleLazy&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> SingleLazy&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> SingleLazy single;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_SingleLazy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 多线程可能出现问题</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;s1 addr is &quot;</span> &lt;&lt; &amp;SingleLazy::<span class="built_in">getInstance</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;s2 addr is &quot;</span> &lt;&lt; &amp;SingleLazy::<span class="built_in">getInstance</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>输出如下</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 addr is 0x557ab517b151</span><br><span class="line">s2 addr is 0x557ab517b151</span><br></pre></td></tr></table></figure></div><p>确实生成了唯一实例，但是存在隐患，多线程可能生成多个实例</p><ol start="2"><li>饿汉式</li></ol><table><thead><tr><th>是否lazy初始化</th><th>是否多线程安全</th><th>实现难度</th></tr></thead><tbody><tr><td>否</td><td>是</td><td>易</td></tr></tbody></table><ul><li>优点：没有加锁，执行效率会提高</li><li>缺点：类加载时就初始化，浪费内存</li></ul><p>实现：静态成员变量指针方式</p><blockquote><p>定义一个类的静态成员变量，用来控制实现单例</p></blockquote><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleHungry</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingleHungry</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SingleHungry</span>(<span class="type">const</span> SingleHungry&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    SingleHungry&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SingleHungry&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> SingleHungry* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(single == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            single = <span class="keyword">new</span> <span class="built_in">SingleHungry</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> SingleHungry *single;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 饿汉式初始化</span></span><br><span class="line">SingleHungry *SingleHungry::single = SingleHungry::<span class="built_in">getInstance</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_func</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;this is thread &quot;</span> &lt;&lt; num &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Instance is &quot;</span> &lt;&lt; SingleHungry::<span class="built_in">getInstance</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_SingleHungry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;s1 addr is &quot;</span> &lt;&lt; SingleHungry::<span class="built_in">getInstance</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;s2 addr is &quot;</span> &lt;&lt; SingleHungry::<span class="built_in">getInstance</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="function">std::thread <span class="title">ti</span><span class="params">(thread_func , i)</span></span>;</span><br><span class="line">        ti.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>输出结果如下</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s1 addr is 0x56334e3ae2b0</span><br><span class="line">s2 addr is 0x56334e3ae2b0</span><br><span class="line">this is thread 0</span><br><span class="line">Instance is 0x56334e3ae2b0</span><br><span class="line">this is thread 1</span><br><span class="line">Instance is 0x56334e3ae2b0</span><br><span class="line">this is thread 2</span><br><span class="line">Instance is 0x56334e3ae2b0</span><br></pre></td></tr></table></figure></div><p>可见无论是单线程还是多线程模式下，通过静态成员变量的指针实现的单例类都是唯一的。  </p><p>但是无论是饿汉式还是懒汉式都存在一个问题，那就是什么时候释放内存？多线程情况下，释放内存就很难了，还有二次释放内存的风险。</p><p>下面我们定义一个单例类并用懒汉式调用</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SinglePointer</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SinglePointer</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SinglePointer</span>(<span class="type">const</span> SinglePointer&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    SinglePointer&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SinglePointer&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> SinglePointer* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(single != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        Lock.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span>(single != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            Lock.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        single = <span class="keyword">new</span> <span class="built_in">SinglePointer</span>();</span><br><span class="line">        Lock.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> SinglePointer *single;</span><br><span class="line">    <span class="type">static</span> std::mutex Lock;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::mutex SinglePointer::Lock;</span><br><span class="line">SinglePointer *SinglePointer::single = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_func_ptr</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;this thread is &quot;</span> &lt;&lt; num &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Instance is &quot;</span> &lt;&lt; SinglePointer::<span class="built_in">getInstance</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_SinglePointer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;s1 addr is &quot;</span> &lt;&lt; SinglePointer::<span class="built_in">getInstance</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;s2 addr is &quot;</span> &lt;&lt; SinglePointer::<span class="built_in">getInstance</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="function">std::thread <span class="title">ti</span><span class="params">(thread_func_ptr , i)</span></span>;</span><br><span class="line">        ti.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 何时释放new的对象?造成内存泄漏</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>输出结果如下：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s1 addr is 0x55cede7582d0</span><br><span class="line">s2 addr is 0x55cede7582d0</span><br><span class="line">this thread is 0</span><br><span class="line">Instance is 0x55cede7582d0</span><br><span class="line">this thread is 1</span><br><span class="line">Instance is 0x55cede7582d0</span><br><span class="line">this thread is 2</span><br><span class="line">Instance is 0x55cede7582d0</span><br></pre></td></tr></table></figure></div><p>此时生成的单例对象的内存空间还没回收，这是个问题，另外如果多线程情况下多次delete也会造成崩溃。</p><p>所以需要一种自动回收内存的机制帮助我们回收内存，所以可以使用智能指针来做这个操作</p><p>实现方式：智能指针方式</p><blockquote><p>可以利用智能指针自动回收内存的机制设计单例类</p></blockquote><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleAuto</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingleAuto</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SingleAuto</span>(<span class="type">const</span> SingleAuto&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    SingleAuto&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SingleAuto&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">SingleAuto</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;single auto delete success\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;SingleAuto&gt; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(single != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        Lock.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span>(single != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            Lock.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        single = std::<span class="built_in">shared_ptr</span>&lt;SingleAuto&gt;(<span class="keyword">new</span> <span class="built_in">SingleAuto</span>());</span><br><span class="line">        Lock.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> std::shared_ptr&lt;SingleAuto&gt; single;</span><br><span class="line">    <span class="type">static</span> std::mutex Lock;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;SingleAuto&gt; SingleAuto:: single = <span class="literal">nullptr</span>;</span><br><span class="line">std::mutex SingleAuto::Lock;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_SingleAuto</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> sp1 = SingleAuto::<span class="built_in">getInstance</span>();</span><br><span class="line">    <span class="keyword">auto</span> sp2 = SingleAuto::<span class="built_in">getInstance</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sp1 is &quot;</span> &lt;&lt; sp1 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sp2 is &quot;</span> &lt;&lt; sp2 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 存在隐患，可以手动删除裸指针，造成崩溃，因为会二次释放内存</span></span><br><span class="line">    <span class="comment">// delete sp1.get();</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>输出如下</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sp1 is 0x56252c7252f0</span><br><span class="line">sp2 is 0x56252c7252f0</span><br></pre></td></tr></table></figure></div><p>智能指针方式不存在内存泄漏，但是有一个隐患就是单例类的析构函数是public,如果被人手动调用会存在崩溃问题，比如将上面的test_SingleAuto中的注释打开，程序会崩溃。</p><p>实现：辅助类智能指针单例模式</p><blockquote><p>智能指针在构造的时候可以指定删除器，所以可以传递一个辅助类或者辅助函数帮助智能指针回收内存时调用我们指定的析构函数</p></blockquote><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> safe deletorr</span></span><br><span class="line"><span class="comment">// 防止外界deletor</span></span><br><span class="line"><span class="comment">// 声明辅助类</span></span><br><span class="line"><span class="comment">// 该类定义放函数调用SingleAutoSafe析构函数</span></span><br><span class="line"><span class="comment">// 不可以提前声明辅助类，编译器会报 incomplete type</span></span><br><span class="line"><span class="comment">// class SafeDeletor</span></span><br><span class="line"><span class="comment">// 所以要提前定义辅助类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleAutoSafe</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SafeDeletor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(SingleAutoSafe* s)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;this is safe deletor operator()\n&quot;</span>;</span><br><span class="line">        <span class="keyword">delete</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SafeDeletorFunc</span><span class="params">(SingleAutoSafe* s)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;this is safe deletor func\n&quot;</span>;</span><br><span class="line">    <span class="keyword">delete</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleAutoSafe</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingleAutoSafe</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">SingleAutoSafe</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;this is sing auto safe deletor\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SingleAutoSafe</span>(<span class="type">const</span> SingleAutoSafe&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    SingleAutoSafe&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SingleAutoSafe&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">SafeDeletor</span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">SafeDeletorFunc</span><span class="params">(SingleAutoSafe* s)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;SingleAutoSafe&gt; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(single != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        Lock.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span>(single != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            Lock.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span>额外指定删除器</span></span><br><span class="line">        <span class="comment">// single = std::shared_ptr&lt;SingleAutoSafe&gt;(new SingleAutoSafe() , SafeDeletor());</span></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span>额外指定删除函数</span></span><br><span class="line">        single = std::<span class="built_in">shared_ptr</span>&lt;SingleAutoSafe&gt;(<span class="keyword">new</span> <span class="built_in">SingleAutoSafe</span>() , SafeDeletorFunc);</span><br><span class="line">        Lock.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> std::shared_ptr&lt;SingleAutoSafe&gt; single;</span><br><span class="line">    <span class="type">static</span> std::mutex Lock;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;SingleAutoSafe&gt; SingleAutoSafe::single = <span class="literal">nullptr</span>;</span><br><span class="line">std::mutex SingleAutoSafe::Lock;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_SingleAutoSafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> sp1 = SingleAutoSafe::<span class="built_in">getInstance</span>();</span><br><span class="line">    <span class="keyword">auto</span> sp2 = SingleAutoSafe::<span class="built_in">getInstance</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sp1 is &quot;</span> &lt;&lt; sp1 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sp2 is &quot;</span> &lt;&lt; sp2 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 此时无法访问析构函数，非常安全</span></span><br><span class="line">    <span class="comment">// delete sp1.get();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>输出如下</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sp1 is 0x563f192162b0</span><br><span class="line">sp2 is 0x563f192162b0</span><br><span class="line">this is safe deletor func</span><br></pre></td></tr></table></figure></div><p>SafeDeletor要写在SingleAutoSafe上边，并且SafeDeletor要声明为SingleAutoSafe类的友元类，这样就可以访问SingleAutoSafe的析构函数了。 我们在构造single时制定了SafeDeletor(),single在回收时，会调用SingleAutoSafe的仿函数，从而完成内存的销毁。 并且SingleAutoSafe的析构函数为私有的无法被外界手动调用了。</p><p>通过辅助类调用单例类的析构函数保证了内存释放的安全性和唯一性。这种方式是生产中常用的。如果将test_SingleAutoSafe的注释打开，手动删除在编译阶段就会报错，达到了代码安全的目的。</p><h2 id="通过单例模板类"><a href="#通过单例模板类" class="headerlink" title="通过单例模板类"></a>通过单例模板类</h2><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TD</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Single_T</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SafeDeletor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T* s)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;this is safe deletor operator()\n&quot;</span>;</span><br><span class="line">        <span class="keyword">delete</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SafeDeletorFunc</span><span class="params">(T* s)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;this is safe deletor func\n&quot;</span>;</span><br><span class="line">    <span class="keyword">delete</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Single_T</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Single_T</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Single_T</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;this is single template deletor\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Single_T</span>(<span class="type">const</span> Single_T&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Single_T&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Single_T&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">SafeDeletor</span>&lt;T&gt;;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">void</span> <span class="built_in">SafeDeletorFunc</span>&lt;T&gt;(T* s);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;T&gt; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(single != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        Lock.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span>(single != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            Lock.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span>额外指定删除器</span></span><br><span class="line">        <span class="comment">// single = std::shared_ptr&lt;T&gt;(new T, SafeDeletor&lt;T&gt;());</span></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span>额外指定删除函数</span></span><br><span class="line">        single = std::<span class="built_in">shared_ptr</span>&lt;T&gt;(<span class="keyword">new</span> T , SafeDeletorFunc&lt;T&gt;);</span><br><span class="line">        Lock.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> std::shared_ptr&lt;T&gt; single;</span><br><span class="line">    <span class="type">static</span> std::mutex Lock;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> 模板类的static成员要放在hpp文件内初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::shared_ptr&lt;T&gt; Single_T&lt;T&gt;::single = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::mutex Single_T&lt;T&gt;::Lock;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用std::call_once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleTon</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SingleTon</span><span class="params">()</span> </span>= <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">SingleTon</span>(<span class="type">const</span> SingleTon&amp; ) = <span class="keyword">delete</span>;</span><br><span class="line">    SingleTon&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SingleTon&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ~<span class="built_in">SingleTon</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;This is SingleTon deletor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">static</span> std::shared_ptr&lt;T&gt; single;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;T&gt; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> std::once_flag flag;</span><br><span class="line">        std::<span class="built_in">call_once</span>(flag, [&amp;]()&#123;</span><br><span class="line">            single = std::<span class="built_in">make_shared</span>&lt;T&gt;(<span class="keyword">new</span> T);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::shared_ptr&lt;T&gt; SingleTon&lt;T&gt;::single = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>使用方式：我们只需要定一个单例类，继承这个模板，并将构造和析构都设置为私有，同时设置友元保证自己的析构和构造可以被友元调用即可。</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleNet</span> : <span class="keyword">public</span> Single_T&lt;SingleNet&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingleNet</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">SingleNet</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">SingleNet</span>(<span class="type">const</span> SingleNet&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    SingleNet&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SingleNet&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">SafeDeletor</span>&lt;SingleNet&gt;;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Single_T</span>&lt;SingleNet&gt;;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">void</span> <span class="built_in">SafeDeletorFunc</span>&lt;SingleNet&gt;(SingleNet* s);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_Single_T</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> sp1 = SingleNet::<span class="built_in">getInstance</span>();</span><br><span class="line">    <span class="keyword">auto</span> sp2 = SingleNet::<span class="built_in">getInstance</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sp1 is &quot;</span> &lt;&lt; sp1 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sp2 is &quot;</span> &lt;&lt; sp2 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个全局对象，这样有利于我们调整系统行为&lt;/p&gt;
&lt;h2 id=&quot;实现思路&quot;</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>建造者模式</title>
    <link href="http://example.com/2024/07/13/builder/"/>
    <id>http://example.com/2024/07/13/builder/</id>
    <published>2024-07-12T16:57:29.000Z</published>
    <updated>2024-11-08T02:21:34.890Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>建造者模式（Builder Pattern）是一种在软件设计中用来组织对象的构造过程的方法。它将对象的构建和表示分离，允许独立改变构建过程或生成不同的表示形式。这种模式特别适用于那些需要创建复杂对象的场景，在这些场景中，对象的组成部分可能相互依赖或者取决于外部环境条件。</p><h2 id="建造者模式的主要组件"><a href="#建造者模式的主要组件" class="headerlink" title="建造者模式的主要组件"></a>建造者模式的主要组件</h2><p>建造者模式通常包含以下主要组件：</p><ol><li><p><strong>产品（Product）接口</strong>：定义了一个通用的产品或对象结构。所有具体产品的构建都会遵循这个接口。</p></li><li><p><strong>抽象建造者（Builder Interface）</strong>：为创建特定产品提供一组方法，这些方法用于设置产品的不同部分。该接口是所有具体建造者的超类。</p></li><li><p><strong>具体建造者（Concrete Builder）</strong>：实现抽象建造者接口，并定义了如何构建具体的产品实例。每个具体的建造者将根据需要构建不同的部分或选择不同的配置来创建产品。</p></li><li><p><strong>产品工厂（Product Factory）</strong> 或 <strong>导演（Director）</strong>：在一些情况下，可以使用一个中心类来调用特定的建造者方法并构建出一个完整的产品对象。这个类通常不直接与产品的具体实现交互，而是通过调用建造者的接口来完成构建过程。</p></li></ol><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>建造者模式适用于以下几种情况：</p><ul><li><strong>复杂对象构造</strong>：当创建对象时涉及多个步骤或依赖于外部环境条件（例如操作系统版本、网络配置等）。</li><li><strong>可选功能构建</strong>：在产品中包含可选择的组件或选项，如定制电脑配置（CPU类型、内存大小、硬盘驱动器类型等）。</li></ul><h2 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h2><p>为了更好地理解建造者模式，我们可以使用一个简单的例子来说明如何应用这个设计模式。假设我们正在组装一台电脑开发一个构建过程，允许用户根据需求自定义电脑的配置</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Product</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Computer</span><span class="params">()</span> </span>= <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setCPU</span><span class="params">( <span class="type">const</span> std::string &amp;cpu )</span> </span>&#123; cpu_ = cpu; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setMemory</span><span class="params">( <span class="type">const</span> std::string &amp;memory )</span> </span>&#123; memory_ = memory; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setStorage</span><span class="params">( <span class="type">const</span> std::string &amp;storage )</span> </span>&#123; storage_ = storage; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;CPU:     &quot;</span> &lt;&lt; cpu_ &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Memory:  &quot;</span> &lt;&lt; memory_ &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Storage: &quot;</span> &lt;&lt; storage_ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string cpu_;</span><br><span class="line">    std::string memory_;</span><br><span class="line">    std::string storage_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Builder interface</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ComputerBuilder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ComputerBuilder</span>()                       = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buildCPU</span><span class="params">( <span class="type">const</span> std::string &amp; )</span>     </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buildMemory</span><span class="params">( <span class="type">const</span> std::string &amp; )</span>  </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buildStorage</span><span class="params">( <span class="type">const</span> std::string &amp; )</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::shared_ptr&lt;Computer&gt; <span class="title">getResult</span><span class="params">()</span>    </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete Builder</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DesktopComputerBuilder</span> : <span class="keyword">public</span> ComputerBuilder &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DesktopComputerBuilder</span>() : <span class="built_in">computer_</span>( std::<span class="built_in">make_shared</span>&lt;Computer&gt;() ) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildCPU</span><span class="params">( <span class="type">const</span> std::string &amp;cpu )</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        computer_-&gt;<span class="built_in">setCPU</span>( cpu );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildMemory</span><span class="params">( <span class="type">const</span> std::string &amp;memory )</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        computer_-&gt;<span class="built_in">setMemory</span>( memory );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildStorage</span><span class="params">( <span class="type">const</span> std::string &amp;storage )</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        computer_-&gt;<span class="built_in">setStorage</span>( storage );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;Computer&gt; <span class="title">getResult</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> computer_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;Computer&gt; computer_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Director</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ComputerAssembler</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Computer&gt; <span class="title">assembleComputer</span><span class="params">( ComputerBuilder &amp;builder )</span> </span>&#123;</span><br><span class="line">        builder.<span class="built_in">buildCPU</span>( <span class="string">&quot;Inter i7&quot;</span> );</span><br><span class="line">        builder.<span class="built_in">buildStorage</span>( <span class="string">&quot;980 PRO 1TB SSD&quot;</span> );</span><br><span class="line">        builder.<span class="built_in">buildMemory</span>( <span class="string">&quot;16GB&quot;</span> );</span><br><span class="line">        <span class="keyword">return</span> builder.<span class="built_in">getResult</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DesktopComputerBuilder builder;</span><br><span class="line">    ComputerAssembler assembler;</span><br><span class="line">    <span class="keyword">auto</span> computer = assembler.<span class="built_in">assembleComputer</span>( builder );</span><br><span class="line">    computer-&gt;<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>在给出的代码示例中，实现了建造者模式的主要组成部分：</p><ol><li><p><strong>产品接口</strong>（<code>Computer</code>）：定义了一个用于创建电脑的基本接口。所有的具体产品（如台式电脑、笔记本电脑等）都必须遵循这个接口。</p></li><li><p><strong>抽象建造者（Builder Interface）</strong>（<code>ComputerBuilder</code>）：定义了构建电脑所需的通用方法，比如设置CPU、内存和存储设备等。这些方法对所有具体的建造者类开放，允许它们独立于具体产品来操作构建过程。</p></li><li><p><strong>具体建造者</strong>（<code>DesktopComputerBuilder</code>）：实现了抽象建造者接口并提供了具体实现的方法。每个具体建造者会根据自己的规则和逻辑来执行构建步骤，比如在台式电脑上选择不同的组件配置。</p></li><li><p><strong>导演类（Director）</strong>（<code>ComputerAssembler</code>）：负责调用具体的建造者类进行构建过程。它不直接与产品接口或具体的产品实例交互，而是通过调用抽象建造者的接口方法完成构建。</p></li><li><p><code>test_func</code> 函数展示了如何使用这些组成部分来构建一个台式电脑的例子：</p></li></ol><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DesktopComputerBuilder builder;</span><br><span class="line">ComputerAssembler assembler;</span><br><span class="line"><span class="keyword">auto</span> computer = assembler.<span class="built_in">assembleComputer</span>( builder );</span><br><span class="line">computer-&gt;<span class="built_in">print</span>();</span><br></pre></td></tr></table></figure></div><p>在这个例子中：</p><ul><li><strong>Builder</strong> (<code>DesktopComputerBuilder</code>) 实例化并执行了具体的构建步骤，比如选择CPU型号、内存大小和存储设备类型。</li><li><strong>Director</strong> (<code>ComputerAssembler</code>) 负责调用 <code>DesktopComputerBuilder</code> 的方法来逐步构造电脑。</li></ul><p>通过这样的结构设计，建造者模式使得在不同场景下可以有不同的构建过程（不同的具体产品），同时保持了代码的可扩展性和灵活性。例如，我们可以轻松地添加新的构建步骤或创建完全不同的产品类型而无需修改现有的组装逻辑。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>建造者模式是一种强大的设计模式，尤其在需要创建具有复杂构造过程的对象时非常有用。它通过封装构建过程和分离产品构建逻辑来提高系统的灵活性、可扩展性和可维护性。</p><h2 id="建造者模式的缺点"><a href="#建造者模式的缺点" class="headerlink" title="建造者模式的缺点"></a>建造者模式的缺点</h2><p>尽管建造者模式在很多情况下能够提供强大的对象构造能力，但就像任何设计模式一样，它也有其局限性和潜在的问题：</p><ol><li><p><strong>增加系统复杂性</strong>：引入多个类和接口会增加系统的复杂度。对于那些没有足够需求变化或不需要高度可配置性的项目来说，构建者模式可能会导致过度工程化。</p></li><li><p><strong>创建过多的实例</strong>：如果建造过程涉及到很多步骤或者每个步骤都有可能产生不同的实例，那么在某些实现中可能会创建大量的对象，这可能导致内存使用和性能问题。优化构建过程以减少不必要的对象创建是很重要的。</p></li><li><p><strong>代码维护难度</strong>：由于构造过程的细节被封装在多个类中，这对于系统维护来说可能需要更多的关注点。如果建造过程发生变化（例如引入新的组件或改变现有组件的选择逻辑），那么通常需要修改不止一个地方，这可能导致维护和更新的成本增加。</p></li><li><p><strong>耦合性问题</strong>：尽管抽象建造者试图通过接口来隐藏构建步骤的细节，但具体建造者的实现可能会与产品类紧密关联。这种依赖关系可能使得重构变得困难，并且如果对建造过程进行微小调整，可能需要修改多个相关部分。</p></li><li><p><strong>代码可读性和理解难度</strong>：建造者模式中的类和方法通常用于封装复杂的构建逻辑，这在一定程度上增加了代码的阅读和理解难度。对于没有熟悉此设计模式的人来说，在初次接触时可能会觉得难以理解整个系统的构造过程。</p></li><li><p><strong>资源消耗</strong>：如果构建步骤涉及外部依赖或需要大量计算资源（如网络请求、数据库查询等），那么建造者模式可能会增加整体系统对这些资源的需求，从而影响性能和用户体验。</p></li><li><p><strong>非线性构建路径</strong>：在某些实现中，建造过程可能不是单一线性的，而是有多个选择点。这可能导致难以预测的结果或更复杂的错误处理逻辑。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;建造者模式（Builder Pattern）是一种在软件设计中用来组织对象的构造过程的方法。它将对象的构建和表示分离，允许独立改变构建过程或</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>工厂模式</title>
    <link href="http://example.com/2024/07/13/factory/"/>
    <id>http://example.com/2024/07/13/factory/</id>
    <published>2024-07-12T16:57:23.000Z</published>
    <updated>2024-11-08T02:21:34.891Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在软件开发中，工厂模式是一种设计模式，主要用于创建对象而不暴露具体类的创建细节。这种模式的主要目标是封装创建过程，并将创建逻辑从客户端代码中解耦出来。</p><h2 id="定义和意图："><a href="#定义和意图：" class="headerlink" title="定义和意图："></a>定义和意图：</h2><p><strong>工厂模式</strong>的意图在于提供一个创建一系列相关或相互依赖的对象的过程，而无需指定这些对象的具体类。它通过定义一个工厂类来实现这一功能，该工厂类负责根据输入参数决定创建哪个具体类的实例。</p><h2 id="常见形式"><a href="#常见形式" class="headerlink" title="常见形式"></a>常见形式</h2><p>工厂模式通常有以下几种常见形式：</p><ol><li><p><strong>简单工厂（Simple Factory）</strong>：<br>这是最基础的形式，它不依赖于类层次结构，并且通常被用于静态语言中。工厂只创建一个类族中的对象，通过传入参数来决定创建哪个具体类。</p></li><li><p><strong>抽象工厂（Abstract Factory）</strong>：<br>抽象工厂模式提供了一系列的工厂方法，用于创建一组相关的产品对象。这些产品可以属于不同的家族，但必须遵循共同的接口或抽象定义。其目的是在多个产品的上下文之间进行隔离，使得客户端代码只需要知道如何使用产品而不是如何创建它们。</p></li><li><p><strong>单例工厂（Singleton Factory）</strong>：<br>在此模式中，工厂类是单例的，确保了在整个应用范围内只有一个实例存在，并且提供一个公共的方法来访问这个实例。这是一种常见的设计模式，用于限制资源访问或配置设置。</p></li><li><p><strong>构造函数工厂（Constructor Factory）</strong>：<br>这种形式在面向对象语言中较为常见，它通过构造方法创建和初始化对象。构造函数工厂可以接受参数构建具有特定配置的对象，提供了一种动态调整对象属性的机制。</p></li></ol><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li>在需要根据环境或运行时条件选择具体类时。</li><li>当客户端代码不应该依赖于具体的类实现细节，而是应该通过抽象接口进行交互时。</li><li>当创建复杂对象需要多个步骤、参数和依赖关系时（例如，配置文件中的信息用于决定对象实例的创建）。</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>假设我们有一个简单工厂模式的例子。假设我们要根据用户输入创建不同类型的形状：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Abstract product</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Shape</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Concrete Product</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;this is a circle&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;this is a square&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Abstract Creator</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShapeFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::shared_ptr&lt;Shape&gt; <span class="title">createShape</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ShapeFactory</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircleFactory</span> : <span class="keyword">public</span> ShapeFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Shape&gt; <span class="title">createShape</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;Circle&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareFactory</span> : <span class="keyword">public</span> ShapeFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::shared_ptr&lt;Shape&gt; <span class="title">createShape</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;Square&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Client</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;CircleFactory&gt; circleFactory = std::<span class="built_in">make_unique</span>&lt;CircleFactory&gt;();</span><br><span class="line">    std::unique_ptr&lt;SquareFactory&gt; squareFactory = std::<span class="built_in">make_unique</span>&lt;SquareFactory&gt;();</span><br><span class="line">    <span class="keyword">auto</span> circle = circleFactory-&gt;<span class="built_in">createShape</span>();</span><br><span class="line">    <span class="keyword">auto</span> square = squareFactory-&gt;<span class="built_in">createShape</span>();</span><br><span class="line">    circle-&gt;<span class="built_in">draw</span>();</span><br><span class="line">    square-&gt;<span class="built_in">draw</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>在这个例子中，<code>Shape</code> 和 <code>ShapeFactory</code> 是接口和抽象类的例子。工厂模式通过创建具体实现的实例（即 <code>Circle</code> 或 <code>Square</code>）来满足客户端的不同需求，而不需要在代码中硬编码具体的类名。</p><h3 id="具体分析："><a href="#具体分析：" class="headerlink" title="具体分析："></a>具体分析：</h3><ol><li><p><strong>接口（Abstract Class）</strong>：</p><ul><li><code>Shape</code>：这是抽象产品类，定义了一个纯虚函数<code>draw()</code>，用于绘制形状。</li><li><code>CircleFactory</code>, <code>SquareFactory</code>：这些是抽象创建者类的实现。它们都实现了从抽象创建者类继承的<code>createShape()</code>接口方法。</li></ul></li><li><p><strong>具体类</strong>：</p><ul><li><code>Circle</code> 和 <code>Square</code> 是具体产品类。它们各自实现了<code>draw()</code>函数以表示不同形状的绘制方式。</li></ul></li><li><p><strong>工厂模式</strong>：</p><ul><li>在这个例子中，通过使用抽象创建者（<code>ShapeFactory</code>）和具体创建者（<code>CircleFactory</code>, <code>SquareFactory</code>），我们可以在不直接引用具体产品类的情况下创建产品对象。这种方法使得客户端代码与具体的产品实现解耦。</li></ul></li><li><p><strong>测试函数</strong>：</p><ul><li><code>test_func()</code> 函数展示了如何通过工厂模式实例化不同的产品。它首先创建了<code>CircleFactory</code>和<code>SquareFactory</code>的实例，然后调用每个工厂的<code>createShape()</code>方法来获取相应的形状对象，并调用它们的<code>draw()</code>方法来验证是否正确创建并绘制出了圆形和正方形。</li></ul></li></ol><h2 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h2><ul><li>当需要在运行时决定使用哪个具体产品类时。</li><li>需要将产品的创建过程与产品的客户端代码分离，以提高代码可维护性和灵活性。</li><li>避免类的爆炸问题（即大量的相似类），通过一个工厂类来管理类的选择和实例化。</li></ul><p>通过这种方式，工厂模式提供了一种灵活的方式来根据特定需求动态地生成不同类型的对象。在实际开发中，这种设计模式常用于UI组件、数据库连接器等场景，以提高代码的可扩展性和维护性。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>工厂模式为创建对象提供了极大的灵活性和封装性，并有助于降低耦合度和提高代码的可维护性。它通过提供一个统一的方式来实例化特定类型的对象或一组相关的对象，使得系统结构更加清晰、更易于调整和扩展。</p><h3 id="工厂模式的缺点"><a href="#工厂模式的缺点" class="headerlink" title="工厂模式的缺点"></a>工厂模式的缺点</h3><p>虽然工厂模式在对象创建时提供了便利性和灵活性，但它同样存在一些潜在的局限和问题：</p><ol><li><p><strong>代码复杂性</strong>：随着功能的增加或需求的变化，工厂类可能会变得非常大且难以维护。每个产品都需要对应的创建方法或工厂实例，这可能导致代码结构混乱，尤其是在有大量相关产品的大型项目中。</p></li><li><p><strong>单一职责原则违背</strong>：在某些情况下，一个工厂类可能需要处理多个不同类的创建问题，这违反了单一职责原则（SRP）。理想的工厂应该只负责创建特定类型的产品，如果必须同时处理多种类型，则其职责会变得过于广泛。</p></li><li><p><strong>依赖增加</strong>：使用工厂模式引入了一个新的接口或抽象层，这可能导致代码中对工厂类的依赖增加。在某些情况下，这种依赖可能难以去除，尤其是当工厂类成为多个客户端组件之间的耦合点时。</p></li><li><p><strong>动态性限制</strong>：虽然工厂模式允许通过传递参数或配置文件来控制创建过程中的决策（如产品实例的选择），但这些设置往往需要在代码中硬编码。如果需要在运行时进行更复杂的自定义逻辑，可能需要更复杂的方法或额外的工厂类，这会增加系统的复杂性。</p></li><li><p><strong>调用链复杂</strong>：当一个工厂负责多个层次的对象创建时（例如，父工厂创建子工厂），可能会形成复杂的调用链。这种结构可能难以理解、测试和维护，尤其是在对象树非常深的情况下。</p></li><li><p><strong>资源管理问题</strong>：在处理大量或动态创建的对象时，工厂模式可能导致资源管理问题，如内存泄露或未正确关闭的资源（例如数据库连接）。如果产品实例需要特定生命周期管理，那么必须仔细考虑如何在工厂中实现这一点，以避免这些问题。</p></li><li><p><strong>非确定性创建过程</strong>：如果产品的创建过程依赖于外部因素（比如用户输入、配置文件、环境变量等），则工厂模式可能难以保证创建过程的确定性和可预测性。这可能会导致在某些情况下（如自动化测试）出现预期之外的结果或错误。</p></li><li><p><strong>对需求变化的适应性差</strong>：如果产品的需求或类型经常发生变化，那么需要频繁地修改工厂类以支持这些新需求。这可能导致代码库中大量重复的工作和维护负担。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;在软件开发中，工厂模式是一种设计模式，主要用于创建对象而不暴露具体类的创建细节。这种模式的主要目标是封装创建过程，并将创建逻辑从客户端代码中</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>智能指针</title>
    <link href="http://example.com/2024/07/10/cpp-pointer/"/>
    <id>http://example.com/2024/07/10/cpp-pointer/</id>
    <published>2024-07-10T13:38:33.000Z</published>
    <updated>2024-11-08T02:21:34.891Z</updated>
    
    <content type="html"><![CDATA[<h1 id="智能指针概述"><a href="#智能指针概述" class="headerlink" title="智能指针概述"></a>智能指针概述</h1><ol><li><p>为什么要有智能指针：直接用<code>new</code>和<code>delete</code>运算符极其容易导致内存泄露，而且非常难以避免，于是人们发明了智能指针这种可以自动回收内存的的工具</p></li><li><p>智能指针一共就三种：普通的指针可以单独一个指针占用一块内存，也可以多个指针共享一块内存</p><ol><li>共享型智能指针：<code>shared_ptr</code><blockquote><p>同一块堆内存可以被多个<code>shared_ptr</code>共享</p></blockquote></li><li>独享型智能指针：<code>unique_ptr</code><blockquote><p>同一块堆内存只能被一个<code>unique_ptr</code>拥有</p></blockquote></li><li>弱引用智能指针：<code>weak_ptr</code><blockquote><p>也是一种共享型智能指针，可以视为对共享型智能指针的一种补充</p></blockquote></li></ol></li></ol><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> *pi = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">  <span class="function"><span class="type">int</span> *<span class="title">pi2</span><span class="params">(pi)</span></span>; <span class="comment">//<span class="doctag">NOTE:</span> pi和pi2共享同一块内存</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ol start="3"><li><p>智能指针的注意事项</p><p>智能指针和裸指针不要混用</p></li></ol><h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol><li><p>我们在动态内存分配时，堆上的内存必须通过栈上的内存来寻址，也就是说栈上的指针(堆上的指针也可以指向堆内存，但终究是要通过栈来寻址)是寻找堆内存的唯一方式</p></li><li><p>所以我们可以给堆内存添加一个引用计数，有几个指针指向它，它的引用计数就是几。当引用计数为 0 时，操作系统就会释放掉这块内存</p></li></ol><h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><h4 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1. 初始化"></a>1. 初始化</h4><p>使用<code>new</code>运算符初始化</p><blockquote><p>一般来说不推荐使用<code>new</code>进行初始化，因为 C++标准提供了专门创建<code>shared_ptr</code>的函数<code>make_shared()</code>，该函数是经过优化的，效率更高</p></blockquote><p>使用<code>make_shared()</code>初始化</p><p><code>注意</code> ： 千万不要用裸指针初始化<code>shared_ptr</code>，容易出现内存泄露的问题</p><p>使用复制构造函数初始化也行</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">shared1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span> (<span class="number">100</span>))</span></span>;</span><br><span class="line">  std::shared_ptr&lt;<span class="type">int</span>&gt; shared2 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line">  <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">shared3</span><span class="params">(shared2)</span></span>;<span class="comment">// 使用复制构造函数初始化也行</span></span><br><span class="line">  <span class="type">int</span> *pi = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">shared4</span><span class="params">(pi)</span></span>;</span><br><span class="line">  <span class="comment">// delete pi; // <span class="doctag">NOTE:</span> 会造成二次释放(堆内存的重复释放)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h4 id="2-shared-ptr-的引用计数"><a href="#2-shared-ptr-的引用计数" class="headerlink" title="2. shared_ptr 的引用计数"></a>2. shared_ptr 的引用计数</h4><p>智能指针就是通过引用计数来判断释放内存的时机的<br><code>use_count()</code>函数可以得到<code>shared_ptr</code>对象的引用计数</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  std::shared_ptr&lt;<span class="type">int</span>&gt; shared1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line">  std::cout &lt;&lt; shared1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">shared2</span><span class="params">(shared1)</span></span>;</span><br><span class="line">  std::cout &lt;&lt; shared1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  shared2.<span class="built_in">reset</span>(); <span class="comment">// <span class="doctag">NOTE:</span> 释放掉该指针对对象的控制权</span></span><br><span class="line">  std::cout &lt;&lt; shared1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h4 id="3-把-shared-ptr-当成普通指针使用"><a href="#3-把-shared-ptr-当成普通指针使用" class="headerlink" title="3. 把 shared_ptr 当成普通指针使用"></a>3. 把 shared_ptr 当成普通指针使用</h4><p>智能指针可以像普通指针那样使用，<code>shared_ptr</code>早已对各种操作进行了重载，就当它是普通指针就可以了</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  std::shared_ptr&lt;<span class="type">int</span>&gt; shared1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line">  std::cout &lt;&lt; *shared1 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h4 id="4-常用函数"><a href="#4-常用函数" class="headerlink" title="4. 常用函数"></a>4. 常用函数</h4><ol><li><code>unique</code>函数<blockquote><p>判断该<code>shared_ptr</code>对象是否独占，若独占，返回<code>true</code>，否则返回<code>false</code></p></blockquote></li></ol><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  std::shared_ptr&lt;<span class="type">int</span>&gt; shared1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line">  std::cout &lt;&lt; shared1.<span class="built_in">unique</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">shared2</span><span class="params">(shared1)</span></span>;</span><br><span class="line">  std::cout &lt;&lt; shared1.<span class="built_in">unique</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  shared2.<span class="built_in">reset</span>();</span><br><span class="line">  std::cout &lt;&lt; shared1.<span class="built_in">unique</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><ol start="2"><li><p><code>reset</code>函数</p><ol><li>当<code>reset</code>函数有参数时，改变此<code>shared_ptr</code>对象指向的内存</li><li>当<code>reset</code>函数无参数时，将此<code>shared_ptr</code>对象置空，也就是将对象内存的指针设置为<code>nullptr</code></li></ol></li></ol><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  std::shared_ptr&lt;<span class="type">int</span>&gt; shared1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line">  std::cout &lt;&lt; shared1.<span class="built_in">unique</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  std::shared_ptr&lt;<span class="type">int</span>&gt; shared2 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">  shared1.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">  shared2 = shared1;</span><br><span class="line">  shared1.<span class="built_in">reset</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><ol start="3"><li><code>get</code>函数， 强烈不推荐使用</li></ol><p>如果一定要用，那么一定不能<code>delete</code>返回的指针</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  std::shared_ptr&lt;<span class="type">int</span>&gt; shared1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line">  std::cout &lt;&lt; shared1.<span class="built_in">unique</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> shared1.<span class="built_in">get</span>(); <span class="comment">// <span class="doctag">NOTE:</span> 堆内存重复释放</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><ol start="4"><li><p><code>swap</code>函数</p><blockquote><p>交换两个智能指针所指向的内存</p></blockquote></li><li><p><code>std</code>命名空间中全局的<code>swap</code>函数</p></li><li><p><code>shared_ptr</code>类提供的<code>swap</code>函数</p></li></ol><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::shared_ptr&lt;<span class="type">int</span>&gt; shared1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line">  std::shared_ptr&lt;<span class="type">int</span>&gt; shared2 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  shared1.<span class="built_in">swap</span>(shared2);</span><br><span class="line">  std::cout &lt;&lt; *shared1 &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; *shared2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  std::<span class="built_in">swap</span>(shared1, shared2);</span><br><span class="line">  std::cout &lt;&lt; *shared1 &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; *shared2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h4 id="5-关于智能指针创建数组的问题"><a href="#5-关于智能指针创建数组的问题" class="headerlink" title="5. 关于智能指针创建数组的问题"></a>5. 关于智能指针创建数组的问题</h4><h4 id="6-用智能指针作为参数传递时直接值传递就行"><a href="#6-用智能指针作为参数传递时直接值传递就行" class="headerlink" title="6. 用智能指针作为参数传递时直接值传递就行"></a>6. 用智能指针作为参数传递时直接值传递就行</h4><p><code>shared_ptr</code>的大小为固定的<code>8</code>或<code>16</code>字节</p><blockquote><p>也就是两倍指针的大小，32 位系统指针为<code>4</code>个字节，64 位系统指针为<code>8</code>个字节，<code>shared_ptr</code>中就两个指针，所以直接按值传递就行了</p></blockquote><h4 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h4><p>在现代程序中，当想要共享一块堆内存时，优先使用<code>shared_ptr</code>，可以极大的减少内存泄露的问题</p><h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h3><ol><li>这个智能指针是在 C++11 的时候引入标准库，它的出现完全是为了弥补<code>shared_ptr</code>的天生缺陷，其实<code>shared_ptr</code>可以说是几乎完美</li><li>只是通过引用计数实现的方式也引来了引用成环的问题，这种问题靠他自己是没法解决的，所以在 C++11 的时候将<code>shared_ptr</code>和<code>weak_ptr</code>一起引入了标准库，依次来解决循环引用的问题</li></ol><h3 id="2-shared-ptr-循环引用的问题"><a href="#2-shared-ptr-循环引用的问题" class="headerlink" title="2. shared_ptr 循环引用的问题"></a>2. shared_ptr 循环引用的问题</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  std::shared_ptr&lt;B&gt; sharedB;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  std::weak_ptr&lt;A&gt; sharedA; <span class="comment">// <span class="doctag">NOTE:</span> 只有把其中一个堆内存用weak_ptr来控制，这两块堆内存才会被释放</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// std::shared_ptr&lt;int&gt; shared1 = std::make_shared&lt;int&gt;(100);</span></span><br><span class="line">  <span class="comment">// std::cout &lt;&lt; shared1.use_count() &lt;&lt; std::endl;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// std::weak_ptr&lt;int&gt; weak1(shared1);</span></span><br><span class="line">  <span class="comment">// std::cout &lt;&lt; shared1.use_count() &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  std::shared_ptr&lt;A&gt; sharedA1 = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">  std::shared_ptr&lt;B&gt; sharedB1 = std::<span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line"></span><br><span class="line">  sharedA1-&gt;sharedB = sharedB1; <span class="comment">// <span class="doctag">NOTE:</span> 两个堆内存，你指我，我指你，双方都在等着对方释放</span></span><br><span class="line">  引用计数都为<span class="number">1</span>，当引用计数为<span class="number">0</span>的时候，堆内存才会被释放，所以这就造成了内存泄露</span><br><span class="line">  sharedB1-&gt;sharedA = sharedA1;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="3-weak-ptr-的作用原理"><a href="#3-weak-ptr-的作用原理" class="headerlink" title="3. weak_ptr 的作用原理"></a>3. weak_ptr 的作用原理</h3><p><code>weak_ptr</code>的作用对象需要绑定到<code>shared_ptr</code>对象上，作用原理是<code>weak_ptr</code>不会改变<code>shared_ptr</code>的引用计数，只要<code>shared_ptr</code>对象的引用计数为 0，就会释放内存，<code>weak_ptr</code>不会影响到释放内存的功能</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p><code>weak_ptr</code>是用比较少，就是为了处理<code>shared_ptr</code>循环引用问题设计的</p><h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><h3 id="1-介绍-1"><a href="#1-介绍-1" class="headerlink" title="1. 介绍"></a>1. 介绍</h3><p>独占式智能指针，在是用智能指针时，我们一般优先考虑独占式智能指针，因为消耗更小，如果发现内存需要共享，那么再去是用<code>shared_ptr</code></p><h3 id="2-unique-ptr-的初始化"><a href="#2-unique-ptr-的初始化" class="headerlink" title="2. unique_ptr 的初始化"></a>2. unique_ptr 的初始化</h3><blockquote><p>和 shared_ptr 完全类似</p></blockquote><ol><li>使用<code>new</code>运算符初始化</li><li>使用<code>make_unique</code>初始化</li></ol><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">unique1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">100</span>))</span></span>;</span><br><span class="line">  std::unique_ptr&lt;<span class="type">int</span>&gt; unique2 = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">1000</span>);</span><br><span class="line">  std::cout &lt;&lt; *unique1 &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; *unique2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="3-unique-ptr-的常用操作"><a href="#3-unique-ptr-的常用操作" class="headerlink" title="3. unique_ptr 的常用操作"></a>3. unique_ptr 的常用操作</h3><ol><li><code>unique_ptr</code>禁止复制构造函数，他禁止赋值运算符的重载运算。否则独占毫无意义</li><li><code>unique_ptr</code>允许移动构造，移动赋值。移动语义代表之前的对象已经失去了意义，移动操作自然不影响独占的特性</li></ol><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  std::unique_ptr&lt;<span class="type">int</span>&gt; unique1 = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line">  std::unique_ptr&lt;<span class="type">int</span>&gt; unique2 = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  unique2 = std::<span class="built_in">move</span>(unique1);</span><br><span class="line">  std::cout &lt;&lt; *unique2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ol start="4"><li><code>reset()</code>函数<ol><li>不带参数的情况下，释放智能指针的对象，并将智能指针置空</li><li>带参数的情况下，释放智能指针的对象，并将智能指针指向新的对象</li></ol></li></ol><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  std::unique_ptr&lt;<span class="type">int</span>&gt; unique1 = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line">  std::unique_ptr&lt;<span class="type">int</span>&gt; unique2 = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  unique1.<span class="built_in">reset</span>();</span><br><span class="line">  unique2.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">12</span>));</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; *unique2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ol start="4"><li>将<code>unique_ptr</code>的对象转化为<code>shared_ptr</code>的对象，当<code>unique_ptr</code>的对象作为一个右值时，就可以将该对象转化为<code>shared_ptr</code>的对象<blockquote><p>这个使用的并不多，需要将独占式指针转化为共享式指针常常是因为先前设计失误<br>注意：shared_ptr 对象无法将其转化为 unique_ptr 对象</p></blockquote></li></ol><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myfunc</span><span class="params">(std::unique_ptr&lt;<span class="type">int</span>&gt; unique3)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">shared1</span><span class="params">(std::move(unique3))</span></span>;</span><br><span class="line">&#125; <span class="comment">// NOTES: 一旦将一个对象转化成右值时，必须保证以后不再单独是用这个对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  std::unique_ptr&lt;<span class="type">int</span>&gt; unique1 = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line">  std::unique_ptr&lt;<span class="type">int</span>&gt; unique2 = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="智能指针的适用范围"><a href="#智能指针的适用范围" class="headerlink" title="智能指针的适用范围"></a>智能指针的适用范围</h3><h4 id="1-能使用智能指针就尽量是用智能指针-，-但是有些情况下不能使用智能指针"><a href="#1-能使用智能指针就尽量是用智能指针-，-但是有些情况下不能使用智能指针" class="headerlink" title="1. 能使用智能指针就尽量是用智能指针 ， 但是有些情况下不能使用智能指针"></a>1. 能使用智能指针就尽量是用智能指针 ， 但是有些情况下不能使用智能指针</h4><p>有些函数必须使用 C 语言的指针，这些函数又没有替代，这种情况下，才使用普通的指针，其他情况一律是用智能指针</p><p>必须使用 C 语言的指针包括:</p><ol><li>网络传输函数：比如 windows 下的<code>send</code>,<code>recv</code>函数，智能使用 C 语言的指针，无法替代</li><li>C 语言文件操作部分：这方面 C++已经有了替代品，C++的文件部分完全支持智能指针，所以在做大型项目时，推荐使用 C++的文件操作功能</li></ol><h4 id="2-我们应该是用哪个智能指针呢？"><a href="#2-我们应该是用哪个智能指针呢？" class="headerlink" title="2. 我们应该是用哪个智能指针呢？"></a>2. 我们应该是用哪个智能指针呢？</h4><ol><li>优先使用<code>unique_ptr</code>，内存需要共享时使用<code>shared_ptr</code></li><li>当使用<code>shared_ptr</code>时，如果出现循环引用的情况下，再去考虑<code>weak_ptr</code></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;智能指针概述&quot;&gt;&lt;a href=&quot;#智能指针概述&quot; class=&quot;headerlink&quot; title=&quot;智能指针概述&quot;&gt;&lt;/a&gt;智能指针概述&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;为什么要有智能指针：直接用&lt;code&gt;new&lt;/code&gt;和&lt;code&gt;delete&lt;/c</summary>
      
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C/C++" scheme="http://example.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>asio socket的创建和连接</title>
    <link href="http://example.com/2024/07/03/linux-socket-programming-2/"/>
    <id>http://example.com/2024/07/03/linux-socket-programming-2/</id>
    <published>2024-07-03T08:22:19.000Z</published>
    <updated>2024-11-08T02:21:34.892Z</updated>
    
    <content type="html"><![CDATA[<h1 id="终端节点的创建"><a href="#终端节点的创建" class="headerlink" title="终端节点的创建"></a>终端节点的创建</h1><p>所谓终端节点就是用来通信的端对端的节点，可以通过ip地址和端口构造，其的节点可以连接这个终端节点做通信</p><p>如果是客户端，可以通过对端的ip和端口构造一个<code>endpoint</code>对象</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">client_endpoint</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 定义需要解析的IP地址字符串和端口号</span></span><br><span class="line">    std::string raw_ip_address = <span class="string">"127.0.0.1"</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port_num   = <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">    boost::system::error_code error; <span class="comment">// 错误代码容器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Boost.Asio库中的ip::address_from_string()函数解析IP地址字符串</span></span><br><span class="line">    boost::asio::ip::address ip_address =</span><br><span class="line">        boost::asio::ip::address::<span class="built_in">from_string</span>( raw_ip_address, error );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查解析过程是否有错误发生，并输出相应的错误信息或返回错误代码</span></span><br><span class="line">    <span class="keyword">if</span> (error.<span class="built_in">value</span>() != <span class="number">0</span>) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Failed to parse IP address. Error code is: "</span></span><br><span class="line">                  &lt;&lt; error.<span class="built_in">value</span>() &lt;&lt; <span class="string">", Message: "</span></span><br><span class="line">                  &lt;&lt; error.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> error.<span class="built_in">value</span>(); <span class="comment">// 返回错误代码</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用解析的IP地址和端口号构建TCP endpoint对象</span></span><br><span class="line">    boost::asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">( ip_address, port_num )</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数返回值，表示操作是否成功执行（如果未抛出异常则假设为0）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p>如果是服务端，则只需要本地地址绑定就可以生成<code>endpoint</code></p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">server_endpoint</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port_num = <span class="number">8080</span>; <span class="comment">// 设置服务器监听端口号为8080</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用IPv4地址类型设置一个任意的本地IP地址。这意味着服务器将侦听来自任何合法的IPv4地址。</span></span><br><span class="line">    boost::asio::ip::address ip_address = boost::asio::ip::address_v4::<span class="built_in">any</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个TCP端点（endpoint），它将绑定到指定的本地IP地址和端口号上</span></span><br><span class="line">    boost::asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(ip_address, port_num)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 表示函数执行成功，返回值为0</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h1 id="创建socket"><a href="#创建socket" class="headerlink" title="创建socket"></a>创建socket</h1><ol><li>创建上下文<code>io_context</code></li><li>选择协议</li><li>生成<code>socket</code></li><li>打开<code>socket</code></li></ol><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">create_tcp_socket</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 使用boost::asio中的ip模块和tcp类定义协议版本v4的套接字</span></span><br><span class="line">    <span class="keyword">using</span> boost::asio::ip::tcp;</span><br><span class="line">    boost::asio::io_context ios; <span class="comment">// 创建IO上下文，用于处理异步操作</span></span><br><span class="line"></span><br><span class="line">    tcp protocol = tcp::<span class="built_in">v4</span>(); <span class="comment">// 初始化并配置为IPv4协议</span></span><br><span class="line"></span><br><span class="line">    <span class="function">tcp::socket <span class="title">sock</span><span class="params">( ios,</span></span></span><br><span class="line"><span class="params"><span class="function">        protocol )</span></span>; <span class="comment">// 使用给定的io_context创建一个新套接字，并将其初始化为指定协议版本</span></span><br><span class="line">    boost::system::error_code ec; <span class="comment">// 创建错误代码对象，用于捕获可能发生的异常</span></span><br><span class="line"></span><br><span class="line">    sock.<span class="built_in">open</span>( protocol, ec ); <span class="comment">// 尝试打开一个与指定协议兼容的新套接字</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( ec.<span class="built_in">value</span>() != <span class="number">0</span> ) { <span class="comment">// 检查是否发生任何错误</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Failed to open the socket! Error code: "</span> &lt;&lt; ec.<span class="built_in">value</span>()</span><br><span class="line">                  &lt;&lt; <span class="string">" Message: "</span> &lt;&lt; ec.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> ec.<span class="built_in">value</span>(); <span class="comment">// 如果打开套接字失败，返回错误代码作为结果值</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 成功的情况下，函数返回0表示成功创建了TCP套接字</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>上面的<code>socket</code>只是通信的<code>socket</code>,如果是服务端，我们还需要生成一个<code>acceptor</code>的<code>socket</code>,用来接受新的连接</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">create_acceptor_socket</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 使用boost::asio中的ip模块和tcp类定义协议版本v6的套接字接受器（acceptor）</span></span><br><span class="line">    <span class="keyword">using</span> boost::asio::ip::tcp;</span><br><span class="line">    boost::asio::io_context ios; <span class="comment">// 创建IO上下文，用于处理异步操作</span></span><br><span class="line"></span><br><span class="line">    tcp protocol = tcp::<span class="built_in">v6</span>(); <span class="comment">// 初始化并配置为IPv6协议</span></span><br><span class="line"></span><br><span class="line">    <span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ios )</span></span>; <span class="comment">// 使用给定的io_context创建一个新接受器（acceptor），用于监听连接请求</span></span><br><span class="line"></span><br><span class="line">    boost::system::error_code ec; <span class="comment">// 创建错误代码对象，用于捕获可能发生的异常</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试打开一个与指定协议兼容的新接受器</span></span><br><span class="line">    acceptor.<span class="built_in">open</span>( protocol, ec );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( ec.<span class="built_in">value</span>() != <span class="number">0</span> ) { <span class="comment">// 检查是否发生任何错误</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Failed to open the socket! Error code: "</span> &lt;&lt; ec.<span class="built_in">value</span>()</span><br><span class="line">                  &lt;&lt; <span class="string">" Message: "</span> &lt;&lt; ec.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> ec.<span class="built_in">value</span>(); <span class="comment">// 如果打开接受器失败，返回错误代码作为结果值</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 成功的情况下，函数返回0表示成功创建了IPv6协议的接受器（acceptor）</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h1 id="绑定acceptor"><a href="#绑定acceptor" class="headerlink" title="绑定acceptor"></a>绑定acceptor</h1><p>对于acceptor类型的socket,服务器需要将其绑定到指定的断点，所有连接这个端点的连接都可以被接收到</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind_acceptor_socket</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 使用boost::asio中的ip模块和tcp类定义协议版本v4的套接字接受器（acceptor）</span></span><br><span class="line">    <span class="keyword">using</span> boost::asio::ip::tcp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定要绑定的端口号，这里为8080</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port_num = <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">tcp::endpoint <span class="title">endpoint</span><span class="params">( boost::asio::ip::address_v4::any(),</span></span></span><br><span class="line"><span class="params"><span class="function">        port_num )</span></span>; <span class="comment">// 创建一个网络端点对象用于指定IP地址和端口</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建IO上下文，用于处理异步操作</span></span><br><span class="line"></span><br><span class="line">    boost::asio::io_context ios;</span><br><span class="line"></span><br><span class="line">    <span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">( ios,</span></span></span><br><span class="line"><span class="params"><span class="function">        endpoint )</span></span>; <span class="comment">// 使用给定的io_context创建并初始化一个新接受器（acceptor），同时绑定到指定的端点</span></span><br><span class="line"></span><br><span class="line">    boost::system::error_code ec; <span class="comment">// 创建错误代码对象，用于捕获可能发生的异常</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试将接受器（acceptor）绑定到指定的网络端点</span></span><br><span class="line">    acceptor.<span class="built_in">bind</span>( endpoint, ec );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( ec.<span class="built_in">value</span>() != <span class="number">0</span> ) { <span class="comment">// 检查是否发生任何错误</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Failed to bind the socket! Error code: "</span> &lt;&lt; ec.<span class="built_in">value</span>()</span><br><span class="line">                  &lt;&lt; <span class="string">" Message: "</span> &lt;&lt; ec.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ec.<span class="built_in">value</span>(); <span class="comment">// 如果绑定失败，返回错误代码作为结果值</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 成功的情况下，函数返回0表示成功绑定了接受器（acceptor）到指定端口</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h1 id="连接指定的端点"><a href="#连接指定的端点" class="headerlink" title="连接指定的端点"></a>连接指定的端点</h1><p>作为客户端可以连接服务器指定的端点进行连接</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect_to_endpoint</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// IP地址字符串和端口号定义</span></span><br><span class="line">    std::string raw_ip_address = <span class="string">"127.0.0.1"</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port_num    = <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用std::exception类来捕获可能抛出的异常</span></span><br><span class="line">    <span class="keyword">using</span> boost::asio::ip::tcp;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="function">tcp::endpoint <span class="title">endpoint</span><span class="params">(boost::asio::ip::address::from_string(raw_ip_address), port_num)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建IO上下文，用于处理异步操作</span></span><br><span class="line"></span><br><span class="line">        boost::asio::io_context ios;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建socket并初始化为指定协议版本的套接字</span></span><br><span class="line">        <span class="function">tcp::socket <span class="title">soc</span><span class="params">(ios, endpoint.protocol())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试连接到指定端点（endpoint）</span></span><br><span class="line">        soc.<span class="built_in">connect</span>(endpoint);</span><br><span class="line">    } <span class="built_in">catch</span> (std::exception &amp;e) {</span><br><span class="line">        <span class="comment">// 如果在尝试连接时抛出异常，捕获它并输出错误信息</span></span><br><span class="line"></span><br><span class="line">        std::cerr &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 返回一个非零值表示连接失败</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error.<span class="built_in">value</span>(); <span class="comment">// 函数返回0表示成功建立了与指定端点的连接</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h1 id="服务器接收连接"><a href="#服务器接收连接" class="headerlink" title="服务器接收连接"></a>服务器接收连接</h1><p>当有客户端连接时，服务器需要接收连接</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept_new_connection</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 指定要监听的端口号，这里为8080</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port_num = <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> boost::asio::ip::</span><br><span class="line">        tcp; <span class="comment">// 使用ip模块和tcp类定义协议版本v4的套接字接受器（acceptor）</span></span><br><span class="line"></span><br><span class="line">    <span class="function">tcp::endpoint <span class="title">endpoint</span><span class="params">( boost::asio::ip::address_v4::any(),</span></span></span><br><span class="line"><span class="params"><span class="function">        port_num )</span></span>; <span class="comment">// 创建一个网络端点对象用于指定IP地址为任何可用地址和指定的端口</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建IO上下文，用于处理异步操作</span></span><br><span class="line"></span><br><span class="line">    boost::asio::io_context ios;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">( ios,</span></span></span><br><span class="line"><span class="params"><span class="function">            endpoint.protocol() )</span></span>; <span class="comment">// 使用给定的io_context创建并初始化一个新接受器（acceptor），同时绑定到指定的端点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置最大连接队列长度为BACKLOG</span></span><br><span class="line">        acceptor.<span class="built_in">listen</span>( BACKLOG );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建socket并初始化为指定协议版本的套接字</span></span><br><span class="line">        <span class="function">tcp::socket <span class="title">socket</span><span class="params">( ios, endpoint.protocol() )</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接受新的客户端连接请求，并将其绑定到新的socket对象上</span></span><br><span class="line">        acceptor.<span class="built_in">accept</span>( socket );</span><br><span class="line">    } <span class="built_in">catch</span> ( std::exception &amp;e ) {</span><br><span class="line">        <span class="comment">// 如果在处理过程中抛出异常，捕获并输出错误信息</span></span><br><span class="line"></span><br><span class="line">        std::cerr &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 返回一个非零值表示接受新连接失败</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 成功接收新的客户端连接后返回0作为结果值</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h1 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h1><p>buffer就是用来接收和发送数据时缓存数据的接口</p><p><code>boost::asio提</code>供了<code>asio::mutable_buffer</code>和<code>asio::const_buffer</code>两种类型的buffer，他们是一段连续的空间，首字节存储了后续数据的长度。<code>asio::mutable_buffer</code>用于写服务，<code>asio::const_buffer</code>用于读服务。但是着这两个结构都没有被asio的api直接使用</p><p>对于api的buffer参数，asio提出了<code>MutableBufferSequence</code>和<code>ConstBufferSequence</code>两种类型的buffer参数，他们是由多个<code>asio::mutable_buffer</code>和多个<code>asio::const_buffer</code>组成的容器。<code>MutableBufferSequence</code>和<code>ConstBufferSequence</code>的具体类型是<code>boost::asio::mutable_buffer</code>和<code>boost::asio::const_buffer</code>。也就是说<code>boost::asio</code>为了节省空间，将一部分连续空间组合起来，交给api使用。可以理解为<code>MutableBufferSequence</code>的数据结构为<code>std::vector&lt;boost::asio::mutable_buffer&gt;</code>，<code>ConstBufferSequence</code>的数据结构为<code>std::vector&lt;boost::asio::const_buffer&gt;</code></p><p><code>std::vector&lt;boost::asio::mutable_buffer&gt;</code>的结构如下</p><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2024/07/03/kqJpCB9e13wNYVx.png" alt="mutable_buffer.png"></p><p>每个vector存储的都是<code>mutable_buffer</code>的地址，每个<code>mutable_buffer</code>的第一个字节表示数据的长度，后面跟着数据内容。</p><p>这么复杂的结构交给用户使用并不合适，所以asio提出了buffer()函数，该函数接收多种形式的字节流，该函数返回<code>asio::mutable_buffers_1</code>或者<code>asio::const_buffers_1</code>结构的对象。</p><p>如果传递给buffer()的参数是一个只读类型，则函数返回<code>asio::const_buffers_1 </code>类型对象。</p><p>如果传递给buffer()的参数是一个可写类型，则返回<code>asio::mutable_buffers_1 </code>类型对象。</p><p><code>asio::const_buffers_1</code>和<code>asio::mutable_buffers_1</code>是<code>asio::mutable_buffer</code>和<code>asio::const_buffer</code>的适配器，提供了符合<code>MutableBufferSequence</code>和<code>ConstBufferSequence</code>概念的接口，所以他们可以作为boost::asio的api函数的参数使用。</p><p>总的来说，我们可以用buffer()函数来生成我们要使用的缓存存储数据<br>比如boost的发送接口send要求的参数为<code>ConstBufferSequence</code>类型</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ConstBufferSequence&gt;</span></span><br><span class="line"><span class="function">std::<span class="type">size_t</span> <span class="title">send</span><span class="params">(<span class="type">const</span> ConstBufferSequence &amp;buffers)</span></span>;</span><br></pre></td></tr></table></figure></div><p>将”Hello World”转换成这种类型</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_const_buffer</span><span class="params">()</span> </span>{</span><br><span class="line">    std::string buf = <span class="string">"Hello World"</span>;</span><br><span class="line">    boost::<span class="function">asio::const_buffer <span class="title">asio_buf</span><span class="params">(buf.c_str(), buf.length())</span></span>;</span><br><span class="line">    std::vector&lt;boost::asio::const_buffer&gt; buffers;</span><br><span class="line">    buffers.<span class="built_in">push_back</span>(asio_buf);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p>现在buffers就是可以传递给接口send的类型，但是这样太复杂了，可以直接使用buffer函数转为为send所需要的类型</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_buffer_str</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">asio::const_buffer <span class="title">asio_buf</span><span class="params">(<span class="string">"Hello World"</span>)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p>asio_buf可以直接传递给send接口。也可以将数组转化为send接受的类型</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_buffer_array</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> BUF_SIZE = <span class="number">20</span>;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="type">char</span>[]&gt; <span class="title">buf</span><span class="params">(<span class="keyword">new</span> <span class="type">char</span>[BUF_SIZE])</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> input_buf = boost::asio::<span class="built_in">buffer</span>(<span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(buf.<span class="built_in">get</span>()), BUF_SIZE);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p>对于流式操作，可以用<code>streambuf</code>，将输入输出流和<code>streambuf</code>组合起来，可以实现流式输入和输出</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_stream_buffer</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 创建一个 asio::streambuf 对象来存储和处理流操作。</span></span><br><span class="line">    asio::streambuf buf;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将 std::ostream 与作为参数传递给 `operator&lt;&lt;` 的 streambuf 关联起来，用于写入数据。</span></span><br><span class="line">    <span class="function">std::ostream <span class="title">output</span><span class="params">(&amp;buf)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 向输出流中写入两条消息，并以换行符分隔。</span></span><br><span class="line">    output &lt;&lt; <span class="string">"Message1\n"</span>;</span><br><span class="line">    output &lt;&lt; <span class="string">"Message2"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个 std::istream 与 streambuf 相关联，以便从其中读取数据。</span></span><br><span class="line">    <span class="comment">// 注意：这里传递的 `&amp;buf` 实际上是作为 `std::streambuf*` 的指针，而不是 `asio::streambuf` 类型。这是一个小错误示例代码中的注释可能未能正确地指出这一点。</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">std::istream <span class="title">input</span><span class="params">(&amp;buf)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义一个字符串变量用于存储读取的数据，并使用 getline() 函数从输入流中读取数据直到遇到换行符 '\n'。</span></span><br><span class="line">    std::string message1;</span><br><span class="line">    std::<span class="built_in">getline</span>(input, message1);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 现在，`message1` 变量将包含读取的 "Message1" 字符串（因为 getline() 函数停止在遇到下一个换行符之前）。</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;终端节点的创建&quot;&gt;&lt;a href=&quot;#终端节点的创建&quot; class=&quot;headerlink&quot; title=&quot;终端节点的创建&quot;&gt;&lt;/a&gt;终端节点的创建&lt;/h1&gt;&lt;p&gt;所谓终端节点就是用来通信的端对端的节点，可以通过ip地址和端口构造，其的节点可以连接这个终端节点做通</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="C/C++" scheme="http://example.com/tags/C-C/"/>
    
    <category term="网络编程" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    <category term="socket" scheme="http://example.com/tags/socket/"/>
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>操作系统笔记01</title>
    <link href="http://example.com/2024/07/02/operating-system-1/"/>
    <id>http://example.com/2024/07/02/operating-system-1/</id>
    <published>2024-07-02T15:22:47.000Z</published>
    <updated>2025-03-06T09:39:24.492Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统的概念、功能、目标"><a href="#操作系统的概念、功能、目标" class="headerlink" title="操作系统的概念、功能、目标"></a>操作系统的概念、功能、目标</h1><p>作为用户和计算机硬件之间的接口</p><ul><li><p>提供的功能：</p><ul><li>命令接口：<ul><li>联机命令接口(输入一次，输出一次)</li><li>脱机命令接口(批处理命令)</li></ul></li><li>程序接口：<ul><li>提供系统调用(广义指令)</li></ul></li></ul></li><li><p>目标： 方便用户使用</p></li></ul><h2 id="关于库函数和系统调用的区别"><a href="#关于库函数和系统调用的区别" class="headerlink" title="关于库函数和系统调用的区别"></a>关于库函数和系统调用的区别</h2><ul><li>库函数是语言或应用程序的一部分，可以运行在运行在用户空间中</li><li>系统调用是操作系统的一部分，是内核为用户提供的程序接口，运行在内核空间中，并且许多库函数都是用系统调用来实现功能</li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>未使用系统调用的库函数，其执行效率通常要比系统调用的高。因为使用系统调用时，需要上下文的切换及状态转换(由用户态转向核心态)</p><h1 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h1><h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><p>并发: 是指两个或多个时间在统一时间间隔发生(宏观同时发生，微观交替发生)</p><p>并行: 是指在同一时刻能同时完成两种或两种以上的工作</p><h2 id="互斥和共享"><a href="#互斥和共享" class="headerlink" title="互斥和共享"></a>互斥和共享</h2><p>互斥: 在一段时间内只允许一个进程访问资源(例如写入操作)</p><p>共享: 在一段时间内允许多个进程访问资源(例如读取操作)</p><h2 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h2><p>是指将一个物理上的实体变为若干逻辑上的对应物(例如虚拟机)</p><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停的，以不可预知的速度向前推进。只有系统拥有并发性，才有可能导致异步性。(例如C++的<code>async</code>，开辟一个一次性的线程执行并行任务，主线程可以通过<code>future</code>在合适的时机执行等待汇总结果。)</p><h1 id="操作系统的发展与分类"><a href="#操作系统的发展与分类" class="headerlink" title="操作系统的发展与分类"></a>操作系统的发展与分类</h1><h2 id="手工操作阶段"><a href="#手工操作阶段" class="headerlink" title="手工操作阶段"></a>手工操作阶段</h2><ul><li>纸带机(用户独占全机，人机速度矛盾)<ul><li>缺点： 用户独占全机，CPU需要等待人工操作，人机速度矛盾，资源利用率低</li></ul></li></ul><h2 id="批处理阶段"><a href="#批处理阶段" class="headerlink" title="批处理阶段"></a>批处理阶段</h2><ul><li><p>单道批处理阶段(外围及–磁带)</p><ul><li>优点：解决了人机矛盾和CPU与I&#x2F;O设备速度不匹配问题</li><li>缺点： 每次只能运行一道程序，不能充分地利用系统资源</li></ul></li><li><p>多道批处理系统(操作系统开始出现)</p></li></ul><h2 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h2><ul><li>轮流处理作业</li><li>不能处理紧急任务</li></ul><h2 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h2><ul><li>优先处理紧急任务</li><li>硬实时系统: 必须在严格的时间内完成处理</li><li>软实时系统: 可以偶尔犯错</li></ul><h2 id="网络操作系统"><a href="#网络操作系统" class="headerlink" title="网络操作系统"></a>网络操作系统</h2><h2 id="分布式操作系统"><a href="#分布式操作系统" class="headerlink" title="分布式操作系统"></a>分布式操作系统</h2><h2 id="个人计算机操作系统"><a href="#个人计算机操作系统" class="headerlink" title="个人计算机操作系统"></a>个人计算机操作系统</h2><h1 id="操作系统的运行环境"><a href="#操作系统的运行环境" class="headerlink" title="操作系统的运行环境"></a>操作系统的运行环境</h1><h2 id="处理器运行模式"><a href="#处理器运行模式" class="headerlink" title="处理器运行模式"></a>处理器运行模式</h2><ul><li>内核态&#x2F;核心态&#x2F;管态</li><li>用户态&#x2F;目态</li></ul><h2 id="程序的运行原理"><a href="#程序的运行原理" class="headerlink" title="程序的运行原理:"></a>程序的运行原理:</h2><ul><li>高级语言编写代码–&gt;机器指令</li><li>程序运行的过程就是CPU执行指令的效果</li></ul><h2 id="两类程序"><a href="#两类程序" class="headerlink" title="两类程序"></a>两类程序</h2><ul><li>内核程序</li><li>应用程序</li></ul><h2 id="两类指令"><a href="#两类指令" class="headerlink" title="两类指令"></a>两类指令</h2><ul><li><p>特权指令: 是指用户不允许直接使用的指令</p><ul><li>I&#x2F;O指令</li><li>关中断指令</li><li>内存清零指令</li><li>存取用于内存保护的级存器</li><li>送PSW到程序状态字寄存器的指令</li></ul></li><li><p>非特权指令: 是指允许用户直接使用的指令</p><ul><li>无法直接访问系统中的软硬资源</li><li>仅限于用户的地址空间</li></ul></li></ul><h2 id="内核-kernel"><a href="#内核-kernel" class="headerlink" title="内核(kernel)"></a>内核(kernel)</h2><ul><li>内核是操作系统最重要最核心的部分</li><li>有很多内核程序组成操作系统内核</li></ul><h2 id="如何改变状态"><a href="#如何改变状态" class="headerlink" title="如何改变状态"></a>如何改变状态</h2><ul><li>内核态-&gt;用户态: 一条修改PSW的特权指令</li><li>用户态-&gt;内核态: 由中断引起，硬件自动完成</li></ul><h2 id="中断和异常的概念"><a href="#中断和异常的概念" class="headerlink" title="中断和异常的概念"></a>中断和异常的概念</h2><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><ul><li><p>定义: 是指来自CPU执行指令外部的时间，通常用于信息输入&#x2F;输出。</p><ul><li>时钟中断</li><li>I&#x2F;O中断请求</li></ul></li><li><p>分类:</p><ul><li>可屏蔽中断: 通过INTR线发出的中断请求，通过改变屏蔽字可以实现多重中断</li><li>不可屏蔽中断: 通过NMI线发出的中断请求，通常是紧急的硬件故障</li></ul></li></ul><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><ul><li><p>定义: 是指来自CPU执行指令内部的时间，例如程序的非法操作码、地址越界、运算溢出、虚存系统的缺页及专门的陷入指令等引起的事件</p></li><li><p>分类:</p><ul><li>故障: 由指令执行引起的异常 (软件中断)</li><li>自陷: 是一种事先安排的“异常”事件，用于在用户态下调用操作系统内核程序 (软件中断)</li><li>终止: 出现了使得CPU无法继续执行的硬件故障 (硬件中断)</li></ul></li></ul><h3 id="中断机制的基本实现原理"><a href="#中断机制的基本实现原理" class="headerlink" title="中断机制的基本实现原理"></a>中断机制的基本实现原理</h3><ul><li>检查中断信号<ul><li>内中断: CPU在执行指令时会检查是否会有异常发生</li><li>外中断: 每个指令周期末尾，CPU都会检查是否由外中断信号需要处理</li></ul></li><li>找到相应的中断处理程序<ul><li>通过“中断向量表”实现</li></ul></li></ul><h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><p>凡是与资源有关的操作，都必须通过系统调用方式向操作系统提出服务请求，并有操作系统代为完成</p><ul><li>设备管理: 完成设备的请求或释放，以及设备的启动等功能</li><li>文件管理: 完成文件的读、写、创建、删除等功能</li><li>进程控制: 完成进程的创建、撤销、阻塞、唤醒等功能</li><li>进程通信: 完成进程之间的消息传递或信号传递</li><li>内存管理: 完成内存分配、回收及获取作业占用内存区大小和起始地址等功能</li></ul><h2 id="系统调用的过程"><a href="#系统调用的过程" class="headerlink" title="系统调用的过程"></a>系统调用的过程</h2><ul><li>传参</li><li>陷入指令&#x2F;Trap&#x2F;访管</li><li>由操作系统内核程序处理系统调用请求</li><li>返回应用程序</li></ul><h1 id="操作系统的运行机制和体系结构"><a href="#操作系统的运行机制和体系结构" class="headerlink" title="操作系统的运行机制和体系结构"></a>操作系统的运行机制和体系结构</h1><h2 id="分层结构"><a href="#分层结构" class="headerlink" title="分层结构"></a>分层结构</h2><p>内核分多层，每层可以单项调用更低一层提供的接口</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2024/07/02/mL1RC7zY48ht53n.png"                      alt="分层结构.png"                ></p><h3 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h3><ul><li><code>便于系统的调试和验证，自底向上逐层调试验证，简化了系统设计和实现</code></li><li>易扩充和易维护，各层之间调用接口清晰固定</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点:"></a>缺点:</h3><ul><li>合理定义各层关系比较困难，仅可调用相邻底层，难以合理定义各层的边界</li><li><code>效率较差，不可跨层调用，系统调用执行时间长</code></li></ul><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>将内核划分为多个模块，各模块之间相互协作</p><p>内核 &#x3D; 主模块+可加载内核模块</p><p><code>主模块: 只负责核心功能，如进程调度、内存管理</code><br>可加载内核模块: 可以动态加载新模块到内核，而无需重新编译整个内核</p><pre class="mermaid">flowchart TD    操作系统 ---|模块| 进程管理    操作系统 --- 存储器管理    操作系统 --- 文件管理    进程管理 ---|子模块| 进程控制    进程管理 --- 进程调度    存储器管理 --- 内存分配    存储器管理 --- 内存保护    文件管理 --- 磁盘管理    文件管理 --- 目录管理</pre><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点:"></a>优点:</h3><ul><li>模块间逻辑清晰易于维护，确定模块间接口后即可多模块同时开发</li><li><code>支持动态加载新的内核模块(安装设备驱动、安装新的文件系统模块到内核)，增强OS的适应性</code></li><li><code>任何模块都可以直接调用其他模块，无需采用消息传递进行通信，效率高</code></li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点:"></a>缺点:</h3><ul><li>模块间的接口定义未必合理、使用</li><li>模块间相互以来，更难调试和验证</li></ul><h2 id="宏内核"><a href="#宏内核" class="headerlink" title="宏内核"></a>宏内核</h2><p>所有的系统功能都放在内核里（大内核结构的OS通常也采用了“模块的”的设计思想）<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2024/07/02/RFZijhTr3QHbgNc.png"                      alt="宏内核.png"                ></p><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点:"></a>优点:</h3><ul><li>性能高，内核内部各种功能都可以直接相互调用</li></ul><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点:"></a>缺点:</h3><ul><li>内核庞大功能复杂，难以维护</li><li>大内核中某个功能模块出错，就可能导致整个系统崩溃</li></ul><h2 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h2><p>只把中断、原语、进程通信等最核心的功能放入内核。进程管理、文件管理、设备管理等功能以用户进程的形式运行在用户态</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2024/07/02/mb9PdlWkDnBUqX7.png"                      alt="微内核.png"                ></p><h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点:"></a>优点:</h3><ul><li>内核小功能少、易于维护，内核可靠性高</li><li>内核外的某个功能模块出错不会导致整个系统的崩溃</li></ul><h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点:"></a>缺点:</h3><ul><li>性能低，需要频繁切换用户态&#x2F;核心态</li><li>用户态下的各功能不可以直接相互调用，只能通过内核的“消息传递”来间接通信</li></ul><h2 id="外核"><a href="#外核" class="headerlink" title="外核"></a>外核</h2><p><code>内核负责进程调度、进程通信等功能。外核负责为用户进程分配未经抽象的硬件资源，且由外核负责保证资源使用安全</code></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2024/07/02/adrmtI9E3BoyzTD.png"                      alt="外核.png"                ></p><h3 id="优点-4"><a href="#优点-4" class="headerlink" title="优点:"></a>优点:</h3><ul><li>外核可直接给用户进程分配“不虚拟、不抽象”的硬件资源，使用户进程可以更灵活的使用硬件资源</li><li>减少了虚拟硬件资源的“映射层”，提升效率</li></ul><h3 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点:"></a>缺点:</h3><ul><li>降低了系统的一致性</li><li>使系统变得更加复杂</li></ul><h1 id="操作系统引导"><a href="#操作系统引导" class="headerlink" title="操作系统引导"></a>操作系统引导</h1><ol><li>激活CPU</li><li>硬件自检</li><li>加载带有操作系统的硬盘</li><li>加载MBR(主引导记录)</li><li>扫描硬盘分区表</li><li>加载分区引导记录</li><li>加载启动管理器</li><li>加载操作系统</li></ol><h1 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h1><p>虚拟机: 使用虚拟化技术，将一台物理机器虚拟化为多台虚拟机起，每个虚拟机起都可以独立运行一个操作系统</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2024/07/02/IUQ3gmnkH6MdWeD.png"                      alt="第一类VM.png"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2024/07/02/Qrv2npeL8uBhCRl.png"                      alt="第二类VM.png"                ></p><table><thead><tr><th>两类虚拟机管理程序的对比</th><th></th><th></th></tr></thead><tbody><tr><td></td><td>第一类VM</td><td>第二类VM</td></tr><tr><td>对物理资源的控制权</td><td>直接运行在硬件之上，能直接控制和分配物理资源</td><td>运行在<code>HOST OS</code>之上，依赖于<code>HOST OS</code>为其分配物理资源</td></tr><tr><td>资源分配方式</td><td>在安装<code>GUEST OS</code>时，VMM要在原本的硬盘上进行分配</td><td><code>GUEST OS</code>拥有自己的虚拟硬盘，是<code>HOST OS</code>文件系统中的一个大文件，</td></tr><tr><td>性能</td><td>性能更好</td><td>性能更差</td></tr><tr><td>可支持的虚拟机数量</td><td>更多，不需要和<code>HOST OS</code>竞争资源</td><td>更少，<code>HOST OS</code>本身也需要一定的系统资源</td></tr><tr><td>虚拟机的可迁移性</td><td>更差</td><td>只需要导出镜像文件即可</td></tr><tr><td>运行模式</td><td>运行在最高特权级，可以执行最高特权的指令</td><td>部分运行在用户态、部分运行在内核态。<code>GUEST OS</code>发出的系统调用会被VMM截获，转换为VMM对<code>HOST OS</code>的系统调用</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;操作系统的概念、功能、目标&quot;&gt;&lt;a href=&quot;#操作系统的概念、功能、目标&quot; class=&quot;headerlink&quot; title=&quot;操作系统的概念、功能、目标&quot;&gt;&lt;/a&gt;操作系统的概念、功能、目标&lt;/h1&gt;&lt;p&gt;作为用户和计算机硬件之间的接口&lt;/p&gt;
&lt;ul&gt;
&lt;</summary>
      
    
    
    
    <category term="考研" scheme="http://example.com/categories/%E8%80%83%E7%A0%94/"/>
    
    
    <category term="408" scheme="http://example.com/tags/408/"/>
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>socket的创建和连接</title>
    <link href="http://example.com/2024/06/30/linux-socket-programming-1/"/>
    <id>http://example.com/2024/06/30/linux-socket-programming-1/</id>
    <published>2024-06-29T16:51:53.000Z</published>
    <updated>2024-11-08T02:21:34.892Z</updated>
    
    <content type="html"><![CDATA[<h1 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h1><h2 id="socket的概念"><a href="#socket的概念" class="headerlink" title="socket的概念"></a>socket的概念</h2><p>Socket（套接字）是计算机网络编程中的一个基本概念，它为应用程序提供了访问底层网络协议的接口，使得进程间能够通过网络进行通信。在更广泛的意义上，Socket 是操作系统提供的一个抽象层，用于简化网络编程并隐藏复杂的网络协议细节。</p><p>Socket 是两个进程间通信的端点，每个 Socket 都有唯一的地址，这个地址包括 IP 地址和端口号。IP 地址用于定位网络上的主机，而端口号则用于区分同一台主机上的不同服务。</p><h2 id="socket的类型"><a href="#socket的类型" class="headerlink" title="socket的类型"></a>socket的类型</h2><p>socket 可以分为几种类型，主要依据它们支持的协议和通信模式：</p><ul><li><strong>流式 Socket (SOCK_STREAM)：</strong> 基于 TCP 协议，提供面向连接的服务，保证数据的顺序传输，且不会丢失数据。</li><li><strong>数据报 Socket (SOCK_DGRAM)：</strong> 基于 UDP 协议，提供无连接服务，数据报文独立传输，不保证数据的顺序和完整性，但传输效率较高。</li><li><strong>原始 Socket (SOCK_RAW)：</strong> 直接访问 IP 层，允许应用程序直接处理 IP 数据包，常用于网络分析或特殊用途的软件。</li></ul><h2 id="socket提供的函数"><a href="#socket提供的函数" class="headerlink" title="socket提供的函数"></a>socket提供的函数</h2><ul><li><code>socket()</code> 创建一个新的确定类型的套接字，类型用一个整型数值标识，并为它分配系统资源。</li><li><code>bind()</code> 一般用于服务器端，将一个套接字与一个套接字地址结构相关联，比如，一个指定的本地端口和IP地址。</li><li><code>listen()</code> 用于服务器端，使一个绑定的TCP套接字进入监听状态。</li><li><code>connect()</code>用于客户端，为一个套接字分配一个自由的本地端口号。 如果是TCP套接字的话，它会试图获得一个新的TCP连接。</li><li><code>accept()</code>用于服务器端。 它接受一个从远端客户端发出的创建一个新的TCP连接的接入请求，创建一个新的套接字，与该连接相应的套接字地址相关联。</li><li><code>send()</code>和<code>recv()</code>,或者<code>write()</code>和<code>read()</code>,或者<code>recvfrom()</code>和<code>sendto()</code>,用于往&#x2F;从远程套接字发送和接受数据。</li><li><code>close()</code>用于系统释放分配给一个套接字的资源。 如果是TCP，连接会被中断。</li><li><code>gethostbyname()</code>和&#96;gethostbyaddr()</li><li><code>select()</code>用于修整有如下情况的套接字列表： 准备读，准备写或者是有错误。</li><li><code>poll()</code>用于检查套接字的状态。 套接字可以被测试，看是否可以写入、读取或是有错误。</li><li><code>getsockopt()</code>用于查询指定的套接字一个特定的套接字选项的当前值。</li><li><code>setsockopt()</code>用于为指定的套接字设定一个特定的套接字选项。</li></ul><h3 id="1-socket"><a href="#1-socket" class="headerlink" title="1. socket()"></a>1. <code>socket()</code></h3><ul><li><strong>作用</strong>：创建一个新的 Socket。</li><li><strong>参数</strong>：<ul><li><code>int domain</code>：地址族，如 <code>AF_INET</code>（IPv4）或 <code>AF_INET6</code>（IPv6）。</li><li><code>int type</code>：Socket 类型，如 <code>SOCK_STREAM</code>（面向连接，流式）或 <code>SOCK_DGRAM</code>（无连接，数据报）。</li><li><code>int protocol</code>：协议，通常是 <code>0</code>，表示使用与 <code>type</code> 关联的默认协议。</li></ul></li></ul><h3 id="2-bind"><a href="#2-bind" class="headerlink" title="2. bind()"></a>2. <code>bind()</code></h3><ul><li><strong>作用</strong>：将 Socket 与本地地址（IP 地址和端口号）相关联。</li><li><strong>参数</strong>：<ul><li><code>int sockfd</code>：Socket 文件描述符。</li><li><code>const struct sockaddr *addr</code>：指向包含地址信息的 <code>sockaddr</code> 结构体的指针。</li><li><code>socklen_t addrlen</code>：<code>sockaddr</code> 结构体的长度。</li></ul></li></ul><h3 id="3-listen"><a href="#3-listen" class="headerlink" title="3. listen()"></a>3. <code>listen()</code></h3><ul><li><strong>作用</strong>：使 Socket 准备接收连接，通常用于服务器端。</li><li><strong>参数</strong>：<ul><li><code>int sockfd</code>：Socket 文件描述符。</li><li><code>int backlog</code>：待处理连接请求的最大队列长度。</li></ul></li></ul><h3 id="4-accept"><a href="#4-accept" class="headerlink" title="4. accept()"></a>4. <code>accept()</code></h3><ul><li><strong>作用</strong>：接受传入的连接请求，并返回一个新的 Socket 文件描述符用于通信。</li><li><strong>参数</strong>：<ul><li><code>int sockfd</code>：监听的 Socket 文件描述符。</li><li><code>struct sockaddr *addr</code>：可选参数，用于存储客户端的地址信息。</li><li><code>socklen_t *addrlen</code>：可选参数，用于存储地址信息的长度。</li></ul></li></ul><h3 id="5-connect"><a href="#5-connect" class="headerlink" title="5. connect()"></a>5. <code>connect()</code></h3><ul><li><strong>作用</strong>：初始化与远程主机的连接，通常用于客户端。</li><li><strong>参数</strong>：<ul><li><code>int sockfd</code>：Socket 文件描述符。</li><li><code>const struct sockaddr *addr</code>：指向包含远程主机地址信息的 <code>sockaddr</code> 结构体的指针。</li><li><code>socklen_t addrlen</code>：<code>sockaddr</code> 结构体的长度。</li></ul></li></ul><h3 id="6-send"><a href="#6-send" class="headerlink" title="6. send()"></a>6. <code>send()</code></h3><ul><li><strong>作用</strong>：发送数据到已连接的 Socket。</li><li><strong>参数</strong>：<ul><li><code>int sockfd</code>：Socket 文件描述符。</li><li><code>const void *buf</code>：指向要发送数据的缓冲区的指针。</li><li><code>size_t len</code>：要发送的数据长度。</li><li><code>int flags</code>：发送标志，如 <code>MSG_DONTROUTE</code>。</li></ul></li></ul><h3 id="7-recv"><a href="#7-recv" class="headerlink" title="7. recv()"></a>7. <code>recv()</code></h3><ul><li><strong>作用</strong>：从 Socket 接收数据。</li><li><strong>参数</strong>：<ul><li><code>int sockfd</code>：Socket 文件描述符。</li><li><code>void *buf</code>：接收数据的缓冲区。</li><li><code>size_t len</code>：缓冲区的大小。</li><li><code>int flags</code>：接收标志，如 <code>MSG_PEEK</code>。</li></ul></li></ul><h3 id="8-sendto"><a href="#8-sendto" class="headerlink" title="8. sendto()"></a>8. <code>sendto()</code></h3><ul><li><strong>作用</strong>：向特定地址发送数据，通常用于无连接的 Socket（如 UDP）。</li><li><strong>参数</strong>：与 <code>send()</code> 类似，额外包括目标地址和地址长度。</li></ul><h3 id="9-recvfrom"><a href="#9-recvfrom" class="headerlink" title="9. recvfrom()"></a>9. <code>recvfrom()</code></h3><ul><li><strong>作用</strong>：接收数据并返回源地址信息，通常用于无连接的 Socket（如 UDP）。</li><li><strong>参数</strong>：与 <code>recv()</code> 类似，额外包括源地址信息和地址长度。</li></ul><h3 id="10-close"><a href="#10-close" class="headerlink" title="10. close()"></a>10. <code>close()</code></h3><ul><li><strong>作用</strong>：关闭 Socket 文件描述符，释放资源。</li><li><strong>参数</strong>：<ul><li><code>int sockfd</code>：要关闭的 Socket 文件描述符。</li></ul></li></ul><h3 id="11-setsockopt"><a href="#11-setsockopt" class="headerlink" title="11. setsockopt()"></a>11. <code>setsockopt()</code></h3><ul><li><strong>作用</strong>：设置 Socket 的选项，如超时、重用地址等。</li><li><strong>参数</strong>：<ul><li><code>int sockfd</code>：Socket 文件描述符。</li><li><code>int level</code>：设置选项的级别，如 <code>SOL_SOCKET</code> 或 <code>IPPROTO_TCP</code>。</li><li><code>int optname</code>：选项名称。</li><li><code>const void *optval</code>：指向选项值的指针。</li><li><code>socklen_t optlen</code>：选项值的长度。</li></ul></li></ul><h3 id="12-getsockopt"><a href="#12-getsockopt" class="headerlink" title="12. getsockopt()"></a>12. <code>getsockopt()</code></h3><ul><li><strong>作用</strong>：获取 Socket 的选项。</li><li><strong>参数</strong>：与 <code>setsockopt()</code> 类似。</li></ul><h3 id="13-shutdown"><a href="#13-shutdown" class="headerlink" title="13. shutdown()"></a>13. <code>shutdown()</code></h3><ul><li><strong>作用</strong>：关闭 Socket 的读取或写入方向。</li><li><strong>参数</strong>：<ul><li><code>int sockfd</code>：Socket 文件描述符。</li><li><code>int how</code>：关闭的方向，如 <code>SHUT_RD</code>（读取方向）或 <code>SHUT_WR</code>（写入方向）。</li></ul></li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>使用 Socket 编程时，应确保正确处理错误情况，检查每个函数的返回值，并适当地处理任何错误代码。</li><li>对于某些函数，如 <code>send()</code> 和 <code>recv()</code>，如果在非阻塞模式下使用，可能需要处理 EAGAIN 或 EWOULDBLOCK 错误码，这表明操作无法立即完成。</li><li>在实际编程中，根据具体需求，可能还需要使用到其他函数，例如 <code>select()</code> 或 <code>poll()</code> 用于多路复用，或者 <code>fork()</code> 和 <code>exec()</code> 用于创建子进程处理连接。</li></ul><h2 id="TCP-socket通信流程"><a href="#TCP-socket通信流程" class="headerlink" title="TCP socket通信流程"></a>TCP socket通信流程</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2024/06/30/SPcvUQlrHe3F9ZI.png"                      alt="tcp-socket.png"                ></p><p>服务器端流程如下：</p><ol><li>创建服务器的<code>socket</code></li><li>初始化<code>sever_addr</code>(服务器地址)</li><li>将<code>socket</code>和<code>server_addr</code>绑定 bind</li><li>开始监听<code>listen</code></li><li>开一个循环保证服务器不会结束，不断的<code>accept</code>接入的客户端请求，进行读写操作<code>write</code>和<code>read</code> (send()和recv()也行)</li><li>关闭<code>socket</code></li></ol><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_PORT 10005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFLEN 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BACLOG 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新的socket，返回文件描述符</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">create_socket</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> res = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> 如果想要使用UDP协议，只需要将SOCK_STREAM改为SOCK_DGRAM即可</span></span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;create socket failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;create socket successfully\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化服务器地址信息</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initialize_address</span><span class="params">(<span class="keyword">struct</span> sockaddr_in *server_addr)</span> &#123;</span><br><span class="line">    <span class="built_in">memset</span>(server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(*server_addr));</span><br><span class="line">    server_addr-&gt;sin_family = AF_INET;</span><br><span class="line">    <span class="comment">// 监听所有可用地址</span></span><br><span class="line">    server_addr-&gt;sin_addr.s_addr = htons(INADDR_ANY);</span><br><span class="line">    server_addr-&gt;sin_port = htons(SERVER_PORT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定socket到指定的地址</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">try_bind</span><span class="params">(<span class="type">int</span> socket_fd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *server_addr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (bind(socket_fd, server_addr, <span class="keyword">sizeof</span>(*server_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;bind successfully&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理客户端请求</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">process_client_request</span><span class="params">(<span class="type">int</span> socket_client)</span> &#123;</span><br><span class="line">    <span class="type">char</span> send_buf[BUFFLEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span> recv_buf[BUFFLEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送的消息，以方便日后添加或修改</span></span><br><span class="line">    <span class="built_in">snprintf</span>(send_buf, BUFFLEN, <span class="string">&quot;Hello, this is the server&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">ssize_t</span> num_read = read(socket_client, recv_buf, BUFFLEN);</span><br><span class="line">        <span class="comment">// 客户端断开连接，或读取失败</span></span><br><span class="line">        <span class="keyword">if</span> (num_read &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num_read == <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;Client closed connection&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                perror(<span class="string">&quot;read failed&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        recv_buf[num_read] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 为接收的字符串添加结束字符</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;From Client: %s\n&quot;</span>, recv_buf);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strncmp</span>(recv_buf, <span class="string">&quot;exit&quot;</span>, <span class="number">4</span>) == <span class="number">0</span>) &#123; <span class="comment">// 客户端请求退出</span></span><br><span class="line">            <span class="comment">// 修改发送的消息</span></span><br><span class="line">            <span class="built_in">strcpy</span>(send_buf, <span class="string">&quot;bye!!!&quot;</span>);</span><br><span class="line">            <span class="comment">// 返回消息给客户端</span></span><br><span class="line">            write(socket_client, send_buf, <span class="built_in">strlen</span>(send_buf));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Me(Server)：%s\n&quot;</span>, send_buf);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向客户端写入发送缓冲区的内容</span></span><br><span class="line">        <span class="keyword">if</span> (write(socket_client, send_buf, <span class="built_in">strlen</span>(send_buf)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;write failed&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Me(Server): %s\n&quot;</span>, send_buf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清空接收缓冲区，准备下一次读取</span></span><br><span class="line">        <span class="built_in">memset</span>(recv_buf, <span class="number">0</span>, BUFFLEN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> socket_server = create_socket(); <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span> <span class="comment">// 声明地址结构</span></span><br><span class="line"></span><br><span class="line">    initialize_address(&amp;server_addr); <span class="comment">// 初始化地址结构</span></span><br><span class="line">    try_bind(socket_server, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr); <span class="comment">// 绑定地址到socket</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始监听连接请求，设定最大等待连接数量为BACLOG</span></span><br><span class="line">    <span class="keyword">if</span> (listen(socket_server, BACLOG) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;start listening&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> client_addr_size = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 初始化客户端地址结构</span></span><br><span class="line">        <span class="built_in">memset</span>(&amp;client_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(client_addr));</span><br><span class="line">        <span class="comment">// 接受新的连接请求</span></span><br><span class="line">        <span class="type">int</span> socket_client = accept(socket_server, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;client_addr_size);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Client %s:%d connected\n&quot;</span>,</span><br><span class="line">            inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));</span><br><span class="line">        <span class="keyword">if</span> (socket_client &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;receive failed&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 尝试接受另一个连接</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 满足要求后开始处理客户端请求</span></span><br><span class="line">        process_client_request(socket_client);</span><br><span class="line">        close(socket_client); <span class="comment">// 关闭客户端连接</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正常情况下不会执行到这一步</span></span><br><span class="line">    close(socket_server);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>客户端流程如下：</p><ol><li>创建客户端<code>socket</code></li><li>初始化<code>server_addr</code></li><li>连接到服务器<code>connect</code></li><li>利用<code>write</code>和<code>read</code>进行读写操作 (send()和recv()也行)</li><li>关闭<code>socket</code></li></ol><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_PORT 10005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFLEN 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建套接字并返回其文件描述符</span></span><br><span class="line"><span class="comment"> * 如果创建失败，程序将以状态1退出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">create_socket</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sock_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sock_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket创建失败&quot;</span>); <span class="comment">// 使用perror提供更多的错误信息</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;socket create successfully\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> sock_fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 初始化服务器地址结构的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initialize_address</span><span class="params">(<span class="keyword">struct</span> sockaddr_in *server_addr)</span> &#123;</span><br><span class="line">    <span class="built_in">memset</span>(server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(*server_addr));</span><br><span class="line">    server_addr-&gt;sin_family = AF_INET;</span><br><span class="line">    server_addr-&gt;sin_port = htons(SERVER_PORT);</span><br><span class="line">    server_addr-&gt;sin_addr.s_addr = inet_addr(<span class="string">&quot;192.168.5.120&quot;</span>); <span class="comment">// 服务器IP</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 建立到服务器的连接</span></span><br><span class="line"><span class="comment"> * 如果连接失败，程序将以状态1退出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">connect_to_server</span><span class="params">(<span class="type">int</span> socket_fd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *server_addr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (connect(socket_fd, server_addr, <span class="keyword">sizeof</span>(*server_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;connection failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connection successful\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 客户端程序开始的主函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> socket_fd = create_socket(); <span class="comment">// 创建socket</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    initialize_address(&amp;server_addr); <span class="comment">// 初始化服务器详细信息</span></span><br><span class="line"></span><br><span class="line">    connect_to_server(socket_fd, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr); <span class="comment">// 连接到服务器</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> send_buf[BUFFLEN] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 用于发送数据的缓冲区</span></span><br><span class="line">    <span class="type">char</span> recv_buf[BUFFLEN] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 用于接收数据的缓冲区</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 持续从用户获取输入并发送到服务器，直到从服务器接收到&quot;bye!!!&quot;</span></span><br><span class="line">    <span class="keyword">while</span> (fgets(send_buf, BUFFLEN, <span class="built_in">stdin</span>)) &#123;</span><br><span class="line">        <span class="comment">// 向服务器写入用户输入</span></span><br><span class="line">        <span class="keyword">if</span> (write(socket_fd, send_buf, strnlen(send_buf, BUFFLEN)) == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;write failed&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Me(Client):%s&quot;</span>, send_buf); <span class="comment">// 打印用户输入</span></span><br><span class="line">        <span class="built_in">memset</span>(send_buf, <span class="number">0</span>, BUFFLEN); <span class="comment">// 清除发送缓冲区</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取服务器的响应</span></span><br><span class="line">        <span class="keyword">if</span> (read(socket_fd, recv_buf, BUFFLEN) == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;receive failed&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Server:%s&quot;</span>, recv_buf); <span class="comment">// 打印服务器的响应</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(recv_buf, <span class="string">&quot;bye!!!&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(recv_buf, <span class="number">0</span>, BUFFLEN); <span class="comment">// 清除接收缓冲区</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(socket_fd); <span class="comment">// 关闭套接字</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;socket编程&quot;&gt;&lt;a href=&quot;#socket编程&quot; class=&quot;headerlink&quot; title=&quot;socket编程&quot;&gt;&lt;/a&gt;socket编程&lt;/h1&gt;&lt;h2 id=&quot;socket的概念&quot;&gt;&lt;a href=&quot;#socket的概念&quot; class=&quot;he</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="C/C++" scheme="http://example.com/tags/C-C/"/>
    
    <category term="网络编程" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    <category term="socket" scheme="http://example.com/tags/socket/"/>
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>python-grammar-1</title>
    <link href="http://example.com/2024/05/02/python-grammar-1/"/>
    <id>http://example.com/2024/05/02/python-grammar-1/</id>
    <published>2024-05-02T08:47:48.000Z</published>
    <updated>2024-11-08T02:21:34.892Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python-数据类型"><a href="#Python-数据类型" class="headerlink" title="Python 数据类型"></a>Python 数据类型</h1><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>在python中数字有三种类型：整数(int)、浮点数(float)、复数(complex)<br>我们可以使用<code>type()</code>函数来判断一个变量或值属于哪个类，还可以通过<code>instance()</code>函数来检查对象是否属于特定的类</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">checkType</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="built_in">print</span>(a, <span class="built_in">type</span>(a))</span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2.5</span></span><br><span class="line">c = <span class="number">1</span>+<span class="number">2j</span></span><br><span class="line"><span class="built_in">print</span>(c, <span class="string">&#x27;是复数吗？&#x27;</span>, <span class="built_in">isinstance</span>(c, <span class="built_in">complex</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">checkType(a)</span><br><span class="line">checkType(b)</span><br><span class="line">checkType(c)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote><p>input([prompt])</p></blockquote><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="built_in">input</span>(<span class="string">&#x27;Enter a number&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于默认是字符串，需要做类型转换</span></span><br><span class="line">a = (<span class="built_in">int</span>)(<span class="built_in">input</span>(<span class="string">&#x27;Enter an integer&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>列表中的项目允许不是同一类型。<br>我们可以使用<code>[]</code>运算符从列表中提取一个项目 或 一系列项目。注意，在Python中，索引从<code>0</code>开始。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">NOTE:</span> 声明</span></span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2.2</span>, <span class="string">&#x27;python&#x27;</span>]</span><br><span class="line">b = [<span class="number">5</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">20</span>, <span class="number">30</span> , <span class="number">50</span> , <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a[2]=&#x27;</span>, a[<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;b[4]=&#x27;</span>, b[<span class="number">4</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>元组和列表相同，但是元组中的元素是不可变的，元组一旦创建就不可修改</p><p>它在括号内 () 定义，其中各项之间用逗号分隔</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">NOTE:</span> 声明</span></span><br><span class="line"></span><br><span class="line">tup = (<span class="number">1</span> , <span class="string">&#x27;awdaw&#x27;</span>, <span class="number">12</span>);</span><br><span class="line"><span class="built_in">print</span>(tup)</span><br><span class="line"><span class="comment"># <span class="doctag">BUG:</span> tup[1] = 1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串和元组一样，其中的元素是不可变的</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">NOTE:</span> 声明</span></span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;awdawdwada&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;s[4]&quot;</span>, s[<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">BUG:</span> s[4] = 1</span></span><br></pre></td></tr></table></figure></div><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>Set 是唯一项的无序集合。Set 由用大括号 { } 括起来，并由逗号分隔的值的集合。集合中的项目是无序的</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">NOTE:</span> 声明</span></span><br><span class="line">s = &#123;<span class="number">5</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">3</span> ,<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;s =&#x27;</span>,s, <span class="built_in">type</span>(s))</span><br><span class="line"><span class="comment"># <span class="doctag">BUG:</span> s[2] = 2;</span></span><br></pre></td></tr></table></figure></div><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>类似哈希表，需要一个key和一个value，key是唯一的，value可以是任何类型。字典中的项目是无序的</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">NOTE:</span> 声明</span></span><br><span class="line">d = &#123;<span class="number">1</span>:<span class="string">&#x27;value&#x27;</span>, <span class="string">&#x27;key&#x27;</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(d, <span class="built_in">type</span>(d))</span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">NOTE:</span> 访问</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;d[&#x27;key&#x27;] = &quot;</span>, d[<span class="string">&#x27;key&#x27;</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="对象与类"><a href="#对象与类" class="headerlink" title="对象与类"></a>对象与类</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parrot</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 类属性</span></span><br><span class="line">    species = <span class="string">&#x27;bird&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Constructor</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name;</span><br><span class="line">        self.age = age;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Method</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">string</span>(<span class="params">self, song</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#125; song is &#123;&#125;&quot;</span>.<span class="built_in">format</span>(self.name, song)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dance</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#125; is now dancing&quot;</span>.<span class="built_in">format</span>(self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">blu = Parrot(<span class="string">&quot;麻雀&quot;</span>, <span class="number">10</span>)</span><br><span class="line">woo = Parrot(<span class="string">&quot;鹦鹉&quot;</span>, <span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;麻雀是 &#123;&#125;&quot;</span>.<span class="built_in">format</span>(blu.__class__.species))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;鹦鹉是 &#123;&#125;&quot;</span>.<span class="built_in">format</span>(woo.__class__.species))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;&#125; is &#123;&#125; old&quot;</span>.<span class="built_in">format</span>(blu.name, blu.age))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;&#125; is &#123;&#125; old&quot;</span>.<span class="built_in">format</span>(woo.name, woo.age))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>( blu.string(<span class="string">&quot;极乐净土&quot;</span>) )</span><br><span class="line"><span class="built_in">print</span>( blu.dance() )</span><br></pre></td></tr></table></figure></div><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><blockquote><p>可以使用<code>isinstance</code> 和 <code>issubclass</code> 来检查一个对象是该类的实例和是否是一个特定的类或者子类</p></blockquote><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Bird is ready&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">whoisThis</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Bird&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">swim</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Swimming faster&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Penguin</span>(<span class="title class_ inherited__">Bird</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># call super() function</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Penguin is ready&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">whoisThis</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Penguin&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Run faster&quot;</span>)</span><br><span class="line"></span><br><span class="line">peggy = Penguin()</span><br><span class="line">peggy.whoisThis()</span><br><span class="line">peggy.run()</span><br><span class="line">peggy.swim()</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="可封装性"><a href="#可封装性" class="headerlink" title="可封装性"></a>可封装性</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.__maxprice = <span class="number">900</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sell</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Price is: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(self.__maxprice))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setMaxPrice</span>(<span class="params">self, price</span>):</span><br><span class="line">        self.__maxprice = price</span><br><span class="line"></span><br><span class="line">c = Computer()</span><br><span class="line">c.sell()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Change price&quot;</span>)</span><br><span class="line">c.setMaxPrice(<span class="number">1000</span>)</span><br><span class="line">c.sell()</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parrot</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fly</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Parrot can fly&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">swim</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Parrot can&#x27;t swim&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Penguin</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fly</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Penguin can&#x27;t fly&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">swim</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Penguin can swim&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># universal method</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">flying_test</span>(<span class="params">bird</span>):</span><br><span class="line">    bird.fly()</span><br><span class="line"></span><br><span class="line">blu = Parrot()</span><br><span class="line">peggy = Penguin()</span><br><span class="line"></span><br><span class="line">flying_test(blu)</span><br><span class="line">flying_test(peggy)</span><br></pre></td></tr></table></figure></div><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><blockquote><p>通过在中实现特殊函数(__function_name__)</p></blockquote><table><thead><tr><th>运算符</th><th>表达</th><th>在内部</th></tr></thead><tbody><tr><td>+</td><td>p1 + p2</td><td>p1.__add__(p2)</td></tr><tr><td>-</td><td>p1 - p2</td><td>p1.__sub__(p2)</td></tr><tr><td>*</td><td>p1 * p2</td><td>p1.__mul__(p2)</td></tr><tr><td>求幂 **</td><td>p1 ** p2</td><td>p1.__pow__(p2)</td></tr><tr><td>相除 &#x2F;</td><td>p1 &#x2F; p2</td><td>p1.__truediv__(p2)</td></tr><tr><td>整除 &#x2F;&#x2F;</td><td>p1 &#x2F;&#x2F; p2</td><td>p1.__floordiv__(p2)</td></tr><tr><td>%</td><td>p1 % p2</td><td>p1.__mode__(p2)</td></tr><tr><td>&lt;&lt;</td><td>p1 &lt;&lt; p2</td><td>p1.__lshift__(p2)</td></tr><tr><td>&gt;&gt;</td><td>p1 &gt;&gt; p2</td><td>p1.__rshift__(p2)</td></tr><tr><td>and</td><td>p1 and p2</td><td>p1.__and__(p2)</td></tr><tr><td>or</td><td>p1 or p2</td><td>p1.__or__(p2)</td></tr><tr><td>^</td><td>p1 ^ p2</td><td>p1.__xor__(p2)</td></tr><tr><td>~</td><td>~p1</td><td>p1.__invert__()</td></tr><tr><td>&lt;</td><td>p1 &lt; p2</td><td>p1.__lt__(p2)</td></tr><tr><td>&gt;</td><td>p1 &gt; p2</td><td>p1.__gt__(p2)</td></tr><tr><td>&lt;&#x3D;</td><td>p1 &lt;&#x3D; p2</td><td>p1.__le__(p2)</td></tr><tr><td>&gt;&#x3D;</td><td>p1 &gt;&#x3D; p2</td><td>p1.__ge__(p2)</td></tr><tr><td>&#x3D;&#x3D;</td><td>p1 &#x3D;&#x3D; p2</td><td>p1.__eq__(p2)</td></tr><tr><td>!&#x3D;</td><td>p1 !&#x3D; p2</td><td>p1.__ne__(p2)</td></tr></tbody></table><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>Python中的Iterator只是一个可以迭代的对象。一个将返回数据的对象，一次返回一个元素。</p><p>自定类实现迭代器</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PowTwo</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, <span class="built_in">max</span> = <span class="number">0</span></span>):</span><br><span class="line">        self.<span class="built_in">max</span> = <span class="built_in">max</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        self.n = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.n &lt;= self.<span class="built_in">max</span>:</span><br><span class="line">            result = <span class="number">2</span> ** self.n</span><br><span class="line">            self.n += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = PowTwo(<span class="number">4</span>)</span><br><span class="line">i = <span class="built_in">iter</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(i))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> PowTwo(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Python-数据类型&quot;&gt;&lt;a href=&quot;#Python-数据类型&quot; class=&quot;headerlink&quot; title=&quot;Python 数据类型&quot;&gt;&lt;/a&gt;Python 数据类型&lt;/h1&gt;&lt;h2 id=&quot;数字&quot;&gt;&lt;a href=&quot;#数字&quot; class=&quot;head</summary>
      
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
</feed>
