<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++中的静态类型、动态类型、RTTI</title>
    <url>/2024/04/22/C-Data-Type/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文介绍了C++中的静态类型、动态类型、RTTI。</p>
<h2 id="静态类型"><a href="#静态类型" class="headerlink" title="静态类型"></a>静态类型</h2><p>C++ 是一种静态类型语言（static typing），这意味着类型检查是在编译时进行而非运行时。换句话说，每个变量、对象、函数返回值等在编译时都必须明确其类型。这种类型系统的主要优点是能够在程序运行之前发现类型不匹配等错误，从而提高代码的安全性和稳定性。</p>
<p>举一个例子</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">42</span>;        <span class="comment">// &#x27;num&#x27; 静态类型为int</span></span><br><span class="line">    <span class="type">double</span> pi = <span class="number">3.14159</span>; <span class="comment">// &#x27;pi&#x27; 静态类型为double</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// FIX: num = pi; 这种写法会造成编译错误，因为类型不匹配</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The value of num is: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The value of pi is: &quot;</span> &lt;&lt; pi &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="动态类型"><a href="#动态类型" class="headerlink" title="动态类型"></a>动态类型</h2><p>在C++这种静态类型语言中，通常所说的”dynamic typing”（动态类型）并不是内置的语言特性，因为C++要求变量在编译时就明确其类型。相对的，”dynamic typing”通常指的是在运行时能够处理多种不同类型的数据。在C++中实现类似动态类型的行为，通常是通过以下几种方式：</p>
<ol>
<li><p><strong>void指针</strong> ：void* 类型，这种方式通常称为”smart pointer”，它允许程序员在不担心对象的生存周期的情况下，指向任意对象，从而实现动态类型的支持，但使用它们往往需要手动管理类型和内存，同时要在使用前将其转换（强制类型转换）回正确的类型。</p>
</li>
<li><p><strong>多态</strong>：利用C++的多态特性，可以通过基类指针或引用来操作一组派生自同一基类的对象。这使得代码可以在运行时处理多种不同类型的对象，而不必在编译时知道具体的派生类型。</p>
</li>
<li><p><strong>任意类型</strong>： 通过使用<code>std::any</code>类型，你可以存放任何类型的值，并且在需要的时候通过<code>std::any_cast</code>来提取原始类型，这在某种程度上提供了动态类型的能力。</p>
</li>
</ol>
<p>举点例子：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;any&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_void_pointer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line">    <span class="type">float</span> y = <span class="number">3.14f</span>;</span><br><span class="line">    std::string z = <span class="string">&quot;hello world\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* void_ptr;</span><br><span class="line"></span><br><span class="line">    void_ptr = &amp;x;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;int_value: &quot;</span> &lt;&lt; *(<span class="built_in">static_cast</span>&lt;<span class="type">int</span>*&gt;(void_ptr)) &lt;&lt; std::endl;</span><br><span class="line">    void_ptr = &amp;y;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;double_value: &quot;</span> &lt;&lt; *(<span class="built_in">static_cast</span>&lt;<span class="type">double</span>*&gt;(void_ptr)) &lt;&lt; std::endl;</span><br><span class="line">    void_ptr = &amp;z;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;string_value: &quot;</span> &lt;&lt; *(<span class="built_in">static_cast</span>&lt;std::string*&gt;(void_ptr)) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_any</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::any any_value;</span><br><span class="line">    any_value = <span class="number">42</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;int_value: &quot;</span> &lt;&lt; std::<span class="built_in">any_cast</span>&lt;<span class="type">int</span>&gt;(any_value) &lt;&lt; std::endl;</span><br><span class="line">    any_value = <span class="number">3.14</span>;</span><br><span class="line">    std::cout &lt;&lt;<span class="string">&quot;double_value: &quot;</span> &lt;&lt; std::<span class="built_in">any_cast</span>&lt;<span class="type">double</span>&gt;(any_value) &lt;&lt; std::endl;</span><br><span class="line">    any_value = std::<span class="built_in">string</span>( <span class="string">&quot;awdawda&quot;</span> );</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;string_value: &quot;</span> &lt;&lt; std::<span class="built_in">any_cast</span>&lt;std::string&gt;(any_value) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test_void_pointer</span>();</span><br><span class="line">    <span class="built_in">test_any</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>需要注意的是，上面实例中的<code>void*</code>和<code>std::any</code>由于额外的类型检查和转换，会在运行时导致额外的性能开销。</p>
<h2 id="RTTI"><a href="#RTTI" class="headerlink" title="RTTI"></a>RTTI</h2><p>RTTI，即运行时类型信息（Run-Time Type Identification），是C++语言中的一个机制，它允许在程序运行时获取对象的类型信息。RTTI是面向对象编程中多态性的一个重要特性，它能够让我们在程序运行时确定对象的实际派生类型。</p>
<p>RTTI主要涉及以下两个操作符和一个类类型特性：</p>
<ol>
<li><p><strong>dynamic_cast</strong>: 用于安全地在继承体系中转换指针或引用。它是类型转换的一种，可以将基类的指针或引用转换为派生类的指针或引用，并在转换不安全的情况下提供错误检查。</p>
</li>
<li><p><strong>typeid</strong>: 当你对表达式使用typeid时，它会返回一个std::type_info对象的引用，该对象代表了表达式的类型。如果该表达式是一个多态类型（即含有虚函数的类）的对象，typeid会返回该对象的动态类型，也就是最派生的类型。</p>
</li>
<li><p><strong>std::type_info</strong>: 这是与<code>typeid</code>一起使用的标准库类，其对象包含了类型的信息，如类型的名称。它提供了比较两个类型是否相等的能力，即通过<code>type_info</code>的<code>operator==</code>来确定两个对象是否为同一类型。</p>
</li>
</ol>
<p>例子：</p>
<p>typeid:</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dummy</span><span class="params">()</span> </span>&#123;&#125; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* base_ptr = <span class="keyword">new</span> Derived;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Using typeid to get the type of the object</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Type: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(*base_ptr).<span class="built_in">name</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> base_ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>dynamic_cast:</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dummy</span><span class="params">()</span> </span>&#123;&#125; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived1</span> : <span class="keyword">public</span> Base &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived2</span> : <span class="keyword">public</span> Base &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* base_ptr = <span class="keyword">new</span> Derived1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Using dynamic_cast to safely downcast the pointer</span></span><br><span class="line">    Derived1* derived1_ptr = <span class="built_in">dynamic_cast</span>&lt;Derived1*&gt;(base_ptr);</span><br><span class="line">    <span class="keyword">if</span> (derived1_ptr) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Downcast to Derived1 successful\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Downcast to Derived1 failed\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Derived2* derived2_ptr = <span class="built_in">dynamic_cast</span>&lt;Derived2*&gt;(base_ptr);</span><br><span class="line">    <span class="keyword">if</span> (derived2_ptr) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Downcast to Derived2 successful\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Downcast to Derived2 failed\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> base_ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>RTTI通常用于实现某些需要类型检查的功能，尤其是那些与继承体系交互的场景。但是，也应当注意它可能会导致一些性能开销，因此程序设计时还应考虑是否有其他方式能够达到相同目的，如使用虚函数来实现多态，而不是依赖RTTI来进行类型判断。在使用RTTI时，请确保编译器的相应设置或选项已经开启，因为某些编译器可能允许关闭RTTI来减少程序的体积和提高性能。在这种情况下，RTTI相关的功能将不可用。</p>
<p>type_info:</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Base&gt; <span class="title">b</span><span class="params">(<span class="keyword">new</span> Base())</span></span>;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Derived&gt; <span class="title">d</span><span class="params">(<span class="keyword">new</span> Derived())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> std::type_info&amp; ti_b = <span class="built_in">typeid</span>(*b);</span><br><span class="line">    <span class="type">const</span> std::type_info&amp; ti_d = <span class="built_in">typeid</span>(*d);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Base class type: &quot;</span> &lt;&lt; ti_b.<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Derived class type: &quot;</span> &lt;&lt; ti_d.<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ti_b == ti_d) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The types are the same!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The types are different!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库设计规范</title>
    <url>/2024/09/15/DataBaseDesign/</url>
    <content><![CDATA[<h2 id="数据库范式"><a href="#数据库范式" class="headerlink" title="数据库范式"></a>数据库范式</h2><p>数据库范式是一套用于设计关系数据库的规范化标准，其目的是减少数据冗余并提高数据的完整性和一致性。范式化是一种将数据库表设计成符合一定级别的过程，每个级别称为一个范式。通过范式化，可以减少数据存储中的冗余，同时避免潜在的数据不一致问题。</p>
<p>数据库范式通常分为六个级别，其中最常用的是前三范式（1NF、2NF、3NF）：</p>
<h3 id="1-第一范式-1NF"><a href="#1-第一范式-1NF" class="headerlink" title="1. 第一范式 (1NF)"></a>1. 第一范式 (1NF)</h3><p>   第一范式要求表中的每一列都是不可分割的原子值，即每个单元格中只包含一个值。这确保了表中的每一列都是单一的事实，而不是列表或集合。例如，如果有一个“联系方式”列包含了电话号码和电子邮件地址，则这样的设计就不符合第一范式。</p>
<h4 id="不符合1NF的例子："><a href="#不符合1NF的例子：" class="headerlink" title="不符合1NF的例子："></a>不符合1NF的例子：</h4><p>假设我们有一个<code>学生</code>表，记录学生的姓名和他们所选的课程：</p>
<table>
<thead>
<tr>
<th>学号</th>
<th>姓名</th>
<th>课程</th>
</tr>
</thead>
<tbody><tr>
<td>S001</td>
<td>张三</td>
<td>数学, 物理</td>
</tr>
<tr>
<td>S002</td>
<td>李四</td>
<td>英语</td>
</tr>
</tbody></table>
<p>这个表不是1NF，因为“课程”这一列包含了多个值（数学和物理），而1NF要求每一列都应该是原子的，即不可再分。</p>
<h4 id="符合1NF的例子："><a href="#符合1NF的例子：" class="headerlink" title="符合1NF的例子："></a>符合1NF的例子：</h4><p>为了使上述表符合1NF，我们可以将其拆分成两个表：</p>
<ul>
<li><strong>学生表</strong>：</li>
</ul>
<table>
<thead>
<tr>
<th>学号</th>
<th>姓名</th>
</tr>
</thead>
<tbody><tr>
<td>S001</td>
<td>张三</td>
</tr>
<tr>
<td>S002</td>
<td>李四</td>
</tr>
</tbody></table>
<ul>
<li><strong>选课表</strong>：</li>
</ul>
<table>
<thead>
<tr>
<th>学号</th>
<th>课程</th>
</tr>
</thead>
<tbody><tr>
<td>S001</td>
<td>数学</td>
</tr>
<tr>
<td>S001</td>
<td>物理</td>
</tr>
<tr>
<td>S002</td>
<td>英语</td>
</tr>
</tbody></table>
<h3 id="2-第二范式-2NF"><a href="#2-第二范式-2NF" class="headerlink" title="2. 第二范式 (2NF)"></a>2. 第二范式 (2NF)</h3><p>   第二范式建立在第一范式的基础上，要求所有的非主键字段完全依赖于主键。这意味着表中的非主键字段不能部分依赖于主键的一部分。例如，如果主键是一个复合键，那么所有非主键字段都必须依赖于整个复合键，而不仅仅是部分主键。</p>
<h4 id="不符合2NF的例子："><a href="#不符合2NF的例子：" class="headerlink" title="不符合2NF的例子："></a>不符合2NF的例子：</h4><p>假设我们有一个<code>员工</code>表，记录员工的基本信息以及部门信息：</p>
<table>
<thead>
<tr>
<th>员工ID</th>
<th>名字</th>
<th>部门名称</th>
<th>部门地址</th>
</tr>
</thead>
<tbody><tr>
<td>E001</td>
<td>王五</td>
<td>销售</td>
<td>北京</td>
</tr>
<tr>
<td>E002</td>
<td>赵六</td>
<td>技术</td>
<td>上海</td>
</tr>
</tbody></table>
<p>这里的问题在于，部门名称和部门地址是依赖于部门的，而不是单独依赖于员工ID。如果部门信息发生变化，就需要在每个员工记录中更新，这样容易导致数据不一致。</p>
<h4 id="符合2NF的例子："><a href="#符合2NF的例子：" class="headerlink" title="符合2NF的例子："></a>符合2NF的例子：</h4><p>为了使上述表符合2NF，我们需要将部门信息提取出来：</p>
<ul>
<li><strong>员工表</strong>：</li>
</ul>
<table>
<thead>
<tr>
<th>员工ID</th>
<th>名字</th>
<th>部门ID</th>
</tr>
</thead>
<tbody><tr>
<td>E001</td>
<td>王五</td>
<td>D001</td>
</tr>
<tr>
<td>E002</td>
<td>赵六</td>
<td>D002</td>
</tr>
</tbody></table>
<ul>
<li><strong>部门表</strong>：</li>
</ul>
<table>
<thead>
<tr>
<th>部门ID</th>
<th>部门名称</th>
<th>部门地址</th>
</tr>
</thead>
<tbody><tr>
<td>D001</td>
<td>销售</td>
<td>北京</td>
</tr>
<tr>
<td>D002</td>
<td>技术</td>
<td>上海</td>
</tr>
</tbody></table>
<h3 id="3-第三范式-3NF"><a href="#3-第三范式-3NF" class="headerlink" title="3. 第三范式 (3NF)"></a>3. 第三范式 (3NF)</h3><p>   第三范式进一步加强了第二范式的要求，它要求所有非主键字段直接依赖于主键，而不是通过另一个非主键字段间接依赖于主键（即避免传递依赖）。例如，如果存在一个表，其中一个非主键字段依赖于另一个非主键字段，那么就需要将它们分离到不同的表中。</p>
<h4 id="不符合3NF的例子："><a href="#不符合3NF的例子：" class="headerlink" title="不符合3NF的例子："></a>不符合3NF的例子：</h4><p>考虑以下一个学生-课程-教师的示例：</p>
<table>
<thead>
<tr>
<th>学号</th>
<th>课程编号</th>
<th>教师编号</th>
<th>教师姓名</th>
</tr>
</thead>
<tbody><tr>
<td>S001</td>
<td>C001</td>
<td>T001</td>
<td>刘老师</td>
</tr>
<tr>
<td>S002</td>
<td>C002</td>
<td>T002</td>
<td>陈老师</td>
</tr>
</tbody></table>
<p>在这个表中，教师姓名直接与学生关联，而没有直接依赖于主键（学号），而是依赖于教师编号。这是一个传递依赖的例子，因此不符合3NF。</p>
<h4 id="符合3NF的例子："><a href="#符合3NF的例子：" class="headerlink" title="符合3NF的例子："></a>符合3NF的例子：</h4><p>为了使上述表符合3NF，我们需要创建一个新的教师表：</p>
<ul>
<li><strong>学生表</strong>：</li>
</ul>
<table>
<thead>
<tr>
<th>学号</th>
<th>课程编号</th>
<th>教师编号</th>
</tr>
</thead>
<tbody><tr>
<td>S001</td>
<td>C001</td>
<td>T001</td>
</tr>
<tr>
<td>S002</td>
<td>C002</td>
<td>T002</td>
</tr>
</tbody></table>
<ul>
<li><strong>教师表</strong>：</li>
</ul>
<table>
<thead>
<tr>
<th>教师编号</th>
<th>教师姓名</th>
</tr>
</thead>
<tbody><tr>
<td>T001</td>
<td>刘老师</td>
</tr>
<tr>
<td>T002</td>
<td>陈老师</td>
</tr>
</tbody></table>
<p>除了这三个主要的范式之外，还有更高层次的范式：</p>
<h3 id="4-BCNF-Boys-Codd范式"><a href="#4-BCNF-Boys-Codd范式" class="headerlink" title="4. BCNF (Boys-Codd范式)"></a>4. BCNF (Boys-Codd范式)</h3><p>   BCNF范式要求每个决定因素都是一个超键。这意味着除了主键之外，没有任何其他字段可以决定任何非键字段。</p>
<h4 id="不符合BCNF的例子："><a href="#不符合BCNF的例子：" class="headerlink" title="不符合BCNF的例子："></a>不符合BCNF的例子：</h4><p>假设我们有一个<code>图书作者</code>表，记录书籍的信息以及作者的信息：</p>
<table>
<thead>
<tr>
<th>图书ID</th>
<th>书名</th>
<th>作者ID</th>
<th>作者名</th>
<th>作者国籍</th>
</tr>
</thead>
<tbody><tr>
<td>B001</td>
<td>梦幻森林</td>
<td>A001</td>
<td>小明</td>
<td>中国</td>
</tr>
<tr>
<td>B002</td>
<td>星际旅行</td>
<td>A002</td>
<td>小红</td>
<td>美国</td>
</tr>
<tr>
<td>B003</td>
<td>梦幻森林</td>
<td>A001</td>
<td>小明</td>
<td>中国</td>
</tr>
</tbody></table>
<p>在这个表中，<code>作者名</code>和<code>作者国籍</code>依赖于<code>作者ID</code>，而不是直接依赖于<code>图书ID</code>。此外，如果我们只改变某本书的作者信息，那么所有包含该作者的记录都需要更新。这表明存在部分依赖（<code>作者名</code>和<code>作者国籍</code>依赖于<code>作者ID</code>）和传递依赖（<code>作者国籍</code>依赖于<code>作者ID</code>），这使得该表不符合BCNF的要求。</p>
<h4 id="符合BCNF的例子："><a href="#符合BCNF的例子：" class="headerlink" title="符合BCNF的例子："></a>符合BCNF的例子：</h4><p>为了使上述表符合BCNF，我们需要将作者信息分离到另一个表中：</p>
<ul>
<li><strong>图书表</strong>：</li>
</ul>
<table>
<thead>
<tr>
<th>图书ID</th>
<th>书名</th>
<th>作者ID</th>
</tr>
</thead>
<tbody><tr>
<td>B001</td>
<td>梦幻森林</td>
<td>A001</td>
</tr>
<tr>
<td>B002</td>
<td>星际旅行</td>
<td>A002</td>
</tr>
<tr>
<td>B003</td>
<td>梦幻森林</td>
<td>A001</td>
</tr>
</tbody></table>
<ul>
<li><strong>作者表</strong>：</li>
</ul>
<table>
<thead>
<tr>
<th>作者ID</th>
<th>作者名</th>
<th>作者国籍</th>
</tr>
</thead>
<tbody><tr>
<td>A001</td>
<td>小明</td>
<td>中国</td>
</tr>
<tr>
<td>A002</td>
<td>小红</td>
<td>美国</td>
</tr>
</tbody></table>
<p>现在，<code>图书表</code>中的每一项都是基于<code>图书ID</code>和<code>作者ID</code>这两个组合键，而<code>作者表</code>中的每一项都是基于<code>作者ID</code>。在这种情况下，没有任何非平凡函数依赖涉及非候选键的情况，因此这两个表都符合BCNF的要求。</p>
<h3 id="5-第四范式-4NF"><a href="#5-第四范式-4NF" class="headerlink" title="5. 第四范式 (4NF)"></a>5. 第四范式 (4NF)</h3><p>   第四范式是在BCNF的基础上进一步消除非平凡的多值依赖。</p>
<h3 id="6-第五范式-5NF-："><a href="#6-第五范式-5NF-：" class="headerlink" title="6. 第五范式 (5NF)："></a>6. 第五范式 (5NF)：</h3><p>   第五范式，也被称为完美范式或PJ范式，关注的是关系模式在连接操作后的数据一致性。</p>
<p>范式化的过程通常涉及到将数据分解成多个相互关联的表，以确保每个表都有一个明确的主题或目的，并且表中的每个字段都直接依赖于主键。虽然遵循范式可以带来许多好处，但在实际应用中，有时候为了提高查询性能或其他原因，可能会选择不完全遵循这些范式，而是采用一定程度的反范式化（denormalization）。</p>
<h2 id="关于键"><a href="#关于键" class="headerlink" title="关于键:"></a>关于键:</h2><ul>
<li>超键(super key): 在关系中能唯一标识元组的属性集称为关系模式的超键<br>只要含有“学号”或者“身份证号”两个属性的集合就叫超键，例如R1（学号 性别）、R2（身份证号 身高）、R3（学号 身份证号）等等都可以称为超键！</li>
<li>候选键(candidate key): 不含有多余属性的超键称为候选键。也就是在候选键中，若再删除属性，就不是键了！<br>不含有多余的属性的超键，比如（学号）、（身份证号）都是候选键，又比如R1中学号这一个属性就可以唯一标识元组了，而有没有性别这一属性对是否唯一标识元组没有任何的影响！</li>
<li>主键(primary key): 用户选作元组标识的一个候选键程序主键<br>就是用户从很多候选键选出来的一个键就是主键，比如你要求学号是主键，那么身份证号就不可以是主键了</li>
<li>外键(foreign key)：如果关系模式R中属性K是其它模式的主键，那么k在模式R中称为外键。<br> 宿舍号就是学生信息表的外键</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>QT信号和槽</title>
    <url>/2024/08/27/QT-Signal/</url>
    <content><![CDATA[<h2 id="信号和槽"><a href="#信号和槽" class="headerlink" title="信号和槽"></a>信号和槽</h2><p>当我们需要一个界面通知另一个界面时，可以采用信号和槽机制。通过链接信号和槽，当一个界面发送信号时，链接该信号的槽会被响应，从而达到消息传递的目的。</p>
<p>我们先创建两个界面并为两个界面添加一个按钮，通过按钮的点击来实现界面的切换</p>
<p>主界面</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/08/27/TqclI9soy68uCfh.png"
                      alt="mainpage.png"
                ></p>
<p>先实现主界面的点击按钮功能，并在终端打印一条信息”show child dialog”<br>现在MainWindow的构造函数中添加信号和槽的逻辑连接</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">connect</span>(ui-&gt;showChildButton, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">showChildDialog</span>()));</span><br></pre></td></tr></table></figure></div>

<p>然后在MainWindow的头文件中添加槽函数，槽函数需要<code>slots</code>声明</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showChildDialog</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></div>

<p>接下来实现该函数</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::showChildDialog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;show child dialog&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>子界面<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/08/27/TlR6VLyQp5HhzvN.png"
                      alt="subpage.png"
                ></p>
<h2 id="不同的连接方式"><a href="#不同的连接方式" class="headerlink" title="不同的连接方式"></a>不同的连接方式</h2><p>上面我们使用的是qt4的连接方式，用SIGNAL和SLOT将信号和槽转化为字符串。但是这种方式存在一个问题，qt要求槽函数的参数不能超过信号定义的参数，比如我们用到的信号clicked(bool)参数就是bool，我们定义的槽函数showChildDialog()参数是不带参数的，可以连接成功，如果我们在连接的时候将showChildDialog()的参数写成三个，也可以连接成功</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// qt4 style 连接信号和槽</span></span><br><span class="line"><span class="built_in">connect</span>(ui-&gt;showChildButton, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>(<span class="type">bool</span>)), <span class="built_in">SLOT</span>(<span class="built_in">showChildDialog</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)));</span><br></pre></td></tr></table></figure></div>

<p>但是点击会没有反应，说明qt4 这种连接信号和槽的方式不做编译检查，只是将信号和槽函数转译成字符串。</p>
<p>推荐qt5的连接方式</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">connect</span>(_child_dialog, &amp;ChildDialog::showMainSig, <span class="keyword">this</span>, &amp;MainWindow::showMainDialog);</span><br><span class="line"><span class="built_in">connect</span>(_child_dialog, &amp;ChildDialog::showMainSig, <span class="keyword">this</span>, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_child_dialog-&gt;<span class="built_in">hide</span>();</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<h2 id="实现界面切换"><a href="#实现界面切换" class="headerlink" title="实现界面切换"></a>实现界面切换</h2><p>在MainWindow类中，加入一个子界面类的指针，方便访问</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showChildDialog</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showMainDialog</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">    ChildDialog *_child_dialog;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>然后改写槽函数，当单击按钮时弹出对话框</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::showChildDialog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _child_dialog-&gt;<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">hide</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这么做有一个问题就是可能会重复创建子窗口，但是Qt的对象树机制会保证父窗口回收时才回收子窗口，所以关闭子窗口只是隐藏了。<br>那么随着点击，久而久之窗口会越来越多。<br>我们想到的一个避免重复创建的办法就是在MainWindow的构造函数里创建好子界面，在槽函数中只控制子界面的显示即可。<br>但同时要注意在MainWindow的析构函数里回收子界面类对象。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    _child_dialog = <span class="keyword">new</span> <span class="built_in">ChildDialog</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// qt4 style 连接信号和槽</span></span><br><span class="line">    <span class="comment">// connect(ui-&gt;showChildButton, SIGNAL(clicked(bool)), SLOT(showChildDialog()));</span></span><br><span class="line">    <span class="comment">// qt5 style(recommend)</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;showChildButton, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;MainWindow::showChildDialog);</span><br><span class="line">    <span class="comment">// connect(_child_dialog, &amp;ChildDialog::showMainSig, this, &amp;MainWindow::showMainDialog);</span></span><br><span class="line">    <span class="built_in">connect</span>(_child_dialog, &amp;ChildDialog::showMainSig, <span class="keyword">this</span>, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_child_dialog-&gt;<span class="built_in">hide</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">show</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">    <span class="keyword">if</span> (_child_dialog != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> _child_dialog;</span><br><span class="line">        _child_dialog = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这样我们频繁点击显示子界面按钮就不会重复创建窗口了。<br>那接下来实现点击主界面的按钮，显示子界面，并隐藏主窗口。<br>实现点击子界面的按钮，显示主窗口，并隐藏子界面。<br>先实现点击子界面按钮显示主窗口，我们可以在ChildDialog类修改下构造函数，使其接受一个QWidget指针，这个指针指向父窗口也就是MainWindow.<br>我们新增成员_parent用来存储MainWindow。<br>新增槽函数showMainWindow用来显示主窗口。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ChildDialog</span> : <span class="keyword">public</span> QDialog</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showMainSig</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ChildDialog</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    ~<span class="built_in">ChildDialog</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showMainWindow</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::ChildDialog *ui;</span><br><span class="line">    QWidget *_parent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>实现槽函数</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChildDialog::showMainWindow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">hide</span>();</span><br><span class="line">    <span class="function">emit <span class="title">showMainSig</span><span class="params">()</span></span>; <span class="comment">//发出信号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在MainWindow连接这个信号</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    _child_dialog = <span class="keyword">new</span> <span class="built_in">ChildDialog</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// qt4 style 连接信号和槽</span></span><br><span class="line">    <span class="comment">// connect(ui-&gt;showChildButton, SIGNAL(clicked(bool)), SLOT(showChildDialog()));</span></span><br><span class="line">    <span class="comment">// qt5 style(recommend)</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;showChildButton, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;MainWindow::showChildDialog);</span><br><span class="line">    <span class="comment">// connect(_child_dialog, &amp;ChildDialog::showMainSig, this, &amp;MainWindow::showMainDialog);</span></span><br><span class="line">    <span class="built_in">connect</span>(_child_dialog, &amp;ChildDialog::showMainSig, <span class="keyword">this</span>, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_child_dialog-&gt;<span class="built_in">hide</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">show</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="连接信号"><a href="#连接信号" class="headerlink" title="连接信号"></a>连接信号</h3><p>上面的程序还可以进一步优化，因为Qt提供了信号连接信号的方式，也就是说我们可以把子界面的按钮点击信号和showMainSig信号连接起来。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">ChildDialog::<span class="built_in">ChildDialog</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QDialog</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::ChildDialog)</span><br><span class="line">    , _parent(parent)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;showMainWindow, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;ChildDialog::showMainSig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>将clicked和showMainSig两个信号连接起来，也可以实现消息的传递。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL事务</title>
    <url>/2024/09/22/SQLEvent/</url>
    <content><![CDATA[<p>在SQL中，事务（Transaction）是一组数据库操作的逻辑单元，这些操作要么全部成功执行，要么全部不执行。事务的主要目的是确保数据库的一致性和完整性，尤其是在并发访问和系统故障的情况下。</p>
<h3 id="事务的基本概念"><a href="#事务的基本概念" class="headerlink" title="事务的基本概念"></a>事务的基本概念</h3><ol>
<li><p><strong>事务的特性（ACID）</strong>:</p>
<ul>
<li><strong>原子性（Atomicity）</strong>: 事务中的所有操作要么全部成功执行，要么全部不执行。如果事务中的任何一个操作失败，整个事务都会回滚到初始状态。</li>
<li><strong>一致性（Consistency）</strong>: 事务执行前后，数据库必须保持一致性状态。事务不能违反数据库的完整性约束。</li>
<li><strong>隔离性（Isolation）</strong>: 并发执行的多个事务之间是相互隔离的，一个事务的执行不能被其他事务干扰。</li>
<li><strong>持久性（Durability）</strong>: 一旦事务成功提交，其结果将永久保存在数据库中，即使系统发生故障也不会丢失。</li>
</ul>
</li>
<li><p><strong>事务的控制语句</strong>:</p>
<ul>
<li><strong>BEGIN TRANSACTION</strong>: 开始一个事务。</li>
<li><strong>COMMIT</strong>: 提交事务，将所有操作永久保存到数据库中。</li>
<li><strong>ROLLBACK</strong>: 回滚事务，撤销所有未提交的操作。</li>
<li><strong>SAVEPOINT</strong>: 在事务中设置保存点，可以在回滚时只回滚到保存点。</li>
</ul>
</li>
</ol>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>; #开始事务</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="keyword">ROLLBACK</span>; #回滚事务</span><br><span class="line"><span class="keyword">SAVEPOINT</span> 回滚点; #添加回滚点</span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> 回滚点; # 回到指定回滚点</span><br><span class="line">...</span><br><span class="line"><span class="keyword">COMMIT</span>; #提交事务</span><br><span class="line"><span class="comment">-- 一旦提交，就无法进行回滚</span></span><br></pre></td></tr></table></figure></div>


<h3 id="事务的实例"><a href="#事务的实例" class="headerlink" title="事务的实例"></a>事务的实例</h3><p>假设我们有一个银行账户表 <code>accounts</code>，我们希望实现一个转账操作，从一个账户转钱到另一个账户。为了确保转账操作的原子性和一致性，我们需要使用事务。</p>
<h4 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a>表结构</h4><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> accounts (</span><br><span class="line">    account_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    balance <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<h4 id="插入初始数据"><a href="#插入初始数据" class="headerlink" title="插入初始数据"></a>插入初始数据</h4><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> accounts (account_id, balance) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1000.00</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> accounts (account_id, balance) <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="number">500.00</span>);</span><br></pre></td></tr></table></figure></div>

<h4 id="转账操作"><a href="#转账操作" class="headerlink" title="转账操作"></a>转账操作</h4><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 从账户1转出500元</span></span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">500.00</span> <span class="keyword">WHERE</span> account_id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 向账户2转入500元</span></span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">500.00</span> <span class="keyword">WHERE</span> account_id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 检查账户1的余额是否足够</span></span><br><span class="line">IF (<span class="keyword">SELECT</span> balance <span class="keyword">FROM</span> accounts <span class="keyword">WHERE</span> account_id <span class="operator">=</span> <span class="number">1</span>) <span class="operator">&lt;</span> <span class="number">0</span> <span class="keyword">THEN</span></span><br><span class="line">    <span class="keyword">ROLLBACK</span>;  <span class="comment">-- 如果余额不足，回滚事务</span></span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line">    <span class="keyword">COMMIT</span>;    <span class="comment">-- 否则，提交事务</span></span><br><span class="line"><span class="keyword">END</span> IF;</span><br></pre></td></tr></table></figure></div>

<p>在这个例子中，我们使用事务来确保转账操作的原子性。如果账户1的余额不足，事务将回滚，撤销所有的操作；否则，事务将提交，转账操作成功完成。</p>
<h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><p>SQL标准定义了四种事务隔离级别，用于控制并发事务之间的相互影响：</p>
<ol>
<li><strong>读未提交（Read Uncommitted）</strong>: 允许一个事务读取另一个事务未提交的数据。可能会导致脏读、不可重复读和幻读。</li>
<li><strong>读已提交（Read Committed）</strong>: 允许一个事务读取另一个事务已提交的数据。可以避免脏读，但可能会导致不可重复读和幻读。</li>
<li><strong>可重复读（Repeatable Read）</strong>: 确保一个事务在执行期间多次读取同一数据时，结果是一致的。可以避免脏读和不可重复读，但可能会导致幻读。</li>
<li><strong>串行化（Serializable）</strong>: 最高的隔离级别，确保事务串行执行，完全避免脏读、不可重复读和幻读。</li>
</ol>
<h4 id="设置隔离级别"><a href="#设置隔离级别" class="headerlink" title="设置隔离级别"></a>设置隔离级别</h4><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br></pre></td></tr></table></figure></div>

<h3 id="事务的使用场景"><a href="#事务的使用场景" class="headerlink" title="事务的使用场景"></a>事务的使用场景</h3><ol>
<li><p><strong>银行转账</strong>:</p>
<ul>
<li>确保从一个账户转钱到另一个账户的操作是原子的，要么全部成功，要么全部失败。</li>
</ul>
</li>
<li><p><strong>订单处理</strong>:</p>
<ul>
<li>确保订单的创建、库存的更新和支付的处理是原子的，避免出现订单创建成功但库存未更新的情况。</li>
</ul>
</li>
<li><p><strong>数据一致性</strong>:</p>
<ul>
<li>确保多个相关操作的一致性，例如在插入新记录时，同时更新相关统计信息。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL索引</title>
    <url>/2024/09/22/SQLIndex/</url>
    <content><![CDATA[<p>在SQL中，索引是一种数据结构，用于加速数据库表中数据的检索速度。索引类似于书籍的目录，可以帮助数据库系统快速定位到存储在表中的特定数据行，而不必扫描整个表。索引对于提高查询性能非常重要，尤其是在处理大型数据集时。</p>
<h3 id="索引的基本概念"><a href="#索引的基本概念" class="headerlink" title="索引的基本概念"></a>索引的基本概念</h3><ol>
<li><p><strong>索引的类型</strong>:</p>
<ul>
<li><strong>B-Tree 索引</strong>: 这是最常见的索引类型，适用于范围查询和排序操作。B-Tree（平衡树）索引能够保持数据的有序性，并且支持高效的插入、删除和查找操作。</li>
<li><strong>哈希索引</strong>: 适用于等值查询，但不支持范围查询。哈希索引通过哈希函数将索引键映射到存储位置，查询速度非常快，但不适合排序操作。</li>
<li><strong>全文索引</strong>: 用于全文搜索，支持对文本数据进行高效的搜索。</li>
<li><strong>空间索引</strong>: 用于地理空间数据，支持空间查询操作。</li>
</ul>
</li>
<li><p><strong>索引的创建</strong>:</p>
<ul>
<li>使用 <code>CREATE INDEX</code> 语句创建索引。例如：<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_name <span class="keyword">ON</span> table_name (column_name);</span><br></pre></td></tr></table></figure></div></li>
<li>可以为一个或多个列创建索引。例如：<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_name <span class="keyword">ON</span> table_name (column1, column2);</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li><p><strong>索引的优点</strong>:</p>
<ul>
<li><strong>提高查询速度</strong>: 索引可以显著减少查询所需的时间，尤其是在大型表中。</li>
<li><strong>加速排序和分组操作</strong>: 索引可以加速 <code>ORDER BY</code> 和 <code>GROUP BY</code> 操作。</li>
<li><strong>唯一性约束</strong>: 索引可以用于强制列的唯一性，例如 <code>UNIQUE</code> 索引。</li>
</ul>
</li>
<li><p><strong>索引的缺点</strong>:</p>
<ul>
<li><strong>增加存储空间</strong>: 索引需要额外的存储空间。</li>
<li><strong>降低写操作的速度</strong>: 插入、更新和删除操作需要更新索引，因此会降低这些操作的速度。</li>
<li><strong>维护成本</strong>: 索引需要定期维护，以确保其有效性。</li>
</ul>
</li>
</ol>
<h3 id="索引的使用场景"><a href="#索引的使用场景" class="headerlink" title="索引的使用场景"></a>索引的使用场景</h3><ol>
<li><p><strong>主键索引</strong>:</p>
<ul>
<li>每个表通常都有一个主键索引，用于唯一标识表中的每一行。主键索引通常是唯一的，并且是自增的。</li>
<li>例如：<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li><p><strong>唯一索引</strong>:</p>
<ul>
<li>用于确保列中的值是唯一的。</li>
<li>例如：<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX idx_email <span class="keyword">ON</span> employees (email);</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li><p><strong>复合索引</strong>:</p>
<ul>
<li>在多个列上创建的索引，适用于多列查询。</li>
<li>例如：<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_name_department <span class="keyword">ON</span> employees (name, department);</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li><p><strong>全文索引</strong>:</p>
<ul>
<li>用于全文搜索，适用于文本数据。</li>
<li>例如：<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> FULLTEXT INDEX idx_content <span class="keyword">ON</span> articles (content);</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
</ol>
<h3 id="索引的维护"><a href="#索引的维护" class="headerlink" title="索引的维护"></a>索引的维护</h3><ol>
<li><p><strong>重建索引</strong>:</p>
<ul>
<li>当索引变得碎片化时，可以通过重建索引来提高性能。</li>
<li>例如：<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> INDEX idx_name <span class="keyword">ON</span> table_name REBUILD;</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li><p><strong>删除索引</strong>:</p>
<ul>
<li>如果不再需要某个索引，可以将其删除以节省存储空间。</li>
<li>例如：<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX idx_name <span class="keyword">ON</span> table_name;</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL语句</title>
    <url>/2024/09/17/SQLGRammar/</url>
    <content><![CDATA[<h2 id="数据库定义语言-DDL"><a href="#数据库定义语言-DDL" class="headerlink" title="数据库定义语言(DDL)"></a>数据库定义语言(DDL)</h2><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database <span class="operator">&lt;</span>database_name<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>为了支持中文，我们需要在创建的时候可以修改编码格式</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="operator">&lt;</span>database_name<span class="operator">&gt;</span> <span class="keyword">DEFAULT</span> CHARSET utf8 <span class="keyword">COLLATE</span> utf8_general_ci</span><br></pre></td></tr></table></figure></div>

<h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span>(列名 数据类型[列级约束条件],</span><br><span class="line">                          列名 数据类型[列级约束条件],</span><br><span class="line">                          ...</span><br><span class="line">                          [, 表级约束条件])</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="SQL数据类型"><a href="#SQL数据类型" class="headerlink" title="SQL数据类型"></a>SQL数据类型</h3><h4 id="数值类型-Numeric-Types"><a href="#数值类型-Numeric-Types" class="headerlink" title="数值类型 (Numeric Types)"></a>数值类型 (Numeric Types)</h4><ol>
<li><p><strong>整数类型</strong>：</p>
<ul>
<li><code>TINYINT</code>: 存储很小的整数，通常范围是 <code>-128</code> 到 <code>127</code>。</li>
<li><code>SMALLINT</code>: 存储较小的整数，通常范围是 <code>-32768</code> 到 <code>32767</code>。</li>
<li><code>MEDIUMINT</code>: MySQL 特有的类型，适合存储中等大小的整数。</li>
<li><code>INT</code> 或 <code>INTEGER</code>: 存储普通大小的整数，通常范围是 <code>-2147483648</code> 到 <code>2147483647</code>。</li>
<li><code>BIGINT</code>: 存储非常大的整数，通常范围是 <code>-9223372036854775808</code> 到 <code>9223372036854775807</code>。</li>
<li><code>UNSIGNED</code>: 以上整数类型可以加上此属性以存储非负整数，范围从 <code>0</code> 开始。</li>
</ul>
</li>
<li><p><strong>小数类型</strong>：</p>
<ul>
<li><code>DECIMAL</code> 或 <code>NUMERIC</code>: 用于存储精确的小数，格式为 <code>DECIMAL(M, D)</code>，其中 <code>M</code> 是数字总长度，<code>D</code> 是小数点后的位数。</li>
<li><code>FLOAT</code>: 用于存储浮点数，可能丢失精度。</li>
<li><code>DOUBLE</code> 或 <code>REAL</code>: 用于存储更高精度的浮点数。</li>
</ul>
</li>
<li><p><strong>位类型</strong>：</p>
<ul>
<li><code>BIT</code>: 用于存储位字段值。</li>
</ul>
</li>
</ol>
<h4 id="字符串类型-String-Types"><a href="#字符串类型-String-Types" class="headerlink" title="字符串类型 (String Types)"></a>字符串类型 (String Types)</h4><ol>
<li><p><strong>定长字符串</strong>：</p>
<ul>
<li><code>CHAR(n)</code>: 存储定长的字符串，其中 <code>n</code> 是字符串的最大长度。如果输入的字符串长度不够，会用空格填充。</li>
</ul>
</li>
<li><p><strong>变长字符串</strong>：</p>
<ul>
<li><code>VARCHAR(n)</code>: 存储变长的字符串，其中 <code>n</code> 是字符串的最大长度。</li>
<li><code>BINARY(n)</code> 和 <code>VARBINARY(n)</code>: 分别存储定长和变长的二进制字符串。</li>
</ul>
</li>
<li><p><strong>大对象类型</strong>：</p>
<ul>
<li><code>TEXT</code>: 用于存储较大的文本数据。</li>
<li><code>BLOB</code>: 用于存储较大的二进制数据。</li>
<li><code>MEDIUMTEXT</code> 和 <code>MEDIUMBLOB</code>: MySQL 特有的类型，用于存储中等大小的文本或二进制数据。</li>
<li><code>LONGTEXT</code> 和 <code>LONGBLOB</code>: MySQL 特有的类型，用于存储非常大的文本或二进制数据。</li>
</ul>
</li>
</ol>
<h4 id="日期-时间类型-Date-Time-Types"><a href="#日期-时间类型-Date-Time-Types" class="headerlink" title="日期&#x2F;时间类型 (Date&#x2F;Time Types)"></a>日期&#x2F;时间类型 (Date&#x2F;Time Types)</h4><ol>
<li><p><strong>日期类型</strong>：</p>
<ul>
<li><code>DATE</code>: 存储日期值。</li>
<li><code>TIME</code>: 存储时间值。</li>
<li><code>YEAR</code>: MySQL 特有的类型，用于存储四位数的年份。</li>
</ul>
</li>
<li><p><strong>日期时间类型</strong>：</p>
<ul>
<li><code>DATETIME</code>: 存储日期和时间值，支持的范围通常是 <code>1000-01-01 00:00:00</code> 至 <code>9999-12-31 23:59:59</code>。</li>
<li><code>TIMESTAMP</code>: 存储日期和时间值，并且在插入或更新时可以自动设置为当前的日期和时间。</li>
<li><code>INTERVAL</code>: PostgreSQL 特有的类型，用于存储时间间隔。</li>
</ul>
</li>
</ol>
<h4 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h4><ol>
<li><p><strong>枚举类型</strong>：</p>
<ul>
<li><code>ENUM(&#39;value1&#39;, &#39;value2&#39;, ... )</code>: 存储一系列预先定义的值中的一个。</li>
</ul>
</li>
<li><p><strong>集合类型</strong>：</p>
<ul>
<li><code>SET(&#39;value1&#39;, &#39;value2&#39;, ... )</code>: 存储一系列预先定义的值中的一个或多个值。</li>
</ul>
</li>
<li><p><strong>JSON 类型</strong>：</p>
<ul>
<li><code>JSON</code>: MySQL 8.0 之后支持的类型，用于存储 JSON 文档。</li>
</ul>
</li>
<li><p><strong>空间类型</strong>：</p>
<ul>
<li><code>POINT</code>, <code>LINESTRING</code>, <code>POLYGON</code>, <code>MULTIPOINT</code>, <code>MULTILINESTRING</code>, <code>MULTIPOLYGON</code>, <code>GEOMETRYCOLLECTION</code>: 用于存储地理空间数据。</li>
</ul>
</li>
</ol>
<h3 id="列级约束条件"><a href="#列级约束条件" class="headerlink" title="列级约束条件"></a>列级约束条件</h3><p>有六种:主键(Primary Key),非空(NotNull)&#x2F;空值null, 默认(Default),外键(外键约束),唯一键(Unique Key),检查约束(Check)(MySql不支持)、默认Default。</p>
<h3 id="表级约束条件"><a href="#表级约束条件" class="headerlink" title="表级约束条件"></a>表级约束条件</h3><p>有四种：主键、外键、唯一、检查</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">CONSTRAINT</span> <span class="operator">&lt;</span>外键名<span class="operator">&gt;</span>] <span class="keyword">FOREIGN</span> KEY 字段名 [..., 字段名<span class="number">2</span>, ...] <span class="keyword">REFERENCES</span> <span class="operator">&lt;</span>主表名<span class="operator">&gt;</span> 主键列<span class="number">1</span> [, 主键列<span class="number">2</span>, ...]</span><br></pre></td></tr></table></figure></div>

<p>现在来创建三个表</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> study(sid <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> name <span class="type">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> sex ENUM(<span class="string">&#x27;male&#x27;</span>, <span class="string">&#x27;female&#x27;</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;male&#x27;</span>);</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> teacher(tid <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> name <span class="type">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> teach (</span><br><span class="line">    tid <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    sid <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> f_tid <span class="keyword">FOREIGN</span> KEY (tid) <span class="keyword">REFERENCES</span> teacher(tid)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- mysql&gt; CREATE TABLE teach(tid int not null, sid int not null);</span></span><br><span class="line"><span class="comment">-- mysql&gt; ALTER TABLE teach</span></span><br><span class="line"><span class="comment">--     -&gt; ADD CONSTRAINT f_tid</span></span><br><span class="line"><span class="comment">--     -&gt; FOREIGN KEY(tid)</span></span><br><span class="line"><span class="comment">--     -&gt; REFERENCES teacher(tid);</span></span><br></pre></td></tr></table></figure></div>

<h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><p>如果我们想要修改表结构，可以通过<code>alter table</code>进行修改</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名[<span class="keyword">ADD</span> 新列名 数据类型[列级约束条件]]</span><br><span class="line">                [<span class="keyword">DROP</span> <span class="keyword">COLUMN</span> 列名[restrict<span class="operator">|</span>cascade]]</span><br><span class="line">                [<span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> 列名 数据类型]</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> 表名[restrict<span class="operator">|</span>cascade]</span><br></pre></td></tr></table></figure></div>

<h2 id="数据库操作语言-DML"><a href="#数据库操作语言-DML" class="headerlink" title="数据库操作语言(DML)"></a>数据库操作语言(DML)</h2><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 <span class="keyword">VALUES</span>(值<span class="number">1</span>, 值<span class="number">2</span>, ...)</span><br></pre></td></tr></table></figure></div>

<p>如果插入的数据与列一一对应，那么可以省略列名，但是如果希望向指定列上插入数据，就需要给出列名</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名(列名<span class="number">1</span>, 列名<span class="number">2</span>, ...) <span class="keyword">VALUES</span>(值<span class="number">1</span>, 值<span class="number">2</span>, ...)</span><br></pre></td></tr></table></figure></div>

<p>也可以一次性向数据库中插入多条数据</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名(列名<span class="number">1</span>, 列名<span class="number">2</span>, ...) <span class="keyword">VALUES</span>(值<span class="number">1</span>, 值<span class="number">2</span>, ...), (值<span class="number">1</span>, 值<span class="number">2</span>, ...)</span><br></pre></td></tr></table></figure></div>

<h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> 表名 <span class="keyword">SET</span> 列名 <span class="operator">=</span> 值, 列名 <span class="operator">=</span> 值, ... <span class="keyword">WHERE</span> 条件</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>注意，SQL语句中等于判断是<code>=</code></p>
</blockquote>
<pre><code>如果忘记加where来限定条件，那么将使得整个表的数据都被修改
</code></pre>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>删除全部数据</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名</span><br></pre></td></tr></table></figure></div>

<p>删除指定数据</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件</span><br></pre></td></tr></table></figure></div>

<h2 id="数据库查询语言DQL"><a href="#数据库查询语言DQL" class="headerlink" title="数据库查询语言DQL"></a>数据库查询语言DQL</h2><h3 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h3><p>只需要在一张表中查找数据，使用<code>select</code>语句即可</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">-- 指定查询某一列数据</span></span><br><span class="line"><span class="keyword">SELECT</span> 列名[, 列名] <span class="keyword">FROM</span> 表名</span><br><span class="line"><span class="comment">-- 会以别名来显示此列</span></span><br><span class="line"><span class="keyword">SELECT</span> 列名 <span class="keyword">AS</span> 别名 <span class="keyword">FROM</span> 表名</span><br><span class="line"><span class="comment">-- 查询所有列的数据</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名</span><br><span class="line"><span class="comment">-- 只查询不重复的值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 列名 <span class="keyword">FROM</span> 表名</span><br><span class="line"><span class="comment">-- 使用where来限定条件</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="常用查询条件"><a href="#常用查询条件" class="headerlink" title="常用查询条件"></a>常用查询条件</h3><ul>
<li>一般的比较运算符<code>=, &gt;, &lt;, &lt;=, &gt;=, !=</code></li>
<li>是否会在集合中<code>in, not in</code></li>
<li>字符模糊匹配<code>like, not like</code></li>
<li>多重条件连接查询<code>and, or, not</code></li>
</ul>
<h3 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 列名 <span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span></span><br></pre></td></tr></table></figure></div>

<p>ASC 升序 DESC 降序 默认为升序</p>
<p>添加多个排序</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 列名<span class="number">1</span> <span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>, 列名<span class="number">2</span> <span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span></span><br></pre></td></tr></table></figure></div>

<p>会先按照列名1进行排序，再按照列名2进行排序</p>
<h3 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h3><p>SQL 中的聚集函数（Aggregate Functions）用于对一组值执行计算，并返回单个值。这些函数通常用于对表中的数据进行汇总和分析。以下是一些常见的 SQL 聚集函数：</p>
<h4 id="1-COUNT"><a href="#1-COUNT" class="headerlink" title="1. COUNT()"></a>1. <code>COUNT()</code></h4><ul>
<li><strong>用途</strong>：计算表中行的数量或满足特定条件的行的数量。</li>
<li><strong>示例</strong>：<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> employees;  <span class="comment">-- 计算 employees 表中的总行数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> department) <span class="keyword">FROM</span> employees;  <span class="comment">-- 计算 employees 表中不同部门的数量</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="2-SUM"><a href="#2-SUM" class="headerlink" title="2. SUM()"></a>2. <code>SUM()</code></h4><ul>
<li><strong>用途</strong>：计算某一列值的总和。</li>
<li><strong>示例</strong>：<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(salary) <span class="keyword">FROM</span> employees;  <span class="comment">-- 计算 employees 表中所有员工的总工资</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="3-AVG"><a href="#3-AVG" class="headerlink" title="3. AVG()"></a>3. <code>AVG()</code></h4><ul>
<li><strong>用途</strong>：计算某一列值的平均值。</li>
<li><strong>示例</strong>：<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">FROM</span> employees;  <span class="comment">-- 计算 employees 表中所有员工的平均工资</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="4-MIN"><a href="#4-MIN" class="headerlink" title="4. MIN()"></a>4. <code>MIN()</code></h4><ul>
<li><strong>用途</strong>：返回某一列的最小值。</li>
<li><strong>示例</strong>：<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(salary) <span class="keyword">FROM</span> employees;  <span class="comment">-- 返回 employees 表中最低的工资</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="5-MAX"><a href="#5-MAX" class="headerlink" title="5. MAX()"></a>5. <code>MAX()</code></h4><ul>
<li><strong>用途</strong>：返回某一列的最大值。</li>
<li><strong>示例</strong>：<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(salary) <span class="keyword">FROM</span> employees;  <span class="comment">-- 返回 employees 表中最高的工资</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="6-GROUP-CONCAT"><a href="#6-GROUP-CONCAT" class="headerlink" title="6. GROUP_CONCAT()"></a>6. <code>GROUP_CONCAT()</code></h4><ul>
<li><strong>用途</strong>：将某一列的值连接成一个字符串，通常用于将分组后的值合并。</li>
<li><strong>示例</strong>：<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department, GROUP_CONCAT(name) <span class="keyword">FROM</span> employees <span class="keyword">GROUP</span> <span class="keyword">BY</span> department;  <span class="comment">-- 将每个部门的员工名字连接成一个字符串</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="7-VARIANCE-和-STDDEV"><a href="#7-VARIANCE-和-STDDEV" class="headerlink" title="7. VARIANCE() 和 STDDEV()"></a>7. <code>VARIANCE()</code> 和 <code>STDDEV()</code></h4><ul>
<li><strong>用途</strong>：计算某一列值的方差和标准差。</li>
<li><strong>示例</strong>：<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> VARIANCE(salary) <span class="keyword">FROM</span> employees;  <span class="comment">-- 计算 employees 表中工资的方差</span></span><br><span class="line"><span class="keyword">SELECT</span> STDDEV(salary) <span class="keyword">FROM</span> employees;  <span class="comment">-- 计算 employees 表中工资的标准差</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="8-BIT-AND-BIT-OR-BIT-XOR"><a href="#8-BIT-AND-BIT-OR-BIT-XOR" class="headerlink" title="8. BIT_AND(), BIT_OR(), BIT_XOR()"></a>8. <code>BIT_AND()</code>, <code>BIT_OR()</code>, <code>BIT_XOR()</code></h4><ul>
<li><strong>用途</strong>：对某一列的值执行按位与、按位或、按位异或操作。</li>
<li><strong>示例</strong>：<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> BIT_AND(flags) <span class="keyword">FROM</span> employees;  <span class="comment">-- 对 employees 表中的 flags 列执行按位与操作</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="使用聚集函数的注意事项："><a href="#使用聚集函数的注意事项：" class="headerlink" title="使用聚集函数的注意事项："></a>使用聚集函数的注意事项：</h4><ul>
<li><strong>NULL 值</strong>：聚集函数通常会忽略 <code>NULL</code> 值。例如，<code>SUM()</code> 函数不会将 <code>NULL</code> 值计入总和。</li>
<li><strong>GROUP BY 子句</strong>：聚集函数通常与 <code>GROUP BY</code> 子句一起使用，以便对数据进行分组并计算每个组的汇总值。</li>
<li><strong>HAVING 子句</strong>：用于过滤分组后的结果，通常与 <code>GROUP BY</code> 子句一起使用。</li>
</ul>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department, <span class="built_in">AVG</span>(salary) <span class="keyword">AS</span> avg_salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">AVG</span>(salary) <span class="operator">&gt;</span> <span class="number">50000</span>;</span><br></pre></td></tr></table></figure></div>

<p>这个查询会计算每个部门的平均工资，并只返回平均工资大于 50000 的部门。</p>
<h3 id="分组分页查询"><a href="#分组分页查询" class="headerlink" title="分组分页查询"></a>分组分页查询</h3><p>通过<code>group by</code>来对查询结果进行分组，需要结合聚集函数一起使用</p>
<p>在 MySQL 中，分组分页查询通常涉及使用 <code>GROUP BY</code> 子句对数据进行分组，然后使用 <code>LIMIT</code> 子句对结果进行分页。以下是详细解释和示例：</p>
<h4 id="1-GROUP-BY-子句"><a href="#1-GROUP-BY-子句" class="headerlink" title="1. GROUP BY 子句"></a>1. <code>GROUP BY</code> 子句</h4><p><code>GROUP BY</code> 子句用于将数据按照一个或多个列进行分组。通常与聚集函数（如 <code>COUNT</code>, <code>SUM</code>, <code>AVG</code>, <code>MIN</code>, <code>MAX</code> 等）一起使用，以便对每个组进行汇总计算。</p>
<h4 id="2-LIMIT-子句"><a href="#2-LIMIT-子句" class="headerlink" title="2. LIMIT 子句"></a>2. <code>LIMIT</code> 子句</h4><p><code>LIMIT</code> 子句用于限制查询结果的行数。通常用于分页查询，通过指定起始行和返回的行数来实现分页。</p>
<h4 id="示例：分组分页查询"><a href="#示例：分组分页查询" class="headerlink" title="示例：分组分页查询"></a>示例：分组分页查询</h4><p>假设我们有一个 <code>orders</code> 表，结构如下：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> orders (</span><br><span class="line">    order_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    customer_id <span class="type">INT</span>,</span><br><span class="line">    order_date <span class="type">DATE</span>,</span><br><span class="line">    amount <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<p>我们希望按 <code>customer_id</code> 分组，并计算每个客户的订单总金额，然后对结果进行分页。</p>
<h4 id="查询每个客户的订单总金额"><a href="#查询每个客户的订单总金额" class="headerlink" title="查询每个客户的订单总金额"></a>查询每个客户的订单总金额</h4><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customer_id, <span class="built_in">SUM</span>(amount) <span class="keyword">AS</span> total_amount</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> customer_id;</span><br></pre></td></tr></table></figure></div>

<h4 id="分页查询每个客户的订单总金额"><a href="#分页查询每个客户的订单总金额" class="headerlink" title="分页查询每个客户的订单总金额"></a>分页查询每个客户的订单总金额</h4><p>假设我们希望每页显示 10 个客户，查询第 2 页的数据（即第 11 到第 20 个客户）：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customer_id, <span class="built_in">SUM</span>(amount) <span class="keyword">AS</span> total_amount</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> customer_id</span><br><span class="line">LIMIT <span class="number">10</span> <span class="keyword">OFFSET</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure></div>

<h4 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h4><ul>
<li>**<code>LIMIT 10 OFFSET 10</code>**：<ul>
<li><code>LIMIT 10</code> 表示每页显示 10 行。</li>
<li><code>OFFSET 10</code> 表示从第 11 行开始（因为 <code>OFFSET</code> 是从 0 开始计数的）。</li>
<li><code>LIMIT 起始位置, 数量</code></li>
</ul>
</li>
</ul>
<h4 id="使用变量进行分页"><a href="#使用变量进行分页" class="headerlink" title="使用变量进行分页"></a>使用变量进行分页</h4><p>如果你希望动态地指定页码和每页的行数，可以使用变量：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="variable">@page_number</span> <span class="operator">=</span> <span class="number">2</span>;  <span class="comment">-- 页码，从 1 开始</span></span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@page_size</span> <span class="operator">=</span> <span class="number">10</span>;   <span class="comment">-- 每页的行数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> customer_id, <span class="built_in">SUM</span>(amount) <span class="keyword">AS</span> total_amount</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> customer_id</span><br><span class="line">LIMIT <span class="variable">@page_size</span> <span class="keyword">OFFSET</span> ((<span class="variable">@page_number</span> <span class="operator">-</span> <span class="number">1</span>) <span class="operator">*</span> <span class="variable">@page_size</span>);</span><br></pre></td></tr></table></figure></div>

<h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><ol>
<li><strong>性能问题</strong>：分组和分页查询可能会影响性能，尤其是在处理大量数据时。可以考虑使用索引来优化查询。</li>
<li><strong><code>HAVING</code> 子句</strong>：如果你需要在分组后对结果进行过滤，可以使用 <code>HAVING</code> 子句。例如，只显示订单总金额大于 1000 的客户：<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customer_id, <span class="built_in">SUM</span>(amount) <span class="keyword">AS</span> total_amount</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> customer_id</span><br><span class="line"><span class="keyword">HAVING</span> total_amount <span class="operator">&gt;</span> <span class="number">1000</span></span><br><span class="line">LIMIT <span class="number">10</span> <span class="keyword">OFFSET</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><p>多表查询是同时查询两个或两个以上的表，多表查询会通过连接转换为单表查询</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表<span class="number">1</span>, 表<span class="number">2</span></span><br></pre></td></tr></table></figure></div>

<p>直接这样查询会得到两张笛卡尔积，也就是每一项数据和另一张表的每一项数据都结合一次，会产生庞大的数据</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表<span class="number">1</span>, 表<span class="number">2</span> <span class="keyword">WHERE</span> 条件</span><br></pre></td></tr></table></figure></div>

<p>这样只会从笛卡尔积的结果中得到满足条件的数据</p>
<h3 id="自身连接查询"><a href="#自身连接查询" class="headerlink" title="自身连接查询"></a>自身连接查询</h3><p>自身连接就是将表自身和表进行笛卡尔积计算，得到结果，但是由于表名相同，因此要先起一个别名</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">AS</span> t1, 表<span class="number">1</span> <span class="keyword">AS</span> t2</span><br></pre></td></tr></table></figure></div>

<h3 id="外连接查询"><a href="#外连接查询" class="headerlink" title="外连接查询"></a>外连接查询</h3><p>SQL 中的外连接（Outer Join）用于从两个或多个表中获取数据，即使某些行在连接条件中没有匹配的行。外连接分为三种类型：左外连接（Left Outer Join）、右外连接（Right Outer Join）和全外连接（Full Outer Join）。  </p>
<p>假设我们现在有一张存储所有用户的表，还有一张用户详细信息的表，我们希望将这两张表结合到一起来查看完整数据</p>
<h4 id="1-左外连接（Left-Outer-Join）"><a href="#1-左外连接（Left-Outer-Join）" class="headerlink" title="1. 左外连接（Left Outer Join）"></a>1. 左外连接（Left Outer Join）</h4><p>左外连接返回左表中的所有行，即使右表中没有匹配的行。如果右表中没有匹配的行，结果集中对应右表的列将为 <code>NULL</code>。</p>
<h5 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h5><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> columns</span><br><span class="line"><span class="keyword">FROM</span> left_table</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> right_table</span><br><span class="line"><span class="keyword">ON</span> left_table.column <span class="operator">=</span> right_table.column;</span><br></pre></td></tr></table></figure></div>

<h5 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h5><p>假设有两个表 <code>employees</code> 和 <code>departments</code>：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees (</span><br><span class="line">    employee_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    employee_name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    department_id <span class="type">INT</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> departments (</span><br><span class="line">    department_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    department_name <span class="type">VARCHAR</span>(<span class="number">100</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<p>我们希望获取所有员工及其所属部门的信息，包括那些没有部门的员工：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employees.employee_name, departments.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments</span><br><span class="line"><span class="keyword">ON</span> employees.department_id <span class="operator">=</span> departments.department_id;</span><br></pre></td></tr></table></figure></div>

<h4 id="2-右外连接（Right-Outer-Join）"><a href="#2-右外连接（Right-Outer-Join）" class="headerlink" title="2. 右外连接（Right Outer Join）"></a>2. 右外连接（Right Outer Join）</h4><p>右外连接返回右表中的所有行，即使左表中没有匹配的行。如果左表中没有匹配的行，结果集中对应左表的列将为 <code>NULL</code>。</p>
<h5 id="语法：-1"><a href="#语法：-1" class="headerlink" title="语法："></a>语法：</h5><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> columns</span><br><span class="line"><span class="keyword">FROM</span> left_table</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> right_table</span><br><span class="line"><span class="keyword">ON</span> left_table.column <span class="operator">=</span> right_table.column;</span><br></pre></td></tr></table></figure></div>

<h5 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h5><p>我们希望获取所有部门及其员工的信息，包括那些没有员工的部门：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employees.employee_name, departments.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments</span><br><span class="line"><span class="keyword">ON</span> employees.department_id <span class="operator">=</span> departments.department_id;</span><br></pre></td></tr></table></figure></div>

<h4 id="3-全外连接（Full-Outer-Join）"><a href="#3-全外连接（Full-Outer-Join）" class="headerlink" title="3. 全外连接（Full Outer Join）"></a>3. 全外连接（Full Outer Join）</h4><p>全外连接返回左表和右表中的所有行，即使它们在连接条件中没有匹配的行。如果某个表中没有匹配的行，结果集中对应另一个表的列将为 <code>NULL</code>。</p>
<h5 id="语法：-2"><a href="#语法：-2" class="headerlink" title="语法："></a>语法：</h5><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> columns</span><br><span class="line"><span class="keyword">FROM</span> left_table</span><br><span class="line"><span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> right_table</span><br><span class="line"><span class="keyword">ON</span> left_table.column <span class="operator">=</span> right_table.column;</span><br></pre></td></tr></table></figure></div>

<h5 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h5><p>我们希望获取所有员工和所有部门的信息，包括那些没有部门或没有员工的记录：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employees.employee_name, departments.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> departments</span><br><span class="line"><span class="keyword">ON</span> employees.department_id <span class="operator">=</span> departments.department_id;</span><br></pre></td></tr></table></figure></div>

<h4 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a>注意事项：</h4><ul>
<li><strong>MySQL 不支持全外连接</strong>：MySQL 不直接支持 <code>FULL OUTER JOIN</code>，但可以通过 <code>UNION</code> 操作符来模拟全外连接。</li>
<li><strong>模拟全外连接</strong>：<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employees.employee_name, departments.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments</span><br><span class="line"><span class="keyword">ON</span> employees.department_id <span class="operator">=</span> departments.department_id</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> employees.employee_name, departments.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments</span><br><span class="line"><span class="keyword">ON</span> employees.department_id <span class="operator">=</span> departments.department_id;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>外连接允许你从两个或多个表中获取数据，即使某些行在连接条件中没有匹配的行。左外连接返回左表中的所有行，右外连接返回右表中的所有行，全外连接返回两个表中的所有行。通过合理使用外连接，你可以更灵活地处理数据关联和缺失情况。</p>
<h3 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h3><p>可以将查询的结果作为另一个查询的条件</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 列名 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> 列名 <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件);</span><br></pre></td></tr></table></figure></div>


<p>SQL 中的嵌套查询（Nested Query），也称为子查询（Subquery），是指在一个查询语句中嵌套另一个查询语句。子查询可以出现在 <code>SELECT</code>、<code>FROM</code>、<code>WHERE</code>、<code>HAVING</code> 等子句中，用于从数据库中获取更复杂的数据。</p>
<h4 id="1-子查询的基本概念"><a href="#1-子查询的基本概念" class="headerlink" title="1. 子查询的基本概念"></a>1. 子查询的基本概念</h4><p>子查询是一个完整的 <code>SELECT</code> 语句，它可以返回一个标量值（单个值）、一个行、一个列或一个表。子查询通常用括号 <code>()</code> 括起来，并且可以嵌套在主查询的各个部分。</p>
<h4 id="2-子查询的类型"><a href="#2-子查询的类型" class="headerlink" title="2. 子查询的类型"></a>2. 子查询的类型</h4><p>根据子查询返回的结果类型，子查询可以分为以下几种类型：</p>
<h5 id="2-1-标量子查询（Scalar-Subquery）"><a href="#2-1-标量子查询（Scalar-Subquery）" class="headerlink" title="2.1 标量子查询（Scalar Subquery）"></a>2.1 标量子查询（Scalar Subquery）</h5><p>标量子查询返回单个值（即一行一列）。它通常用于 <code>SELECT</code> 子句、<code>WHERE</code> 子句或 <code>HAVING</code> 子句中。</p>
<h6 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h6><p>假设我们有一个 <code>employees</code> 表和一个 <code>departments</code> 表，我们希望查询每个员工的姓名及其所属部门的名称：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_name,</span><br><span class="line">       (<span class="keyword">SELECT</span> department_name</span><br><span class="line">        <span class="keyword">FROM</span> departments</span><br><span class="line">        <span class="keyword">WHERE</span> departments.department_id <span class="operator">=</span> employees.department_id) <span class="keyword">AS</span> department_name</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure></div>

<h5 id="2-2-行子查询（Row-Subquery）"><a href="#2-2-行子查询（Row-Subquery）" class="headerlink" title="2.2 行子查询（Row Subquery）"></a>2.2 行子查询（Row Subquery）</h5><p>行子查询返回一行数据（即多列）。它通常用于 <code>WHERE</code> 子句中。</p>
<h6 id="示例：-5"><a href="#示例：-5" class="headerlink" title="示例："></a>示例：</h6><p>假设我们希望查询工资最高的员工的姓名和工资：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_name, salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> (salary, employee_id) <span class="operator">=</span> (<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(salary), employee_id</span><br><span class="line">                               <span class="keyword">FROM</span> employees);</span><br></pre></td></tr></table></figure></div>

<h5 id="2-3-列子查询（Column-Subquery）"><a href="#2-3-列子查询（Column-Subquery）" class="headerlink" title="2.3 列子查询（Column Subquery）"></a>2.3 列子查询（Column Subquery）</h5><p>列子查询返回一列数据（即多行一列）。它通常用于 <code>WHERE</code> 子句中。</p>
<h6 id="示例：-6"><a href="#示例：-6" class="headerlink" title="示例："></a>示例：</h6><p>假设我们希望查询所有工资高于平均工资的员工：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_name, salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">FROM</span> employees);</span><br></pre></td></tr></table></figure></div>

<h5 id="2-4-表子查询（Table-Subquery）"><a href="#2-4-表子查询（Table-Subquery）" class="headerlink" title="2.4 表子查询（Table Subquery）"></a>2.4 表子查询（Table Subquery）</h5><p>表子查询返回一个表（即多行多列）。它通常用于 <code>FROM</code> 子句中。</p>
<h6 id="示例：-7"><a href="#示例：-7" class="headerlink" title="示例："></a>示例：</h6><p>假设我们希望查询每个部门的平均工资，并按平均工资排序：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_name, avg_salary</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> department_id, <span class="built_in">AVG</span>(salary) <span class="keyword">AS</span> avg_salary</span><br><span class="line">      <span class="keyword">FROM</span> employees</span><br><span class="line">      <span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id) <span class="keyword">AS</span> dept_avg</span><br><span class="line"><span class="keyword">JOIN</span> departments <span class="keyword">ON</span> dept_avg.department_id <span class="operator">=</span> departments.department_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> avg_salary <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></div>

<h4 id="3-子查询的位置"><a href="#3-子查询的位置" class="headerlink" title="3. 子查询的位置"></a>3. 子查询的位置</h4><p>子查询可以出现在以下位置：</p>
<h5 id="3-1-SELECT-子句"><a href="#3-1-SELECT-子句" class="headerlink" title="3.1 SELECT 子句"></a>3.1 <code>SELECT</code> 子句</h5><p>子查询可以出现在 <code>SELECT</code> 子句中，用于计算每个行的特定值。</p>
<h6 id="示例：-8"><a href="#示例：-8" class="headerlink" title="示例："></a>示例：</h6><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_name,</span><br><span class="line">       salary,</span><br><span class="line">       (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">FROM</span> employees) <span class="keyword">AS</span> avg_salary</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure></div>

<h5 id="3-2-FROM-子句"><a href="#3-2-FROM-子句" class="headerlink" title="3.2 FROM 子句"></a>3.2 <code>FROM</code> 子句</h5><p>子查询可以出现在 <code>FROM</code> 子句中，用于生成一个临时表，供主查询使用。</p>
<h6 id="示例：-9"><a href="#示例：-9" class="headerlink" title="示例："></a>示例：</h6><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_name, avg_salary</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> department_id, <span class="built_in">AVG</span>(salary) <span class="keyword">AS</span> avg_salary</span><br><span class="line">      <span class="keyword">FROM</span> employees</span><br><span class="line">      <span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id) <span class="keyword">AS</span> dept_avg</span><br><span class="line"><span class="keyword">JOIN</span> departments <span class="keyword">ON</span> dept_avg.department_id <span class="operator">=</span> departments.department_id;</span><br></pre></td></tr></table></figure></div>

<h5 id="3-3-WHERE-子句"><a href="#3-3-WHERE-子句" class="headerlink" title="3.3 WHERE 子句"></a>3.3 <code>WHERE</code> 子句</h5><p>子查询可以出现在 <code>WHERE</code> 子句中，用于过滤数据。</p>
<h6 id="示例：-10"><a href="#示例：-10" class="headerlink" title="示例："></a>示例：</h6><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_name, salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">FROM</span> employees);</span><br></pre></td></tr></table></figure></div>

<h5 id="3-4-HAVING-子句"><a href="#3-4-HAVING-子句" class="headerlink" title="3.4 HAVING 子句"></a>3.4 <code>HAVING</code> 子句</h5><p>子查询可以出现在 <code>HAVING</code> 子句中，用于过滤分组后的数据。</p>
<h6 id="示例：-11"><a href="#示例：-11" class="headerlink" title="示例："></a>示例：</h6><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id, <span class="built_in">AVG</span>(salary) <span class="keyword">AS</span> avg_salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">AVG</span>(salary) <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">FROM</span> employees);</span><br></pre></td></tr></table></figure></div>

<h4 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4. 注意事项"></a>4. 注意事项</h4><ul>
<li><strong>性能问题</strong>：嵌套查询可能会影响性能，尤其是在处理大量数据时。可以考虑使用连接（Join）或其他优化方法来替代嵌套查询。</li>
<li><strong>相关子查询</strong>：相关子查询是指子查询依赖于外部查询的值。相关子查询通常会导致性能问题，因为它们会对外部查询的每一行执行一次子查询。</li>
</ul>
<h3 id="数据库控制语言DCL"><a href="#数据库控制语言DCL" class="headerlink" title="数据库控制语言DCL"></a>数据库控制语言DCL</h3><h4 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h4><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="operator">&lt;</span>username<span class="operator">&gt;</span> IDENTIFIED <span class="keyword">BY</span> <span class="operator">&lt;</span>password<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>也可以不带密码</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="operator">&lt;</span>username<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></div>

<h4 id="登录用户"><a href="#登录用户" class="headerlink" title="登录用户"></a>登录用户</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -u &lt;username&gt; -p &lt;password&gt;</span><br></pre></td></tr></table></figure></div>

<h3 id="用户授权"><a href="#用户授权" class="headerlink" title="用户授权"></a>用户授权</h3><h4 id="1-GRANT"><a href="#1-GRANT" class="headerlink" title="1. GRANT"></a>1. <code>GRANT</code></h4><p><code>GRANT</code> 命令用于授予用户或角色对数据库对象（如表、视图、存储过程等）的访问权限。</p>
<h5 id="语法：-3"><a href="#语法：-3" class="headerlink" title="语法："></a>语法：</h5><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> privileges <span class="keyword">ON</span> object <span class="keyword">TO</span> user_or_role;</span><br></pre></td></tr></table></figure></div>

<h5 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h5><ul>
<li><code>privileges</code>：要授予的权限，可以是 <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, <code>ALL PRIVILEGES</code> 等。</li>
<li><code>object</code>：要授予权限的数据库对象，如表、视图、存储过程等。</li>
<li><code>user_or_role</code>：要授予权限的用户或角色。</li>
</ul>
<h5 id="示例：-12"><a href="#示例：-12" class="headerlink" title="示例："></a>示例：</h5><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 授予用户 &#x27;alice&#x27; 对表 &#x27;employees&#x27; 的 SELECT 权限</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> employees <span class="keyword">TO</span> alice;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 授予用户 &#x27;bob&#x27; 对表 &#x27;employees&#x27; 的所有权限</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> employees <span class="keyword">TO</span> bob;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 授予角色 &#x27;developers&#x27; 对数据库 &#x27;mydb&#x27; 的所有权限</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> DATABASE mydb <span class="keyword">TO</span> developers;</span><br></pre></td></tr></table></figure></div>

<h4 id="2-REVOKE"><a href="#2-REVOKE" class="headerlink" title="2. REVOKE"></a>2. <code>REVOKE</code></h4><p><code>REVOKE</code> 命令用于撤销用户或角色对数据库对象的访问权限。</p>
<h5 id="语法：-4"><a href="#语法：-4" class="headerlink" title="语法："></a>语法：</h5><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> privileges <span class="keyword">ON</span> object <span class="keyword">FROM</span> user_or_role;</span><br></pre></td></tr></table></figure></div>

<h5 id="参数说明：-1"><a href="#参数说明：-1" class="headerlink" title="参数说明："></a>参数说明：</h5><ul>
<li>**<code>privileges</code>**：要撤销的权限，可以是 <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, <code>ALL PRIVILEGES</code> 等。</li>
<li>**<code>object</code>**：要撤销权限的数据库对象，如表、视图、存储过程等。</li>
<li>**<code>user_or_role</code>**：要撤销权限的用户或角色。</li>
</ul>
<h5 id="示例：-13"><a href="#示例：-13" class="headerlink" title="示例："></a>示例：</h5><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 撤销用户 &#x27;alice&#x27; 对表 &#x27;employees&#x27; 的 SELECT 权限</span></span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> employees <span class="keyword">FROM</span> alice;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 撤销用户 &#x27;bob&#x27; 对表 &#x27;employees&#x27; 的所有权限</span></span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> employees <span class="keyword">FROM</span> bob;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 撤销角色 &#x27;developers&#x27; 对数据库 &#x27;mydb&#x27; 的所有权限</span></span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> DATABASE mydb <span class="keyword">FROM</span> developers;</span><br></pre></td></tr></table></figure></div>

<h4 id="3-DENY"><a href="#3-DENY" class="headerlink" title="3. DENY"></a>3. <code>DENY</code></h4><p><code>DENY</code> 命令用于显式拒绝用户或角色对数据库对象的访问权限。与 <code>REVOKE</code> 不同，<code>DENY</code> 会阻止用户通过角色或其他方式继承权限。</p>
<h5 id="语法：-5"><a href="#语法：-5" class="headerlink" title="语法："></a>语法：</h5><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">DENY privileges <span class="keyword">ON</span> object <span class="keyword">TO</span> user_or_role;</span><br></pre></td></tr></table></figure></div>

<h5 id="参数说明：-2"><a href="#参数说明：-2" class="headerlink" title="参数说明："></a>参数说明：</h5><ul>
<li>**<code>privileges</code>**：要拒绝的权限，可以是 <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, <code>ALL PRIVILEGES</code> 等。</li>
<li>**<code>object</code>**：要拒绝权限的数据库对象，如表、视图、存储过程等。</li>
<li>**<code>user_or_role</code>**：要拒绝权限的用户或角色。</li>
</ul>
<h5 id="示例：-14"><a href="#示例：-14" class="headerlink" title="示例："></a>示例：</h5><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 拒绝用户 &#x27;alice&#x27; 对表 &#x27;employees&#x27; 的 SELECT 权限</span></span><br><span class="line">DENY <span class="keyword">SELECT</span> <span class="keyword">ON</span> employees <span class="keyword">TO</span> alice;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 拒绝用户 &#x27;bob&#x27; 对表 &#x27;employees&#x27; 的所有权限</span></span><br><span class="line">DENY <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> employees <span class="keyword">TO</span> bob;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 拒绝角色 &#x27;developers&#x27; 对数据库 &#x27;mydb&#x27; 的所有权限</span></span><br><span class="line">DENY <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> DATABASE mydb <span class="keyword">TO</span> developers;</span><br></pre></td></tr></table></figure></div>

<h4 id="4-CREATE-ROLE-和-DROP-ROLE"><a href="#4-CREATE-ROLE-和-DROP-ROLE" class="headerlink" title="4. CREATE ROLE 和 DROP ROLE"></a>4. <code>CREATE ROLE</code> 和 <code>DROP ROLE</code></h4><p><code>CREATE ROLE</code> 和 <code>DROP ROLE</code> 命令用于创建和删除角色。角色是一组权限的集合，可以授予用户或其他角色。</p>
<h5 id="语法：-6"><a href="#语法：-6" class="headerlink" title="语法："></a>语法：</h5><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> ROLE role_name;</span><br><span class="line"><span class="keyword">DROP</span> ROLE role_name;</span><br></pre></td></tr></table></figure></div>

<h5 id="示例：-15"><a href="#示例：-15" class="headerlink" title="示例："></a>示例：</h5><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建一个名为 &#x27;developers&#x27; 的角色</span></span><br><span class="line"><span class="keyword">CREATE</span> ROLE developers;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除名为 &#x27;developers&#x27; 的角色</span></span><br><span class="line"><span class="keyword">DROP</span> ROLE developers;</span><br></pre></td></tr></table></figure></div>

<h4 id="5-ALTER-ROLE"><a href="#5-ALTER-ROLE" class="headerlink" title="5. ALTER ROLE"></a>5. <code>ALTER ROLE</code></h4><p><code>ALTER ROLE</code> 命令用于修改角色的属性，如重命名角色、修改角色的默认配置等。</p>
<h5 id="语法：-7"><a href="#语法：-7" class="headerlink" title="语法："></a>语法：</h5><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> ROLE role_name <span class="keyword">WITH</span> options;</span><br></pre></td></tr></table></figure></div>

<h5 id="示例：-16"><a href="#示例：-16" class="headerlink" title="示例："></a>示例：</h5><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 重命名角色 &#x27;developers&#x27; 为 &#x27;devs&#x27;</span></span><br><span class="line"><span class="keyword">ALTER</span> ROLE developers RENAME <span class="keyword">TO</span> devs;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改角色 &#x27;devs&#x27; 的默认配置</span></span><br><span class="line"><span class="keyword">ALTER</span> ROLE devs <span class="keyword">WITH</span> LOGIN;</span><br></pre></td></tr></table></figure></div>

<h4 id="6-SET-ROLE"><a href="#6-SET-ROLE" class="headerlink" title="6. SET ROLE"></a>6. <code>SET ROLE</code></h4><p><code>SET ROLE</code> 命令用于在当前会话中切换角色。</p>
<h5 id="语法：-8"><a href="#语法：-8" class="headerlink" title="语法："></a>语法：</h5><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> ROLE role_name;</span><br></pre></td></tr></table></figure></div>

<h5 id="示例：-17"><a href="#示例：-17" class="headerlink" title="示例："></a>示例：</h5><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 在当前会话中切换到角色 &#x27;developers&#x27;</span></span><br><span class="line"><span class="keyword">SET</span> ROLE developers;</span><br></pre></td></tr></table></figure></div>


]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL触发器</title>
    <url>/2024/09/22/SQLTrigger/</url>
    <content><![CDATA[<p>在SQL中，触发器（Trigger）是一种特殊的存储过程，它在特定的数据库操作（如插入、更新或删除）发生时自动执行。触发器通常用于维护数据完整性、执行审计跟踪、记录日志等任务。触发器可以在表级别定义，并且可以与 <code>INSERT</code>、<code>UPDATE</code> 和 <code>DELETE</code> 操作相关联。</p>
<p>触发器所依附的表为基本表，当触发器表上发生<code>select/update/delete</code>操作时，会自动生成两个临时的表(<code>new/old</code>，只能由触发器使用)</p>
<p>比如:</p>
<ul>
<li>在<code>insert</code>操作时，会生成<code>new</code>表，记录插入的数据，<code>old</code>表则为空。</li>
<li>在<code>delete</code>操作时，会生成<code>new</code>表，记录删除的数据，<code>old</code>表记录被删除的数据。</li>
<li>在<code>update</code>操作时，会生成<code>new</code>表，记录更新的数据，<code>old</code>表记录更新前的数据。</li>
</ul>
<p>创建触发器</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> <span class="operator">&lt;</span>trigger_name<span class="operator">&gt;</span> [BEFORE<span class="operator">|</span>AFTER] [<span class="keyword">INSERT</span><span class="operator">|</span><span class="keyword">UPDATE</span><span class="operator">|</span><span class="keyword">DELETE</span>] <span class="keyword">ON</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span><span class="operator">/</span><span class="operator">&lt;</span>view_name<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> [<span class="keyword">INSERT</span><span class="operator">|</span><span class="keyword">UPDATE</span><span class="operator">|</span><span class="keyword">DELETE</span> ] <span class="keyword">FROM</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span> <span class="keyword">WHERE</span> <span class="operator">&lt;</span><span class="keyword">condition</span><span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure></div>

<p><code>FOR EACH ROW</code> 表示针对每一行都会生效，无论哪行进行指定操作都会执行触发器</p>
<p>查看触发器</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TRIGGERS;</span><br></pre></td></tr></table></figure></div>

<p>删除触发器</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> <span class="operator">&lt;</span>trigger_name<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="触发器的基本概念"><a href="#触发器的基本概念" class="headerlink" title="触发器的基本概念"></a>触发器的基本概念</h3><ol>
<li><p><strong>触发器的类型</strong>:</p>
<ul>
<li><strong>BEFORE 触发器</strong>: 在触发操作（如插入、更新或删除）之前执行。</li>
<li><strong>AFTER 触发器</strong>: 在触发操作之后执行。</li>
<li><strong>INSTEAD OF 触发器</strong>: 用于视图，替代触发操作执行。</li>
</ul>
</li>
<li><p><strong>触发器的创建</strong>:</p>
<ul>
<li>使用 <code>CREATE TRIGGER</code> 语句创建触发器。</li>
<li>触发器可以与 <code>INSERT</code>、<code>UPDATE</code> 和 <code>DELETE</code> 操作相关联。</li>
</ul>
</li>
<li><p><strong>触发器的优点</strong>:</p>
<ul>
<li><strong>自动执行</strong>: 触发器在特定事件发生时自动执行，无需手动调用。</li>
<li><strong>维护数据完整性</strong>: 触发器可以用于强制执行复杂的业务规则和约束。</li>
<li><strong>审计跟踪</strong>: 触发器可以用于记录对数据的修改，便于审计和追踪。</li>
</ul>
</li>
<li><p><strong>触发器的缺点</strong>:</p>
<ul>
<li><strong>性能开销</strong>: 触发器的执行会增加数据库操作的开销，尤其是在频繁操作的情况下。</li>
<li><strong>复杂性</strong>: 触发器的逻辑可能变得复杂，难以维护和调试。</li>
</ul>
</li>
</ol>
<h3 id="触发器的实例"><a href="#触发器的实例" class="headerlink" title="触发器的实例"></a>触发器的实例</h3><h4 id="实例1：插入操作触发器"><a href="#实例1：插入操作触发器" class="headerlink" title="实例1：插入操作触发器"></a>实例1：插入操作触发器</h4><p>假设我们有一个 <code>employees</code> 表，我们希望在每次插入新员工时，自动记录插入操作的时间。</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    hire_date DATETIME</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> audit_log (</span><br><span class="line">    log_id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    action <span class="type">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">    log_date DATETIME</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trg_employees_insert</span><br><span class="line">AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> employees</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> audit_log (action, log_date)</span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">&#x27;INSERT&#x27;</span>, NOW());</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure></div>

<p>在这个例子中，<code>trg_employees_insert</code> 触发器在每次向 <code>employees</code> 表插入新记录时自动执行，并将插入操作记录到 <code>audit_log</code> 表中。</p>
<h4 id="实例2：更新操作触发器"><a href="#实例2：更新操作触发器" class="headerlink" title="实例2：更新操作触发器"></a>实例2：更新操作触发器</h4><p>假设我们希望在每次更新 <code>employees</code> 表中的 <code>hire_date</code> 字段时，自动记录更新前后的值。</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trg_employees_update</span><br><span class="line">BEFORE <span class="keyword">UPDATE</span> <span class="keyword">ON</span> employees</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> audit_log (action, log_date)</span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">&#x27;UPDATE&#x27;</span>, NOW());</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure></div>

<p>在这个例子中，<code>trg_employees_update</code> 触发器在每次更新 <code>employees</code> 表中的记录时自动执行，并将更新操作记录到 <code>audit_log</code> 表中。</p>
<h4 id="实例3：删除操作触发器"><a href="#实例3：删除操作触发器" class="headerlink" title="实例3：删除操作触发器"></a>实例3：删除操作触发器</h4><p>假设我们希望在每次删除 <code>employees</code> 表中的记录时，自动记录删除操作。</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trg_employees_delete</span><br><span class="line">AFTER <span class="keyword">DELETE</span> <span class="keyword">ON</span> employees</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> audit_log (action, log_date)</span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">&#x27;DELETE&#x27;</span>, NOW());</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure></div>

<p>在这个例子中，<code>trg_employees_delete</code> 触发器在每次删除 <code>employees</code> 表中的记录时自动执行，并将删除操作记录到 <code>audit_log</code> 表中。</p>
<h3 id="触发器的使用场景"><a href="#触发器的使用场景" class="headerlink" title="触发器的使用场景"></a>触发器的使用场景</h3><ol>
<li><p><strong>数据完整性</strong>:</p>
<ul>
<li>触发器可以用于强制执行复杂的业务规则和约束，例如在插入或更新数据时检查数据的合法性。</li>
</ul>
</li>
<li><p><strong>审计跟踪</strong>:</p>
<ul>
<li>触发器可以用于记录对数据的修改，便于审计和追踪。</li>
</ul>
</li>
<li><p><strong>自动更新</strong>:</p>
<ul>
<li>触发器可以用于自动更新相关表中的数据，例如在插入新订单时自动更新库存表。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>asio-IOServicePool</title>
    <url>/2024/08/24/asio-IOServicePool/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>IOServicePool</code>是一个用于管理多个<code>io_context</code>实例的多线程模型，每一个线程管理一个<code>io_context</code>，它的主要目的是在多线程环境中高效地分发和异步处理I&#x2F;O操作</p>
<h2 id="单线程和多线程对比"><a href="#单线程和多线程对比" class="headerlink" title="单线程和多线程对比"></a>单线程和多线程对比</h2><p>单线程模式图<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/08/24/1Kw5yAiT2DrJg3l.png"
                      alt="单线程模型.png"
                ></p>
<p>多线程模式图<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/08/24/j9vaAPC8WMzpce3.png"
                      alt="IOServicePool.png"
                ></p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li><p>每一个<code>io_context</code>跑在不同的线程里，所以同一个<code>socket</code>会被注册在同一个<code>io_context</code>里，它的回调函数也会被单独的一个线程回调，那么对于同一个<code>socket</code>，他的回调函数每次触发都是在同一个线程里，就不会有线程安全问题，网络io层面上的并发是线程安全的。</p>
</li>
<li><p>但是对于不同的<code>socket</code>，回调函数的触发可能是同一个线程(两个<code>socket</code>被分配到同一个<code>io_context</code>)，也可能不是同一个线程(两个<code>socket</code>被分配到不同的<code>io_context</code>里)。所以如果两个<code>socket</code>对应的上层逻辑处理，如果有交互或者访问共享区，会存在线程安全问题。比如<code>socket1</code>代表玩家1，<code>socket2</code>代表玩家2，玩家1和玩家2在逻辑层存在交互，比如两个玩家都在做工会任务，他们属于同一个工会，工会积分的增加就是共享区的数据，需要保证线程安全。可以通过加锁或者逻辑队列的方式解决安全问题，我们目前采取了后者。</p>
</li>
<li><p>多线程相比单线程，极大的提高了并发能力，因为单线程仅有一个<code>io_context</code>服务用来监听读写事件，就绪后回调函数在一个线程里串行调用, 如果一个回调函数的调用时间较长肯定会影响后续的函数调用，毕竟是穿行调用。而采用多线程方式，可以在一定程度上减少前一个逻辑调用影响下一个调用的情况，比如两个<code>socket</code>被部署到不同的<code>iocontext</code>上，但是当两个<code>socket</code>部署到同一个<code>iocontext</code>上时仍然存在调用时间影响的问题。不过我们已经通过逻辑队列的方式将网络线程和逻辑线程解耦合了，不会出现前一个调用时间影响下一个回调触发的问题。</p>
</li>
</ol>
<h2 id="IOServicePool实现"><a href="#IOServicePool实现" class="headerlink" title="IOServicePool实现"></a>IOServicePool实现</h2><p>IOServicePool本质上是一个线程池，基本功能就是根据构造函数传入的数量创建n个线程和iocontext，然后每个线程跑一个iocontext，这样就可以并发处理不同iocontext读写事件了。<br>声明如下：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span></span></span><br><span class="line"><span class="comment">// 如果要使用这个线程池的话，</span></span><br><span class="line"><span class="comment">// 将CServer的io_context替换为AsioIOServicePool::GetInstance()-&gt;get_io_service()</span></span><br><span class="line"><span class="comment">// main函数需要给服务器创建一个io_context</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Singleton.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AsioIOServicePool</span> : <span class="keyword">public</span> Singleton&lt;AsioIOServicePool&gt; &#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&lt;AsioIOServicePool&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> IOService = boost::asio::io_context;</span><br><span class="line">    <span class="keyword">using</span> Work      = boost::asio::io_context::work;</span><br><span class="line">    <span class="keyword">using</span> WorkPtr   = std::unique_ptr&lt;Work&gt;;</span><br><span class="line">    ~<span class="built_in">AsioIOServicePool</span>();</span><br><span class="line">    <span class="built_in">AsioIOServicePool</span>( <span class="type">const</span> AsioIOServicePool &amp; )            = <span class="keyword">delete</span>;</span><br><span class="line">    AsioIOServicePool &amp;<span class="keyword">operator</span>=( <span class="type">const</span> AsioIOServicePool &amp; ) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    boost::<span class="function">asio::io_context &amp;<span class="title">get_io_service</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">AsioIOServicePool</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">size_t</span> thread_size = std::thread::hardware_concurrency() )</span></span>;</span><br><span class="line">    std::vector&lt;IOService&gt; _ioServices;</span><br><span class="line">    std::vector&lt;WorkPtr&gt; _works;</span><br><span class="line">    std::vector&lt;std::thread&gt; _threads;</span><br><span class="line">    std::<span class="type">size_t</span> _nextIOservice; <span class="comment">// 轮询索引</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>实现如下：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">AsioIOServicePool::<span class="built_in">AsioIOServicePool</span>(<span class="type">size_t</span> thread_size)</span><br><span class="line">    : _ioServices(thread_size), _works(thread_size), _nextIOservice(<span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; thread_size; ++i) &#123;</span><br><span class="line">        _works[i] = std::<span class="built_in">make_unique</span>&lt;Work&gt;(<span class="built_in">Work</span>(_ioServices[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;IOService : _ioServices) &#123;</span><br><span class="line">        _threads.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>, &amp;IOService]() &#123; IOService.<span class="built_in">run</span>(); &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boost::<span class="function">asio::io_context &amp;<span class="title">AsioIOServicePool::get_io_service</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;service = _ioServices[_nextIOservice++ % _ioServices.<span class="built_in">size</span>()];</span><br><span class="line">    <span class="keyword">return</span> service;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AsioIOServicePool::Stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;work : _works) &#123;</span><br><span class="line">        work.<span class="built_in">reset</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;t : _threads) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AsioIOServicePool::~<span class="built_in">AsioIOServicePool</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;AsioIOServicePool destroyed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>这段代码实现了一个基于 <code>boost::asio</code> 的 I&#x2F;O 服务池（<code>AsioIOServicePool</code>），并使用了单例模式（通过 <code>Singleton&lt;AsioIOServicePool&gt;</code>）来确保全局只有一个实例。以下是对代码的详细解释：</p>
<h4 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AsioIOServicePool</span> : <span class="keyword">public</span> Singleton&lt;AsioIOServicePool&gt; &#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&lt;AsioIOServicePool&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> IOService = boost::asio::io_context;</span><br><span class="line">    <span class="keyword">using</span> Work      = boost::asio::io_context::work;</span><br><span class="line">    <span class="keyword">using</span> WorkPtr   = std::unique_ptr&lt;Work&gt;;</span><br><span class="line">    ~<span class="built_in">AsioIOServicePool</span>();</span><br><span class="line">    <span class="built_in">AsioIOServicePool</span>( <span class="type">const</span> AsioIOServicePool &amp; )            = <span class="keyword">delete</span>;</span><br><span class="line">    AsioIOServicePool &amp;<span class="keyword">operator</span>=( <span class="type">const</span> AsioIOServicePool &amp; ) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    boost::<span class="function">asio::io_context &amp;<span class="title">get_io_service</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">AsioIOServicePool</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">size_t</span> thread_size = std::thread::hardware_concurrency() )</span></span>;</span><br><span class="line">    std::vector&lt;IOService&gt; _ioServices;</span><br><span class="line">    std::vector&lt;WorkPtr&gt; _works;</span><br><span class="line">    std::vector&lt;std::thread&gt; _threads;</span><br><span class="line">    std::<span class="type">size_t</span> _nextIOservice; <span class="comment">// 轮询索引</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>AsioIOServicePool</code> 继承自 <code>Singleton&lt;AsioIOServicePool&gt;</code>，确保它是单例的。</li>
<li><code>friend class Singleton&lt;AsioIOServicePool&gt;;</code>：允许 <code>Singleton</code> 类访问 <code>AsioIOServicePool</code> 的私有成员。</li>
<li>使用 <code>using</code> 别名定义了 <code>IOService</code>、<code>Work</code> 和 <code>WorkPtr</code>。</li>
<li>删除了拷贝构造函数和赋值操作符，防止对象被复制。</li>
<li><code>get_io_service()</code> 方法用于获取一个 <code>io_context</code> 实例。</li>
<li><code>Stop()</code> 方法用于停止所有 <code>io_context</code> 并等待线程结束。</li>
<li>私有构造函数 <code>AsioIOServicePool</code> 接受一个线程数量参数，默认为硬件并发数。</li>
<li>成员变量包括 <code>_ioServices</code>（<code>io_context</code> 数组）、<code>_works</code>（工作对象数组）、<code>_threads</code>（线程数组）和 <code>_nextIOservice</code>（轮询索引）。</li>
</ul>
<h4 id="实现文件"><a href="#实现文件" class="headerlink" title="实现文件"></a>实现文件</h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">AsioIOServicePool::<span class="built_in">AsioIOServicePool</span>(<span class="type">size_t</span> thread_size)</span><br><span class="line">    : _ioServices(thread_size), _works(thread_size), _nextIOservice(<span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; thread_size; ++i) &#123;</span><br><span class="line">        _works[i] = std::<span class="built_in">make_unique</span>&lt;Work&gt;(<span class="built_in">Work</span>(_ioServices[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;IOService : _ioServices) &#123;</span><br><span class="line">        _threads.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>, &amp;IOService]() &#123; IOService.<span class="built_in">run</span>(); &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>构造函数初始化 <code>_ioServices</code>、<code>_works</code> 和 <code>_nextIOservice</code>。</li>
<li>为每个 <code>io_context</code> 创建一个 <code>Work</code> 对象，防止 <code>io_context</code> 在没有工作时退出。</li>
<li>为每个 <code>io_context</code> 创建一个线程，并在该线程中运行 <code>io_context</code>。</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">boost::<span class="function">asio::io_context &amp;<span class="title">AsioIOServicePool::get_io_service</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;service = _ioServices[_nextIOservice++ % _ioServices.<span class="built_in">size</span>()];</span><br><span class="line">    <span class="keyword">return</span> service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>get_io_service()</code> 方法通过轮询方式返回一个 <code>io_context</code> 实例。</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AsioIOServicePool::Stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;work : _works) &#123;</span><br><span class="line">        work.<span class="built_in">reset</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;t : _threads) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>Stop()</code> 方法重置所有 <code>Work</code> 对象，使 <code>io_context</code> 可以退出。</li>
<li>等待所有线程结束。</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">AsioIOServicePool::~<span class="built_in">AsioIOServicePool</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;AsioIOServicePool destroyed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>析构函数输出一条消息，表示对象被销毁。</li>
</ul>
<h3 id="关于优雅退出"><a href="#关于优雅退出" class="headerlink" title="关于优雅退出"></a>关于优雅退出</h3><p>IOServicePool多线程服务器退出时，需要捕获退出信号如<code>SIGINT</code>、<code>SIGTERM</code>等，然后通知所有线程退出，然后等待线程结束，将退出信号和一个<code>io_context</code>绑定，当接收到退出信号时，我们将IOServicePool中的<code>io_context</code>退出，然后等待所有线程退出，最后销毁线程池。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> pool = AsioIOServicePool::<span class="built_in">GetInstance</span>();</span><br><span class="line">        boost::asio::io_context  io_context;</span><br><span class="line">        boost::<span class="function">asio::signal_set <span class="title">signals</span><span class="params">(io_context, SIGINT, SIGTERM)</span></span>;</span><br><span class="line">        signals.<span class="built_in">async_wait</span>([&amp;io_context,pool](<span class="keyword">auto</span>, <span class="keyword">auto</span>) &#123;</span><br><span class="line">            io_context.<span class="built_in">stop</span>();</span><br><span class="line">            pool-&gt;<span class="built_in">Stop</span>();</span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="function">CServer <span class="title">s</span><span class="params">(io_context, <span class="number">10086</span>)</span></span>;</span><br><span class="line">        io_context.<span class="built_in">run</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>网络编程</tag>
        <tag>socket</tag>
        <tag>计算机网络</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL视图</title>
    <url>/2024/09/17/SQLView/</url>
    <content><![CDATA[<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>SQL 中的视图（View）是一个虚拟表，它基于一个或多个表的查询结果。视图本身不存储数据，而是存储查询的定义。当你查询视图时，数据库引擎会执行视图定义的查询，并返回结果。视图可以简化复杂的查询，提供数据的安全性，并隐藏底层表的复杂性。</p>
<h3 id="1-创建视图（CREATE-VIEW）"><a href="#1-创建视图（CREATE-VIEW）" class="headerlink" title="1. 创建视图（CREATE VIEW）"></a>1. 创建视图（CREATE VIEW）</h3><p>你可以使用 <code>CREATE VIEW</code> 语句来创建视图。视图的定义可以包含 <code>SELECT</code> 语句中的所有元素，如 <code>WHERE</code>、<code>GROUP BY</code>、<code>JOIN</code> 等。</p>
<h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> columns</span><br><span class="line"><span class="keyword">FROM</span> tables</span><br><span class="line"><span class="keyword">WHERE</span> conditions;</span><br></pre></td></tr></table></figure></div>

<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><p>假设我们有一个 <code>employees</code> 表和一个 <code>departments</code> 表，我们希望创建一个视图，显示每个员工的姓名、部门名称和工资：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> employee_department_view <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> employees.employee_name, departments.department_name, employees.salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">JOIN</span> departments <span class="keyword">ON</span> employees.department_id <span class="operator">=</span> departments.department_id;</span><br></pre></td></tr></table></figure></div>

<h3 id="2-查询视图（SELECT）"><a href="#2-查询视图（SELECT）" class="headerlink" title="2. 查询视图（SELECT）"></a>2. 查询视图（SELECT）</h3><p>查询视图与查询表的方式相同。你可以像查询表一样查询视图。</p>
<h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employee_department_view;</span><br></pre></td></tr></table></figure></div>

<h3 id="3-更新视图（UPDATE-VIEW）"><a href="#3-更新视图（UPDATE-VIEW）" class="headerlink" title="3. 更新视图（UPDATE VIEW）"></a>3. 更新视图（UPDATE VIEW）</h3><p>在某些情况下，你可以通过视图更新底层表的数据。视图必须是可更新的，即视图的定义必须满足一定的条件（如没有 <code>GROUP BY</code>、<code>HAVING</code>、<code>DISTINCT</code> 等）。</p>
<h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> employee_department_view</span><br><span class="line"><span class="keyword">SET</span> salary <span class="operator">=</span> <span class="number">6000</span></span><br><span class="line"><span class="keyword">WHERE</span> employee_name <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="4-删除视图（DROP-VIEW）"><a href="#4-删除视图（DROP-VIEW）" class="headerlink" title="4. 删除视图（DROP VIEW）"></a>4. 删除视图（DROP VIEW）</h3><p>你可以使用 <code>DROP VIEW</code> 语句删除视图。</p>
<h4 id="语法：-1"><a href="#语法：-1" class="headerlink" title="语法："></a>语法：</h4><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> view_name;</span><br></pre></td></tr></table></figure></div>

<h4 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h4><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> employee_department_view;</span><br></pre></td></tr></table></figure></div>

<h3 id="5-修改视图（ALTER-VIEW）"><a href="#5-修改视图（ALTER-VIEW）" class="headerlink" title="5. 修改视图（ALTER VIEW）"></a>5. 修改视图（ALTER VIEW）</h3><p>在某些数据库系统中，你可以使用 <code>ALTER VIEW</code> 语句修改视图的定义。</p>
<h4 id="语法：-2"><a href="#语法：-2" class="headerlink" title="语法："></a>语法：</h4><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> columns</span><br><span class="line"><span class="keyword">FROM</span> tables</span><br><span class="line"><span class="keyword">WHERE</span> conditions;</span><br></pre></td></tr></table></figure></div>

<h4 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h4><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> employee_department_view <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> employees.employee_name, departments.department_name, employees.salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">JOIN</span> departments <span class="keyword">ON</span> employees.department_id <span class="operator">=</span> departments.department_id</span><br><span class="line"><span class="keyword">WHERE</span> employees.salary <span class="operator">&gt;</span> <span class="number">5000</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="6-视图的优点"><a href="#6-视图的优点" class="headerlink" title="6. 视图的优点"></a>6. 视图的优点</h3><ul>
<li>简化查询:视图可以将复杂的查询封装起来，简化用户的查询操作。</li>
<li>数据安全:视图可以限制用户只能访问特定的数据，从而提高数据的安全性。</li>
<li>数据独立性:视图可以隐藏底层表的复杂性，使用户无需了解底层表的结构。</li>
<li>逻辑数据分组:视图可以将多个表的数据逻辑上组合在一起，方便用户进行数据分析。</li>
</ul>
<h3 id="7-视图的缺点"><a href="#7-视图的缺点" class="headerlink" title="7. 视图的缺点"></a>7. 视图的缺点</h3><ul>
<li>性能问题:视图的查询性能可能不如直接查询底层表，尤其是在视图定义复杂的情况下。</li>
<li>更新限制:视图的更新操作受到限制，不是所有的视图都可以进行更新操作。</li>
<li>存储开销:虽然视图本身不存储数据，但视图的定义会占用存储空间。</li>
</ul>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CreatE</span> <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span> 子查询语句 [<span class="keyword">WITH</span> <span class="keyword">CHECK</span> OPTION]</span><br></pre></td></tr></table></figure></div>

<p><code>WITH CHECK OPTION</code>是指当创建后，如果更新视图中的数据，是否要满足子查询中的条件表达式，不满足将无法插入，创建后，我们就可以使用<code>SELECT</code>来直接查询视图上的数据，因此还能在视图上的基础导出其他视图</p>
<ol>
<li>若视图是由两个以上的基本表导出的，则此视图不允许更新</li>
<li>若视图的字段来自地段表达式或常数，则不允许对此视图执行<code>INSERT</code>或<code>UPDATE</code>操作，但允许执行<code>DELETE</code>操作</li>
<li>若视图的字段来自集函数，则此视图不允许更新</li>
<li>若视图定义中含有<code>GROUP BY</code>或<code>HAVING</code>，则不允许更新</li>
<li>若视图定义中含有<code>DISTINCT</code>短语，则不允许更新</li>
<li>若视图定义中含有嵌套查询，并且内层查询的<code>FROM</code>子句中涉及的表也是导出该图的基本表，则此视图不允许更新。<br>例如将成绩在平均成绩以上的元组定义成一个视图<code>GOOD_SC</code>:</li>
</ol>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> GOOD_SC <span class="keyword">AS</span> <span class="keyword">SELECT</span> Sno, Cno, Grade <span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> Grade <span class="operator">&gt;</span> (<span class="keyword">SElECt</span> <span class="built_in">AVG</span>(Grade) <span class="keyword">FROM</span> SC);</span><br></pre></td></tr></table></figure></div>

<p>导出视图<code>GOOD_SC</code>的基本表是<code>SC</code>表，内层查询中涉及的基本表也是<code>SC</code>，所以视图<code>GOOD_SC</code>是不允许更新的</p>
<ol start="7">
<li>一个不允许更新的视图上定义的视图也不允许更新</li>
</ol>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>建造者模式</title>
    <url>/2024/07/13/builder/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>建造者模式（Builder Pattern）是一种在软件设计中用来组织对象的构造过程的方法。它将对象的构建和表示分离，允许独立改变构建过程或生成不同的表示形式。这种模式特别适用于那些需要创建复杂对象的场景，在这些场景中，对象的组成部分可能相互依赖或者取决于外部环境条件。</p>
<h2 id="建造者模式的主要组件"><a href="#建造者模式的主要组件" class="headerlink" title="建造者模式的主要组件"></a>建造者模式的主要组件</h2><p>建造者模式通常包含以下主要组件：</p>
<ol>
<li><p><strong>产品（Product）接口</strong>：定义了一个通用的产品或对象结构。所有具体产品的构建都会遵循这个接口。</p>
</li>
<li><p><strong>抽象建造者（Builder Interface）</strong>：为创建特定产品提供一组方法，这些方法用于设置产品的不同部分。该接口是所有具体建造者的超类。</p>
</li>
<li><p><strong>具体建造者（Concrete Builder）</strong>：实现抽象建造者接口，并定义了如何构建具体的产品实例。每个具体的建造者将根据需要构建不同的部分或选择不同的配置来创建产品。</p>
</li>
<li><p><strong>产品工厂（Product Factory）</strong> 或 <strong>导演（Director）</strong>：在一些情况下，可以使用一个中心类来调用特定的建造者方法并构建出一个完整的产品对象。这个类通常不直接与产品的具体实现交互，而是通过调用建造者的接口来完成构建过程。</p>
</li>
</ol>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>建造者模式适用于以下几种情况：</p>
<ul>
<li><strong>复杂对象构造</strong>：当创建对象时涉及多个步骤或依赖于外部环境条件（例如操作系统版本、网络配置等）。</li>
<li><strong>可选功能构建</strong>：在产品中包含可选择的组件或选项，如定制电脑配置（CPU类型、内存大小、硬盘驱动器类型等）。</li>
</ul>
<h2 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h2><p>为了更好地理解建造者模式，我们可以使用一个简单的例子来说明如何应用这个设计模式。假设我们正在组装一台电脑开发一个构建过程，允许用户根据需求自定义电脑的配置</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Product</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Computer</span><span class="params">()</span> </span>= <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setCPU</span><span class="params">( <span class="type">const</span> std::string &amp;cpu )</span> </span>&#123; cpu_ = cpu; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setMemory</span><span class="params">( <span class="type">const</span> std::string &amp;memory )</span> </span>&#123; memory_ = memory; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setStorage</span><span class="params">( <span class="type">const</span> std::string &amp;storage )</span> </span>&#123; storage_ = storage; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;CPU:     &quot;</span> &lt;&lt; cpu_ &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Memory:  &quot;</span> &lt;&lt; memory_ &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Storage: &quot;</span> &lt;&lt; storage_ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string cpu_;</span><br><span class="line">    std::string memory_;</span><br><span class="line">    std::string storage_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Builder interface</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ComputerBuilder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ComputerBuilder</span>()                       = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buildCPU</span><span class="params">( <span class="type">const</span> std::string &amp; )</span>     </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buildMemory</span><span class="params">( <span class="type">const</span> std::string &amp; )</span>  </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buildStorage</span><span class="params">( <span class="type">const</span> std::string &amp; )</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::shared_ptr&lt;Computer&gt; <span class="title">getResult</span><span class="params">()</span>    </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete Builder</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DesktopComputerBuilder</span> : <span class="keyword">public</span> ComputerBuilder &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DesktopComputerBuilder</span>() : <span class="built_in">computer_</span>( std::<span class="built_in">make_shared</span>&lt;Computer&gt;() ) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildCPU</span><span class="params">( <span class="type">const</span> std::string &amp;cpu )</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        computer_-&gt;<span class="built_in">setCPU</span>( cpu );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildMemory</span><span class="params">( <span class="type">const</span> std::string &amp;memory )</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        computer_-&gt;<span class="built_in">setMemory</span>( memory );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildStorage</span><span class="params">( <span class="type">const</span> std::string &amp;storage )</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        computer_-&gt;<span class="built_in">setStorage</span>( storage );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;Computer&gt; <span class="title">getResult</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> computer_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;Computer&gt; computer_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Director</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ComputerAssembler</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Computer&gt; <span class="title">assembleComputer</span><span class="params">( ComputerBuilder &amp;builder )</span> </span>&#123;</span><br><span class="line">        builder.<span class="built_in">buildCPU</span>( <span class="string">&quot;Inter i7&quot;</span> );</span><br><span class="line">        builder.<span class="built_in">buildStorage</span>( <span class="string">&quot;980 PRO 1TB SSD&quot;</span> );</span><br><span class="line">        builder.<span class="built_in">buildMemory</span>( <span class="string">&quot;16GB&quot;</span> );</span><br><span class="line">        <span class="keyword">return</span> builder.<span class="built_in">getResult</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DesktopComputerBuilder builder;</span><br><span class="line">    ComputerAssembler assembler;</span><br><span class="line">    <span class="keyword">auto</span> computer = assembler.<span class="built_in">assembleComputer</span>( builder );</span><br><span class="line">    computer-&gt;<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>在给出的代码示例中，实现了建造者模式的主要组成部分：</p>
<ol>
<li><p><strong>产品接口</strong>（<code>Computer</code>）：定义了一个用于创建电脑的基本接口。所有的具体产品（如台式电脑、笔记本电脑等）都必须遵循这个接口。</p>
</li>
<li><p><strong>抽象建造者（Builder Interface）</strong>（<code>ComputerBuilder</code>）：定义了构建电脑所需的通用方法，比如设置CPU、内存和存储设备等。这些方法对所有具体的建造者类开放，允许它们独立于具体产品来操作构建过程。</p>
</li>
<li><p><strong>具体建造者</strong>（<code>DesktopComputerBuilder</code>）：实现了抽象建造者接口并提供了具体实现的方法。每个具体建造者会根据自己的规则和逻辑来执行构建步骤，比如在台式电脑上选择不同的组件配置。</p>
</li>
<li><p><strong>导演类（Director）</strong>（<code>ComputerAssembler</code>）：负责调用具体的建造者类进行构建过程。它不直接与产品接口或具体的产品实例交互，而是通过调用抽象建造者的接口方法完成构建。</p>
</li>
<li><p><code>test_func</code> 函数展示了如何使用这些组成部分来构建一个台式电脑的例子：</p>
</li>
</ol>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">DesktopComputerBuilder builder;</span><br><span class="line">ComputerAssembler assembler;</span><br><span class="line"><span class="keyword">auto</span> computer = assembler.<span class="built_in">assembleComputer</span>( builder );</span><br><span class="line">computer-&gt;<span class="built_in">print</span>();</span><br></pre></td></tr></table></figure></div>

<p>在这个例子中：</p>
<ul>
<li><strong>Builder</strong> (<code>DesktopComputerBuilder</code>) 实例化并执行了具体的构建步骤，比如选择CPU型号、内存大小和存储设备类型。</li>
<li><strong>Director</strong> (<code>ComputerAssembler</code>) 负责调用 <code>DesktopComputerBuilder</code> 的方法来逐步构造电脑。</li>
</ul>
<p>通过这样的结构设计，建造者模式使得在不同场景下可以有不同的构建过程（不同的具体产品），同时保持了代码的可扩展性和灵活性。例如，我们可以轻松地添加新的构建步骤或创建完全不同的产品类型而无需修改现有的组装逻辑。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>建造者模式是一种强大的设计模式，尤其在需要创建具有复杂构造过程的对象时非常有用。它通过封装构建过程和分离产品构建逻辑来提高系统的灵活性、可扩展性和可维护性。</p>
<h2 id="建造者模式的缺点"><a href="#建造者模式的缺点" class="headerlink" title="建造者模式的缺点"></a>建造者模式的缺点</h2><p>尽管建造者模式在很多情况下能够提供强大的对象构造能力，但就像任何设计模式一样，它也有其局限性和潜在的问题：</p>
<ol>
<li><p><strong>增加系统复杂性</strong>：引入多个类和接口会增加系统的复杂度。对于那些没有足够需求变化或不需要高度可配置性的项目来说，构建者模式可能会导致过度工程化。</p>
</li>
<li><p><strong>创建过多的实例</strong>：如果建造过程涉及到很多步骤或者每个步骤都有可能产生不同的实例，那么在某些实现中可能会创建大量的对象，这可能导致内存使用和性能问题。优化构建过程以减少不必要的对象创建是很重要的。</p>
</li>
<li><p><strong>代码维护难度</strong>：由于构造过程的细节被封装在多个类中，这对于系统维护来说可能需要更多的关注点。如果建造过程发生变化（例如引入新的组件或改变现有组件的选择逻辑），那么通常需要修改不止一个地方，这可能导致维护和更新的成本增加。</p>
</li>
<li><p><strong>耦合性问题</strong>：尽管抽象建造者试图通过接口来隐藏构建步骤的细节，但具体建造者的实现可能会与产品类紧密关联。这种依赖关系可能使得重构变得困难，并且如果对建造过程进行微小调整，可能需要修改多个相关部分。</p>
</li>
<li><p><strong>代码可读性和理解难度</strong>：建造者模式中的类和方法通常用于封装复杂的构建逻辑，这在一定程度上增加了代码的阅读和理解难度。对于没有熟悉此设计模式的人来说，在初次接触时可能会觉得难以理解整个系统的构造过程。</p>
</li>
<li><p><strong>资源消耗</strong>：如果构建步骤涉及外部依赖或需要大量计算资源（如网络请求、数据库查询等），那么建造者模式可能会增加整体系统对这些资源的需求，从而影响性能和用户体验。</p>
</li>
<li><p><strong>非线性构建路径</strong>：在某些实现中，建造过程可能不是单一线性的，而是有多个选择点。这可能导致难以预测的结果或更复杂的错误处理逻辑。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程-1</title>
    <url>/2024/03/23/concurrency-programming-1/</url>
    <content><![CDATA[<h1 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h1><h2 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h2><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;hello world\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>如果函数需要传参</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(std::string name)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(func , <span class="string">&quot;127.0.0.1&quot;</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>仿函数作为参数</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Background_task</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>[](<span class="type">const</span> std::string&amp; str) &#123;</span><br><span class="line">        std::cout &lt;&lt; str &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>注意：</p>
<p>如果采用如下的方式调用函数，编译器一定会报错</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(Background_task())</span></span>;</span><br><span class="line">t1.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure></div>

<p>因为编译器会将t1当作一个函数对象，返回一个<code>std::thread</code>类型的值，函数的参数为一个函数指针，该函数指针返回值为<code>Back_ground_task</code>，参数为void</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">std::<span class="built_in">thread</span> (*)(<span class="built_in">Background_task</span> (*)());</span><br></pre></td></tr></table></figure></div>

<p>修改的方式如下</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">((background_task()))</span></span>;</span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">std::thread t2&#123;<span class="built_in">background_task</span>()&#125;;</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure></div>

<p>lambda表达式作为参数</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">([](<span class="type">const</span> std::string&amp; str)&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    std::cout &lt;&lt; str &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125; , <span class="string">&quot;hello world\n&quot;</span>)</span></span>;</span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>注意在线程中参数是以拷贝的形式进行传递，因此对于拷贝耗时的对象可以选择用引用或者指针进行传递。但是需要考虑对象的生命周期。因为线程的运行长度可能会超过参数的生命周期，这个时候如果线程还在访问一个已经被销毁的对象就会出现问题</p>
<h3 id="detach-和-join"><a href="#detach-和-join" class="headerlink" title="detach 和 join"></a>detach 和 join</h3><blockquote>
<p>主要API</p>
</blockquote>
<p>一旦启动线程之后，我们必须决定是要等待到这个线程结束(join)，或者直接和主线程独立开来(detach)，我们必须二者选其一。如果<code>std::thread</code>对象销毁时我们还没有触发任何操作，则<code>std::thread</code>对象在析构函数将调用<code>std::terminate()</code>从而导致进程异常退出</p>
<ul>
<li><p><code>join</code>: 调用这个API时，当前线程就会停滞，直到目标线程执行完毕。</p>
</li>
<li><p><code>detach</code>: 这个API是让目标线程成为守护线程。一旦<code>detach</code>之后，目标线程将独立运行，即便其对应的<code>std::thread</code>对象销毁也不影响线程的执行。并且无法与之通信。</p>
</li>
</ul>
<p>对于这两个接口，都必须是可执行的线程才有意义。可以通过<code>joinable()</code>接口查询是否可以对它们进行<code>join</code>或者<code>detach</code></p>
<h3 id="管理线程"><a href="#管理线程" class="headerlink" title="管理线程"></a>管理线程</h3><ul>
<li><p><code>yield</code>: 通常在自己的主要任务已经完成时，希望让出处理器给其他任务使用</p>
</li>
<li><p><code>get_id</code>: 返回当前线程的id，可以用来标识不同的线程</p>
</li>
<li><p><code>sleep_for</code>: 可以让当前线程停滞一段时间</p>
</li>
<li><p><code>sleep_until</code>: 和<code>sleep_for</code>类似，但是以具体时间点为参数，这两个API都是以<code>chrono</code>api为基础</p>
</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_time</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> <span class="type">in_time_t</span> = std::chrono::system_clock::<span class="built_in">to_time_t</span>(now);</span><br><span class="line"></span><br><span class="line">    std::stringstream ssin;</span><br><span class="line">    ssin &lt;&lt; std::<span class="built_in">put_time</span>(std::<span class="built_in">localtime</span>(&amp;<span class="type">in_time_t</span>) , <span class="string">&quot;%Y-%m-%d %X&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;now is: &quot;</span> &lt;&lt; ssin.<span class="built_in">str</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sleep_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[thread-&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;] is waking up\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[thread-&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;] print: &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print_time</span>();</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(sleep_thread)</span> , <span class="title">t2</span><span class="params">(loop_thread)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">detach</span>();</span><br><span class="line">    <span class="built_in">print_time</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="线程的归属权"><a href="#线程的归属权" class="headerlink" title="线程的归属权"></a>线程的归属权</h3><blockquote>
<p>每个线程都有其归属权，也就是说归属给每个变量管理</p>
</blockquote>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><code>t1</code>是一个线程变量，管理一个线程，该线程执行<code>func()</code>对于<code>std::thread</code>C++不允许拷贝构造和拷贝赋值，所以只能通过移动和局部变量返回的方式将线程变量管理权转移给其他变量管理。</p>
<p>例如下面的例子</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;; <span class="comment">// namespace</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. t1绑定函数func1()</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(func1)</span></span>;</span><br><span class="line">    <span class="comment">//2. 转移t1的管理的线程给t2，转移后t1无效</span></span><br><span class="line">    std::thread t2 = std::<span class="built_in">move</span>(t1);</span><br><span class="line">    <span class="comment">//3. t1绑定函数func2()</span></span><br><span class="line">    t1 = std::<span class="built_in">thread</span>(func2);</span><br><span class="line">    <span class="comment">//4. 新建一个线程t3</span></span><br><span class="line">    std::thread t3;</span><br><span class="line">    <span class="comment">//5. 转移t2管理的线程给t3，，</span></span><br><span class="line">    t3 = std::<span class="built_in">move</span>(t2);</span><br><span class="line">    <span class="comment">//6. 转移t3管理的线程给t1</span></span><br><span class="line">    t1 = std::<span class="built_in">move</span>(t3);</span><br><span class="line">    <span class="comment">// <span class="doctag">BUG:</span>不可以将一个线程的管理权交给一个已经绑定线程的变量，</span></span><br><span class="line">    <span class="comment">//否则会触发线程的terminate函数引发崩溃</span></span><br><span class="line">    <span class="comment">// t1 = std::move(t3);</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2000</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>当我们启动一个线程之后，如果主线程崩溃，会导致子线程也会异常退出，调用<code>std::terminate()</code>，如果自线程在进行一些重要的操作比如将充值信息入库等，丢失这些信息是很为危险的。所以常用的做法是捕获异常，并且在异常情况下保证子线程稳定运行结束后，主线程抛出异常结束运行</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">catch_exception</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> some_local_state = <span class="number">0</span>;</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; myfunc = []()&#123;</span><br><span class="line">        <span class="comment">// doing something</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">functhread</span><span class="params">(myfunc)</span></span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// 本线程做的一些事情，可能引发崩溃</span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125; <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">        functhread.<span class="built_in">join</span>();</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;ababababa\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    functhread.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>但是用这种方式编码会显得臃肿，可以使用<code>RAII</code>技术，保证线程对象析构的时候等待线程运行结束，回收资源。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">thread_guard</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::thread&amp; <span class="type">_t</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">thread_guard</span><span class="params">(std::thread&amp; t)</span> : _t(t) &#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">thread_guard</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="type">_t</span>.<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">            <span class="type">_t</span>.<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">thread_guard</span>(<span class="type">const</span> thread_guard&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    thread_guard&amp; <span class="keyword">operator</span>=(<span class="type">const</span> thread_guard&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">auto_guard</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> some_local_state = <span class="number">0</span>;</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; myfunc = []()&#123;</span><br><span class="line">        <span class="comment">// doing something</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(myfunc)</span></span>;</span><br><span class="line">    <span class="function">thread_guard <span class="title">guard</span><span class="params">(t1)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;auto guard finish\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="慎用隐式转换"><a href="#慎用隐式转换" class="headerlink" title="慎用隐式转换"></a>慎用隐式转换</h3><p>C++中会有一些隐式转换，例如<code>char*</code>转换为<code>std::string</code>等，这些隐式转换在线程的调用上可能会造成崩溃问题</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">danger_oops</span><span class="params">(<span class="type">int</span> som_param)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(buffer, <span class="string">&quot;%i&quot;</span>, som_param);</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span>在线程内部将char const* 转化为std::string</span></span><br><span class="line">    <span class="comment">// 指针常量  char const*  指针本身不能变</span></span><br><span class="line">    <span class="comment">// 常量指针  const char * 指向的内容不能变</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(print_str, <span class="number">3</span>, buffer)</span></span>;</span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;danger oops finished &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在以上代码中，当我们定义一个线程变量<code>thread t</code>时，传递给这个线程参数<code>buffer</code>会被保存到<code>thread</code>的成员变量中。而在线程对象t内部启动并运行线程时，参数才会被传递给调用函数<code>print_str</code>。而此时<code>buffer</code>可能到<code>&#125;</code>就被销毁了。改进方式很简单，我们将参数传递给<code>thread</code>时显示转换成<code>string</code>就可以了，其实相当于拷贝一份过去。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="type">void</span> <span class="title">danger_oops</span><span class="params">(<span class="type">int</span> som_param)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(buffer, <span class="string">&quot;%i&quot;</span>, som_param);</span><br><span class="line">    <span class="comment">//在线程内部将char const* 转化为std::string</span></span><br><span class="line">    <span class="comment">//指针常量  char const*  指针本身不能变</span></span><br><span class="line">    <span class="comment">//常量指针  const char * 指向的内容不能变</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(print_str, <span class="number">3</span>, std::string(buffer))</span></span>;</span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;danger oops finished &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="引用参数"><a href="#引用参数" class="headerlink" title="引用参数"></a>引用参数</h3><p>在线程要调用的回调函数参数作为引用类型时，需要将参数显式转换为引用对象传递给构造函数，如果采用如下调用会编译失败</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">change_param</span><span class="params">(<span class="type">int</span>&amp; param)</span> </span>&#123;</span><br><span class="line">    ++param;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ref_oops</span><span class="params">(<span class="type">int</span> some_param)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;before change , param is &quot;</span> &lt;&lt; some_param &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 需要引用显式转换</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(change_param , some_param)</span></span>;</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;after change , param is &quot;</span> &lt;&lt; some_param &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>即使函数<code>change_param</code>的参数为<code>int&amp;</code>类型，我们传递给t2的构造函数为<code>some_param</code>，也不会达到在<code>change_param</code>函数内部修改关联到外部<code>some_param</code>的效果。因为<code>some_param</code>在传递给<code>thread</code>的构造函数后会转变为右值保存，右值传递给一个左值引用会出问题，所以编译也出了问题。</p>
<p>只需要使用<code>std::ref()</code>就可以解决</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change_param</span><span class="params">(<span class="type">int</span>&amp; param)</span> </span>&#123;</span><br><span class="line">    ++param;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ref_oops</span><span class="params">(<span class="type">int</span> some_param)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;before change , param is &quot;</span> &lt;&lt; some_param &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 需要引用显式转换</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(change_param , std::ref(some_param))</span></span>;</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;after change , param is &quot;</span> &lt;&lt; some_param &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="绑定类成员函数"><a href="#绑定类成员函数" class="headerlink" title="绑定类成员函数"></a>绑定类成员函数</h3><p>有时候我们需要绑定一个类的成员函数。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">do_length_work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;do_length_work&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bind_class_oops</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    X my_x;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(&amp;X::do_length_work , &amp;my_x)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>注意，如果<code>thread</code>绑定的是普通函数，可以在函数前加<code>&amp;</code>或者不加<code>&amp;</code>，因为编译器默认将普通函数名作为函数地址，但是如果是绑定类的成员函数，必须加<code>&amp;</code></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">thead_work1</span><span class="params">(std::string str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str is &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">std::string hellostr = <span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line"><span class="comment">//两种方式都正确</span></span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(thead_work1, hellostr)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t2</span><span class="params">(&amp;thead_work1, hellostr)</span></span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="使用move操作"><a href="#使用move操作" class="headerlink" title="使用move操作"></a>使用move操作</h3><p>有时候传递给线程的参数是独占的，所谓独占就是不支持拷贝赋值和构造，但是我们可以通过<code>std::move()</code>的方式将参数的所有权转移给线程。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">deal_unqiue</span><span class="params">(std::unique_ptr&lt;<span class="type">int</span>&gt; p)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;unique ptr data is &quot;</span> &lt;&lt; *p &lt;&lt; std::endl;</span><br><span class="line">    (*p)++;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;after unqiue ptr data is &quot;</span> &lt;&lt; *p &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">move_oops</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(deal_unqiue , std::move(p))</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="一次调用"><a href="#一次调用" class="headerlink" title="一次调用"></a>一次调用</h3><p>在一些情况下，我们有些任务需要执行一次，并且我们只希望它执行一次，例如资源的初始化人物。这个时候就可以用到<code>std::call_once</code>和<code>std::once_flag</code>。这两个接口保证即便在多线程的环境下，相应的函数也只会调用一次。</p>
<p>例如下面的代码，有四个线程会执行<code>init()</code>函数，但是只有一个线程会执行。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Initializing....&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">(std::once_flag&amp; flag)</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">call_once</span>(flag, init);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::once_flag flag;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">( worker, std::ref(flag) )</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">( worker, std::ref(flag) )</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t3</span><span class="params">( worker, std::ref(flag) )</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t4</span><span class="params">( worker, std::ref(flag) )</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t5</span><span class="params">( worker, std::ref(flag) )</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    t4.<span class="built_in">join</span>();</span><br><span class="line">    t5.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>注意，我们无法确定哪个线程执行了<code>init()</code>函数，但是我们也不需要关心，因为只要有一个线程执行了<code>init()</code>函数就可以了</p>
<h3 id="并发任务"><a href="#并发任务" class="headerlink" title="并发任务"></a>并发任务</h3><p>实例：需要计算某个范围内所有数的平方根总和</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> MAX = <span class="number">10e8</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> min , <span class="type">int</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = min ; i &lt;= max; i++) &#123;</span><br><span class="line">        sum += <span class="built_in">sqrt</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task</span><span class="params">(<span class="type">int</span> min , <span class="type">int</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 得到调用func之前的时间</span></span><br><span class="line">    <span class="keyword">auto</span> start_time = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">func</span>(min , max);</span><br><span class="line">    <span class="comment">// 得到调用后func之后的时间</span></span><br><span class="line">    <span class="keyword">auto</span> end_time = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="comment">// 得到持续的时间</span></span><br><span class="line">    <span class="keyword">auto</span> ms = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(end_time - start_time).<span class="built_in">count</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Task finish, &quot;</span> &lt;&lt; ms &lt;&lt; <span class="string">&quot; ms consumed , Result: &quot;</span> &lt;&lt; sum &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">task</span>(<span class="number">1</span> , MAX);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出为</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Task finish, 1821 ms consumed , Result: 2.10819e+13</span><br></pre></td></tr></table></figure></div>

<p>很明显上面的计算使用单线程性能太差，可以使用并发进行。</p>
<ol>
<li>先获取当前硬件支持多少个线程并行执行</li>
<li>根据处理器情况决定线程数量</li>
<li>对于每一个线程都通过<code>func()</code>函数来完成任务，并划分一部分数据给它处理</li>
<li>等待每一个线程结束。</li>
</ol>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">concurrent_task</span><span class="params">(<span class="type">int</span> min , <span class="type">int</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> start_time = std::chrono::steady_clock::<span class="built_in">nowxainshi</span>();</span><br><span class="line">    <span class="comment">// 得到线程数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> concurrent_count = std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;hardware_concurrency: &quot;</span> &lt;&lt; concurrent_count &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    min = <span class="number">0</span>;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">0</span>; t &lt; concurrent_count; t++) &#123;</span><br><span class="line">        <span class="type">int</span> range = max / concurrent_count * (t + <span class="number">1</span>);</span><br><span class="line">        threads.<span class="built_in">push_back</span>(std::<span class="built_in">thread</span>(func , min , range));</span><br><span class="line">        min = range + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : threads) &#123;</span><br><span class="line">        i.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> end_time = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> ms = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(end_time - start_time).<span class="built_in">count</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Task finish, &quot;</span> &lt;&lt; ms &lt;&lt; <span class="string">&quot; ms consumed , Result: &quot;</span> &lt;&lt; sum &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>输出如下</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">hardware_concurrency: 20</span><br><span class="line">Task finish, 2086 ms consumed , Result: 1.53287e+12</span><br></pre></td></tr></table></figure></div>

<p>但是我们会发现性能并没有多少提升，并且结果还是错的。</p>
<p>要搞清楚为什么，我们需要一点背景知识</p>
<p>对于现代处理器来说，为了加速处理的速度，每个处理器都会有自己的高速缓存，这个高速缓存是与每个处理相对应的</p>
<blockquote>
<p>现在的处理器起码有三级缓存</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://ooo.0x0.ooo/2024/03/23/OgtpNY.png"
                      alt="OgtpNY.png"
                ></p>
<p>处理器在进行计算的时候，高速缓存会参与其中，例如数据的读和写。而高速缓存和系统主存（Memory）是有可能存在不一致的。即：某个结果计算后保存在处理器的高速缓存中了，但是没有同步到主存中，此时这个值对于其他处理器就是不可见的。</p>
<p>事情还没有这么简单。我们对于全局变量值的修改<code>sum += sqrt(i);</code>这条语句，它并非是原子的。它其实很多条指令的组合才完成的。假设在某个设备上，这条语句通过下面这几个步骤来完成的，时序可能如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://ooo.0x0.ooo/2024/03/23/OgtJEv.png"
                      alt="OgtJEv.png"
                ></p>
<p>如图所示，在时间点a的时候，所有线程对于<code>sum</code>变量的值是一致的。</p>
<p>但是在时间点b之后，thread3上已经对<code>sum</code>进行了赋值，而这个时候其他几个线程也同时在其他处理器上使用了这个值，那么这个时候它们所使用的值是旧的，也就是错误的。最后得到的结果也就是错误的。</p>
<h3 id="竞争条件与临界区"><a href="#竞争条件与临界区" class="headerlink" title="竞争条件与临界区"></a>竞争条件与临界区</h3><p>当多个进程或者线程同时访问共享数据时，只要有一个任务会修改数据，那么就可能会发生问题。此时结果依赖于这些任务执行的相对时间，这种场景称为<a class="link"   href="https://zhuanlan.zhihu.com/p/426072739" >竞争条件 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>访问共享数据的代码片段称之为<strong>临界区</strong>。例如上面的实例，临界区就是读写<code>sum</code>变量的地方</p>
<p>要避免竞争条件，就需要对临界区进行数据保护。</p>
<p>那么对于上面的实例的解决方法就是一次只让一个线程访问共享数据，访问完了再让其他线程接着访问，这样就可以避免问题发生了。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程-2</title>
    <url>/2024/03/23/concurrency-programming-2/</url>
    <content><![CDATA[<h1 id="互斥体与锁"><a href="#互斥体与锁" class="headerlink" title="互斥体与锁"></a>互斥体与锁</h1><h2 id="mutex"><a href="#mutex" class="headerlink" title="mutex"></a>mutex</h2><p>开发并发系统的目的主要是为了提升性能：将任务分散到多个线程，然后在不同的处理器上同时执行。这些分散开来的线程通常会包含两类任务：</p>
<ol>
<li>独立的对于划分给自己的数据进行处理</li>
<li>对于结果的汇总</li>
</ol>
<p>其中第一项任务由于每个线程都是独立的，不存在竞争条件的问题。而第二个任务，由于所有的线程都可能往总结果汇总，这就需要做保护了。<br>在某一个具体的时刻，只应当有一个线程更新结果，即：保证每个线程对于共享数据的访问是”互斥的”，<code>mutex</code>就提供了这样的功能。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>lock</td>
<td>加锁，如果不可用，则阻塞</td>
</tr>
<tr>
<td>try_lock</td>
<td>尝试加锁，如果mutex不可以用直接返回(bool)</td>
</tr>
<tr>
<td>unlock</td>
<td>解开互斥锁</td>
</tr>
</tbody></table>
<p>这三个方法提供了基础的锁定和解除锁定的功能。使用<code>lock</code>意味着你有很强的意愿一定要获取到互斥体，而使用<code>try_lock</code>则是进行一次尝试。这意味着如果失败了，你通常还有其他的路径可以走。</p>
<p>在这些基础功能之上，其他的类分别在下面三个方面进行了扩展</p>
<ul>
<li><p>超时： <code>timed_mutex</code>, <code>recursive_timed_mutex</code>, <code>shared_timed_mutex</code>的名称都带有<code>timed</code>,这意味着它们都支持超时的功能。它们都提供了<code>try_lock_for</code>和<code>try_lock_until</code>方法，这两个方法分别可以制定超时的时间长度和时间点。如果在超时的时间范围内没有能获取到锁，则直接返回，不再继续等待。</p>
</li>
<li><p>可重入：<code>rescursive_mutex</code>和<code>recursive_timed_mutex</code>的名称都带有<code>rescursive</code>。可重入或者叫做可递归，是指在同一个线程中，同一把锁可以锁定多次。这就避免了一些不必要的死锁。</p>
</li>
<li><p>共享：<code>shared_timed_mutex</code>和<code>shared_mutex</code>提供了共享功能。对于这类互斥体，实际上是提供了两把锁：一把是共享锁、一把是互斥锁。一旦某个线程获取了互斥锁，任何其他线程都无法再获取互斥锁和共享锁;但是如果有某个线程获取到了共享锁，其他线程无法再获取到互斥锁，但是还有获取到共享锁。这里互斥锁的使用和其他互斥体接口功能一样。而共享锁可以被同时多个线程获取到。共享锁通常用在<a class="link"   href="https://zhuanlan.zhihu.com/p/189993251" >读者写者模型 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>上</p>
</li>
</ul>
<p>使用共享锁的接口如下：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>lock_shared</td>
<td>获取互斥体的共享锁，如果无法获取则阻塞</td>
</tr>
<tr>
<td>try_lock_shared</td>
<td>尝试获取共享锁，如果不可用，直接返回</td>
</tr>
<tr>
<td>unlock_shared</td>
<td>解锁共享锁</td>
</tr>
</tbody></table>
<p>接下里对之前的代码进行改造</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化一个互斥锁，开全局</span></span><br><span class="line"><span class="type">static</span> std::mutex lock1;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">concurrent_func</span><span class="params">(<span class="type">int</span> min , <span class="type">int</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> tmp_sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = min ; i &lt;= max; i++) &#123;</span><br><span class="line">        tmp_sum += <span class="built_in">sqrt</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    lock1.<span class="built_in">lock</span>();</span><br><span class="line">    sum += tmp_sum;</span><br><span class="line">    lock1.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">concurrent_task</span><span class="params">(<span class="type">int</span> min , <span class="type">int</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> start_time = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="comment">// 得到线程数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> concurrent_count = std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;hardware_concurrency: &quot;</span> &lt;&lt; concurrent_count &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    min = <span class="number">0</span>;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">0</span>; t &lt; concurrent_count; t++) &#123;</span><br><span class="line">        <span class="type">int</span> range = max / concurrent_count * (t + <span class="number">1</span>);</span><br><span class="line">        threads.<span class="built_in">push_back</span>(std::<span class="built_in">thread</span>(concurrent_func , min , range));</span><br><span class="line">        min = range + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : threads) &#123;</span><br><span class="line">        i.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> end_time = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> ms = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(end_time - start_time).<span class="built_in">count</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Task finish, &quot;</span> &lt;&lt; ms &lt;&lt; <span class="string">&quot; ms consumed , Result: &quot;</span> &lt;&lt; sum &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>这里有两个地方需要关注：</p>
<ol>
<li>在访问共享数据之前加锁</li>
<li>在访问完之后解锁</li>
</ol>
<p>输出如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">hardware_concurrency: 20</span><br><span class="line">Task finish, 201 ms consumed , Result: 2.10819e+13</span><br></pre></td></tr></table></figure></div>

<p>通过多线程实现并行求容器和</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator , <span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_sum</span><span class="params">(Iterator fst , Iterator lst , T&amp; res)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> std::mutex g1;</span><br><span class="line">    <span class="keyword">auto</span> tmp_res = std::<span class="built_in">accumulate</span>(fst , lst , T&#123;&#125;);</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">g</span><span class="params">(g1)</span></span>;</span><br><span class="line">    res += tmp_res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">parallel_accumulate</span><span class="params">( Iterator fst, Iterator lst, T init )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> res = init;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span>  min_thread = <span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span>  hardware_threads = std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span>  length = std::<span class="built_in">distance</span>(fst , lst);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span>  max_thread = (length + min_thread - <span class="number">1</span>) / min_thread;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> num_threads = std::<span class="built_in">min</span>(hardware_threads ? hardware_threads : min_thread , max_thread );</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> dis = length / num_threads;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;std::thread&gt; <span class="title">threads</span><span class="params">(num_threads)</span></span>;</span><br><span class="line"></span><br><span class="line">    Iterator st = fst;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; th : threads) &#123;</span><br><span class="line">        Iterator ed = st;</span><br><span class="line">        std::<span class="built_in">advance</span>(ed , dis);</span><br><span class="line">        th = std::<span class="built_in">thread</span>(get_sum&lt;Iterator , T&gt; , st , ed , std::<span class="built_in">ref</span>(res));</span><br><span class="line">        th.<span class="built_in">join</span>();</span><br><span class="line">        st = ed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_parallel_acc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++ ) &#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>( i );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    sum     = parallel_accumulate&lt;std::vector&lt;<span class="type">int</span>&gt;::iterator, <span class="type">int</span>&gt;(</span><br><span class="line">        vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), sum );</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sum is &quot;</span> &lt;&lt; sum &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>我们通常用锁的粒度来描述锁的范围。<strong>细粒度</strong>是指锁保护较小的范围，<strong>粗粒度</strong>是指保护较大的范围。出于性能的考虑，我们应该保证锁的粒度尽可能的细。并且，不应该在获取锁的范围内执行耗时的操作，例如执行IO。如果是耗时的运算也应该尽可能的移动到锁的外边。</p>
<h2 id="锁的使用"><a href="#锁的使用" class="headerlink" title="锁的使用"></a>锁的使用</h2><ol>
<li>mutex</li>
</ol>
<p>我们可以通过<code>mutex</code>对共享数据进行加锁，防止多线程访问共享区造成数据不一致问题。如下，我们初始化一个共享变量<code>shared_data</code>,然后定义了一个互斥量<code>std::mutex</code>，接下来启动了两个线程，分别执行<code>use_lock</code>增加数据，和一个lambda表达式减少数据。结果可以看到两个线程对于共享数据的访问是独占的，单位时间片只有一个线程访问并输出日志</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">std::mutex mtx1;</span><br><span class="line"><span class="type">int</span> shared_data = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        mtx1.<span class="built_in">lock</span>();</span><br><span class="line">        shared_data++;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;current thread is &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;shared_data is &quot;</span> &lt;&lt; shared_data &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        mtx1.<span class="built_in">unlock</span>();</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">microseconds</span>(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(use_lock)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([]()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        mtx1.lock();</span></span></span><br><span class="line"><span class="params"><span class="function">        shared_data--;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::cout &lt;&lt; <span class="string">&quot;current thread is &quot;</span> &lt;&lt; std::this_thread::get_id() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::cout &lt;&lt; <span class="string">&quot;shared_data is &quot;</span> &lt;&lt; shared_data &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        mtx1.unlock();</span></span></span><br><span class="line"><span class="params"><span class="function">        std::this_thread::sleep_for(std::chrono::microseconds(<span class="number">10</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>lock_guard<blockquote>
<p>lock_guard可以自动加锁和解锁</p>
</blockquote>
</li>
</ol>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">g</span><span class="params">(mtx1)</span></span>;</span><br><span class="line">        shared_data++;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;current thread is &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;shared_data is &quot;</span> &lt;&lt; shared_data &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">microseconds</span>(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>lock_guard</code>在作用域结束时自动调用其析构函数解锁，这么做的一个好处是简化了一些特殊情况从函数返回的写法，比如异常或者条件不满足时，函数内部直接return,锁也会自动解开。</p>
<ol start="3">
<li>如何保证数据安全</li>
</ol>
<p>有时候我们可以对共享数据的访问和修改聚合到一个函数，在函数内部加锁保证数据的安全性。但是对于读取类型的操作，即使读取函数是线程安全的，但是返回值抛给外边使用，存在不安全性。比如一个栈对象，我们要保证其在多线程访问的时候是安全的，可以在判断栈是否为空，判断操作内部我们可以加锁，但是判断结束后返回值就不加锁了，就会存在线程安全问题</p>
<p>比如定义了如下栈，对于多线程的访问时判断栈是否为空，此后两个线程同时出栈，可能会造成崩溃</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsafe_stack1</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::stack&lt;T&gt; data;</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadsafe_stack1</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">threadsafe_stack1</span>(<span class="type">const</span> threadsafe_stack1&amp; other) &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">Lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        data = other.data;</span><br><span class="line">    &#125;</span><br><span class="line">    threadsafe_stack1&amp; <span class="keyword">operator</span>=(<span class="type">const</span> threadsafe_stack1&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">Lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        data.<span class="built_in">push</span>(std::<span class="built_in">move</span>(new_value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 问题代码</span></span><br><span class="line">    <span class="function">T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">Lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> element = data.<span class="built_in">top</span>();</span><br><span class="line">        data.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>如下，线程1和线程2先后判断都不为空，之后执行出栈，会造成崩溃</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_threadsafe_stack1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    threadsafe_stack1&lt;<span class="type">int</span>&gt; safe_stack;</span><br><span class="line">    safe_stack.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;safe_stack]()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::this_thread::sleep_for(std::chrono::seconds(<span class="number">1</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">        safe_stack.pop();</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;safe_stack]()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">if</span>(!safe_stack.empty()) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::this_thread::sleep_for(std::chrono::seconds(<span class="number">1</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">            safe_stack.pop();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>解决这个问题我们可以用抛出异常函数，例如定义一个空栈的异常</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">empty_stack</span> : std::exception &#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">what</span><span class="params">()</span> <span class="type">const</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>然后修改出栈函数</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">Lock</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(data.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">empty_stack</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> element = data.<span class="built_in">top</span>();</span><br><span class="line">    data.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这么做就需要在外层使用的时候捕获异常。这是C++ 并发编程中提及的建议。但是现在这个<code>pop</code>函数仍存在问题，比如<code>T</code>是一个<code>vector&lt;int&gt;</code>类型时，那么在<code>pop</code>函数内部<code>element</code>就是<code>vector&lt;int&gt;</code>类型，开始<code>element</code>存储了一些int值，程序没问题，函数执行了<code>pop</code>操作，假设此时程序内存暴增，导致当前程序使用的内存足够大时，可用的有效空间不够，函数返回<code>element</code>时，就会存在<code>vector</code>做拷贝赋值时造成失败。即使我们捕获异常，释放部分空间但也会导致栈元素已经出栈，数据丢失了。这其实是内存管理不当造成的，但书中给了优化方案</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsafe_stack1</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::stack&lt;T&gt; data;</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadsafe_stack1</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">threadsafe_stack1</span>(<span class="type">const</span> threadsafe_stack1&amp; other) &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">Lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        data = other.data;</span><br><span class="line">    &#125;</span><br><span class="line">    threadsafe_stack1&amp; <span class="keyword">operator</span>=(<span class="type">const</span> threadsafe_stack1&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">Lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        data.<span class="built_in">push</span>(std::<span class="built_in">move</span>(new_value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">Lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span>1.试图弹出前检查栈是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(data.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span>2.改动栈容器前设置返回值</span></span><br><span class="line">        <span class="function">std::shared_ptr&lt;T&gt; <span class="type">const</span> <span class="title">res</span><span class="params">(std::make_shared&lt;T&gt;(data.top()))</span></span>;</span><br><span class="line">        data.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(T&amp; value)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">Lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(data.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">empty_stack</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        value = data.<span class="built_in">top</span>();</span><br><span class="line">        data.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>我们提供了两个版本的pop操作，一个是带引用类型参数的，一个是直接pop出智能指针类型，这样在<code>pop</code>函数内部减少了数据的拷贝，防止内存溢出，其实这两种做法确实是相比之前直接<code>pop</code>固定类修能够的值更节省内存，运行效率也好很多。我们也完全可以基于之前的思想，在pop时如果栈为空返回空指针，这样比抛出异常好些</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁是如何造成的"><a href="#死锁是如何造成的" class="headerlink" title="死锁是如何造成的"></a>死锁是如何造成的</h3><p>死锁一般是调用顺序不一致而导致的。例如两个线程循环调用。当线程1先加锁A,在加锁B,而线程而先加锁B,在加锁A。那么在某一时刻就可能造成一种情况，线程1先加锁了A,线程2先加锁了B,那么他们都希望彼此占有对方的锁，又不释放自己占有的锁</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">std::mutex lock1 , lock2;</span><br><span class="line"><span class="type">int</span> m_1 = <span class="number">0</span> , m_2 = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dead_lock1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;DeadLock1 Begin\n&quot;</span>;</span><br><span class="line">        lock1.<span class="built_in">lock</span>();</span><br><span class="line">        m_1 = <span class="number">1024</span>;</span><br><span class="line">        lock2.<span class="built_in">lock</span>();</span><br><span class="line">        m_2 = <span class="number">2048</span>;</span><br><span class="line">        lock2.<span class="built_in">unlock</span>();</span><br><span class="line">        lock1.<span class="built_in">unlock</span>();</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">5</span>));</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;DeadLock1 End\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dead_lock2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;DeadLock2 Begin\n&quot;</span>;</span><br><span class="line">        lock2.<span class="built_in">lock</span>();</span><br><span class="line">        m_2 = <span class="number">2222</span>;</span><br><span class="line">        lock1.<span class="built_in">lock</span>();</span><br><span class="line">        m_1 = <span class="number">1111</span>;</span><br><span class="line">        lock1.<span class="built_in">unlock</span>();</span><br><span class="line">        lock2.<span class="built_in">unlock</span>();</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">5</span>));</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;DeadLock2 End\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call_dead_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(dead_lock1)</span> , <span class="title">t2</span><span class="params">(dead_lock2)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>() , t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这样运行之后在某一个时刻一定会导致死锁。实际工作中避免死锁的一个方式就是将加锁和解锁的功能封装为独立函数，这样能保证独立的函数里执行完操作之后就解锁，不会导致一个函数里面使用多个锁的情况。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">atomic_lock1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;AtomicLock1 Begin\n&quot;</span>;</span><br><span class="line">    lock1.<span class="built_in">lock</span>();</span><br><span class="line">    m_1 = <span class="number">1024</span>;</span><br><span class="line">    lock1.<span class="built_in">unlock</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;AtomicLock1 End\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">atomic_lock2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;AtomicLock2 Begin\n&quot;</span>;</span><br><span class="line">    lock2.<span class="built_in">lock</span>();</span><br><span class="line">    m_2 = <span class="number">2048</span>;</span><br><span class="line">    lock2.<span class="built_in">unlock</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;AtomicLock2 End\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safe_lock1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">atomic_lock1</span>();</span><br><span class="line">        <span class="built_in">atomic_lock2</span>();</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safe_lock2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">atomic_lock2</span>();</span><br><span class="line">        <span class="built_in">atomic_lock1</span>();</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call_safe_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(safe_lock1)</span> , <span class="title">t2</span><span class="params">(safe_lock2)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>() , t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="同时加锁"><a href="#同时加锁" class="headerlink" title="同时加锁"></a>同时加锁</h3><p>当我们无法避免在一个函数内部使用两个互斥量，并且都要解锁的情况下，闹我们可以采取同时加锁的方式，我们先定义一个类，假设这个类不推荐拷贝构造，但我们也提供了这个类的拷贝构造和移动构造。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">some_big_object</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">some_big_object</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">some_big_object</span>(<span class="type">int</span> item) : _data(item) &#123;&#125;</span><br><span class="line">    <span class="built_in">some_big_object</span>(<span class="type">const</span> some_big_object&amp; other) : _data(other._data) &#123;&#125;</span><br><span class="line">    <span class="built_in">some_big_object</span>(some_big_object&amp;&amp; other) : _data(std::<span class="built_in">move</span>(other._data)) &#123;&#125;</span><br><span class="line">    some_big_object&amp; <span class="keyword">operator</span>=(<span class="type">const</span> some_big_object&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span>(_data == other._data) &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _data = other._data;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os , <span class="type">const</span> some_big_object&amp; soj) &#123;</span><br><span class="line">        os &lt;&lt; soj._data;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(some_big_object&amp; o1 , some_big_object&amp; o2)</span> </span>&#123;</span><br><span class="line">        some_big_object temp = std::<span class="built_in">move</span>(o1);</span><br><span class="line">        o1 = std::<span class="built_in">move</span>(o2);</span><br><span class="line">        o2 = std::<span class="built_in">move</span>(temp);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>接下来再定义一个类对上面的类进行管理，为防止多线程情况下数据混乱，包含了一个互斥量。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">big_obj_manager</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">big_obj_manager</span>(<span class="type">int</span> data = <span class="number">0</span>) : <span class="built_in">sbo</span>(data) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printinfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The current data is: &quot;</span> &lt;&lt; sbo &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">danger_swap</span><span class="params">(big_obj_manager&amp; bo1 , big_obj_manager&amp; bo2)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">safe_swap</span><span class="params">(big_obj_manager&amp; bo1 , big_obj_manager&amp; bo2)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">safe_swap_scope</span><span class="params">(big_obj_manager&amp; bo1 , big_obj_manager&amp; bo2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    some_big_object sbo;</span><br><span class="line">    std::mutex mtx;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>为了演示哪些交换是安全的，哪些交换是危险的，所以写了三个函数</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">danger_swap</span><span class="params">(big_obj_manager&amp; bo1 , big_obj_manager&amp; bo2)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;thread[&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;] begin \n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(&amp;bo1 == &amp;bo2) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">g1</span><span class="params">(bo1.mtx)</span></span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">g2</span><span class="params">(bo2.mtx)</span></span>;</span><br><span class="line">    <span class="built_in">swap</span>(bo1.sbo , bo2.sbo);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;thread[&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;] end \n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><code>danger_swap</code>是危险的交换方式，例如如下调用</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">big_obj_manager <span class="title">o1</span><span class="params">(<span class="number">1</span>)</span> , <span class="title">o2</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(danger_swap , std::ref(o1) , std::ref(o2))</span> , <span class="title">t2</span><span class="params">(danger_swap , std::ref(o1) , std::ref(o2))</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    o1.<span class="built_in">printinfo</span>();</span><br><span class="line">    o2.<span class="built_in">printinfo</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>这种调用方式存在隐患，因为<code>danger_swap</code>函数在两个线程中使用会造成竞争互相加锁的情况。那就需要用锁同时锁住两个锁。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safe_swap</span><span class="params">(big_obj_manager&amp; bo1 , big_obj_manager&amp; bo2)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;thread[&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;] begin \n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(&amp;bo1 == &amp;bo2) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> 同时锁住两个以上的锁（最少两个）</span></span><br><span class="line">    std::<span class="built_in">lock</span>(bo1.mtx , bo2.mtx);</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">g1</span><span class="params">(bo1.mtx , std::adopt_lock)</span></span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">g2</span><span class="params">(bo2.mtx , std::adopt_lock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap</span>(bo1.sbo , bo2.sbo);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;thread[&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;] end \n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">big_obj_manager <span class="title">o1</span><span class="params">(<span class="number">1</span>)</span> , <span class="title">o2</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(safe_swap , std::ref(o1) , std::ref(o2))</span> , <span class="title">t2</span><span class="params">(danger_swap , std::ref(o1) , std::ref(o2))</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    o1.<span class="built_in">printinfo</span>();</span><br><span class="line">    o2.<span class="built_in">printinfo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>上面的加锁方式可以简化，C++17<code>scoped_lock</code>可以对多个互斥两同时加锁，同时释放</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">safe_swap_scope</span><span class="params">(big_obj_manager&amp; bo1 , big_obj_manager&amp; bo2)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;thread[&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;] begin \n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(&amp;bo1 == &amp;bo2) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::scoped_lock <span class="title">guard</span><span class="params">(bo1.mtx , bo2.mtx)</span></span>;</span><br><span class="line">    <span class="comment">// 等价于</span></span><br><span class="line">    <span class="comment">// std::scoped_lock&lt;std::mutex , std::mutex&gt; guard(bo1.mtx , bo2.mtx);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap</span>(bo1.sbo , bo2.sbo);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;thread[&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;] end \n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="层级锁"><a href="#层级锁" class="headerlink" title="层级锁"></a>层级锁</h3><p>现实开发中常常很难规避同一个函数内部多个加锁的情况，我们要尽可能避免循环加锁，所以可以自定义一个层级锁，保证实际项目中对多个互斥量加锁时是有序的。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hierarchial_mutex</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">hierarchial_mutex</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> value)</span> : _hierarchy_value(value) , _previous_hierarchy_value(<span class="number">0</span>) &#123;</span>&#125;</span><br><span class="line">    <span class="built_in">hierarchial_mutex</span>(<span class="type">const</span> hierarchial_mutex&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    hierarchial_mutex&amp; <span class="keyword">operator</span>=(<span class="type">const</span> hierarchial_mutex&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @brief: 加锁函数，先检查是否违反当前层级值，如果没有，可以加锁并且更新线程的层级值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">check_for_hierarchy_violation</span>();</span><br><span class="line">        _internal_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="built_in">update_hierarchy_value</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @brief: 解锁函数, 如果线程的层级值和当前层级值不一致，就抛出异常，否则先更新线程的层级为上一层的层级值，再解锁</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(_this_thread_hierarchy_value != _hierarchy_value) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;mutex hierarchy violated&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        _this_thread_hierarchy_value = _previous_hierarchy_value;</span><br><span class="line">        _internal_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @brief: 尝试加锁函数，先检查是否违反当前层级值，再检查锁是否可以加，最后在更新线程的层级值</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">trylock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">check_for_hierarchy_violation</span>();</span><br><span class="line">        <span class="keyword">if</span>(!_internal_mutex.<span class="built_in">try_lock</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">update_hierarchy_value</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::mutex _internal_mutex;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> 当前层级值</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> _hierarchy_value;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> 上一次层级值</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> _previous_hierarchy_value;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> 本线程记录的层级值</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">thread_local</span> <span class="type">unsigned</span> <span class="type">long</span> _this_thread_hierarchy_value;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> thread_local 关键字修饰的变量具有线程周期，这些变量在线程开始时被生成，在线程结束时被销毁，并且每一个线程都拥有一个独立的变量实例</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// @brief: 检查当前线程是否违反当前层级</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">check_for_hierarchy_violation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(_this_thread_hierarchy_value &lt;= _hierarchy_value) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;mutex hierarchy violated&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @brief: 更新线程的层级值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update_hierarchy_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        _previous_hierarchy_value = _this_thread_hierarchy_value;</span><br><span class="line">        _this_thread_hierarchy_value = _hierarchy_value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化静态成员变量</span></span><br><span class="line"><span class="keyword">thread_local</span> <span class="type">unsigned</span> <span class="type">long</span> hierarchial_mutex::_this_thread_hierarchy_value = ULONG_MAX;</span><br></pre></td></tr></table></figure></div>

<p>层级锁能保证我们每个线程加锁时，一定是先加权重最高的锁(不然会抛出异常)，并且释放时也保证了顺序。<br>主要原理就是将当前锁的权重保存在变量中，这样该线程再次加锁时判断线程变量的权重和锁的权重是否大于，如果满足条件就继续加锁。</p>
<h3 id="C-unique-lock-共享锁和递归锁"><a href="#C-unique-lock-共享锁和递归锁" class="headerlink" title="C++ unique_lock,共享锁和递归锁"></a>C++ unique_lock,共享锁和递归锁</h3><blockquote>
<p>介绍了 <code>unique_lock</code>、<code>shared_lock</code>、<code>recursive_lock</code>，其中<code>shared_lock</code>和<code>unique_lock</code>比较常用，而<code>recursive_lock</code>用得不多，尽可能规避使用这个锁</p>
</blockquote>
<h4 id="unique-lock"><a href="#unique-lock" class="headerlink" title="unique_lock"></a>unique_lock</h4><p><code>unique_lock</code>和<code>lock_guard</code>用法基本一致，构造时默认加锁，析构时默认解锁，但<code>unique_lock</code>有个好处就是可以手动解锁，这一点尤为重要，方便我们控制锁区域的粒度，也能支持和条件变量配套使用。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// unique_lock的基本用法</span></span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="type">int</span> shared_data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_unique</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Lock success \n&quot;</span>;</span><br><span class="line">    shared_data++;</span><br><span class="line">    lock.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们可以通过<code>unique_lock</code>的<code>owns_lock</code>判断是否持有锁</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">owns_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    shared_data++;</span><br><span class="line">    <span class="keyword">if</span>(lock.<span class="built_in">owns_lock</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;owns_lock\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;doesn&#x27;t own lock\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lock.<span class="built_in">unlock</span>();</span><br><span class="line">    <span class="keyword">if</span>(lock.<span class="built_in">owns_lock</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;owns_lock\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;doesn&#x27;t own lock\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>unqiue_lock</code>可以延时加锁</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">defer_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 延迟加锁</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx , std::defer_lock)</span></span>;</span><br><span class="line">    <span class="comment">// 可以加锁</span></span><br><span class="line">    lock.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="comment">// 可以自动析构解锁，也可以手动解锁</span></span><br><span class="line">    lock.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>综合运用<code>owns_lock</code>和<code>defer_lock</code></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_own_defer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">( mtx )</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( lock.<span class="built_in">owns_lock</span>() ) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Main thread has the lock\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Main thread doesn&#x27;t have the lock&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">( []() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::unique_lock&lt;std::mutex&gt; lock( mtx );</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">if</span> ( lock.owns_lock() ) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;The thread has the lock\n&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125; <span class="keyword">else</span> &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;The thread doesn&#x27;t have the lock&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        lock.lock();</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">if</span> ( lock.owns_lock() ) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;The thread has the lock\n&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125; <span class="keyword">else</span> &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;The thread doesn&#x27;t have the lock&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">        lock.unlock();</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125; )</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>上述代码会一次输出，但是程序会阻塞，因为子线程会卡在加锁的逻辑上，因为主线程为释放锁，而主线程又等待子线程推出，导致整个程序卡住</p>
<p>和<code>lock_guard</code>一样，<code>unique_lock</code>也支持领养锁</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_own_adopt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mtx.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx , std::adopt_lock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> ( lock.<span class="built_in">owns_lock</span>() ) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;owns_lock\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;doesn&#x27;t own lock\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>经管是领养的，但是打印还是会出现<code>owns_lock</code>,因为不管如何锁被加上，就会输出<code>owns_lock</code><br>既然<code>unique_lock</code>支持领养操作也支持延迟加锁，那么可以用两种方式实现<code>lock_guard</code>实现的<code>swap</code>操作</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span> , b = <span class="number">99</span>;</span><br><span class="line"></span><br><span class="line">std::mutex mtx1 , mtx2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safe_swap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">lock</span>(mtx1 , mtx2);</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(mtx1 , std::adopt_lock)</span> , <span class="title">lock2</span><span class="params">(mtx2 , std::adopt_lock)</span></span>;</span><br><span class="line">    std::<span class="built_in">swap</span>(a , b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// FIX: 错误用法</span></span><br><span class="line">    <span class="comment">// lock1.unlock();</span></span><br><span class="line">    <span class="comment">// lock2.unlock();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safe_swap2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(mtx1 , std::defer_lock)</span> , <span class="title">lock2</span><span class="params">(mtx2 , std::defer_lock)</span></span>;</span><br><span class="line">    <span class="comment">// lock1 , lock2加锁</span></span><br><span class="line">    std::<span class="built_in">lock</span>(lock1 , lock2);</span><br><span class="line">    <span class="comment">// FIX: 错误用法</span></span><br><span class="line">    <span class="comment">// std::lock(mtx1 , mtx2);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>注意</strong>， 一旦<code>mutex</code>被<code>unique_lock</code>管理，加锁和释放操作就交给<code>unique_lock</code>，不能调用<code>mutex</code>加锁和解锁，因为锁的使用权已经交给了<code>unique_lock</code></p>
<p>我们知道<code>mutex</code>是不支持拷贝和构造的，但是<code>unique_lock</code>支持移动，当一个<code>mutex</code>被转移给<code>unique_lock</code>后，可以通过<code>unique_ptr</code>转移其归属权</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">std::mutex mtx1 , mtx2 , mtx;</span><br><span class="line"><span class="type">int</span> shared_data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转移互斥量所有权</span></span><br><span class="line"><span class="comment">// 互斥量本身不支持move操作，但是unique_lock支持</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">get_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    shared_data++;</span><br><span class="line">    <span class="keyword">return</span> lock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_return</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(get_lock())</span></span>;</span><br><span class="line">    shared_data++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>锁的粒度表示加锁的精细程度，一个锁的粒度要足够大，保证可以锁住要访问的共享数据。同时一个锁的粒度要足够小，保证非共享数据不被锁住影响性能，而<code>unique_ptr</code>则很好支持手动解锁</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">precision_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    shared_data++;</span><br><span class="line">    lock.<span class="built_in">unlock</span>();</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span>不涉及共享数据的耗时操作不要放在锁内执行</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    lock.<span class="built_in">lock</span>();</span><br><span class="line">    shared_data++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h4><p>试想这样一个场景，对于一个DNS服务，我们可以根据域名查询服务对应的ip地址，它很久才更新一次，比如新增记录，删除记录或者更新记录等。平时大部分时间都是提供给外部查询，对于查询操作，即使多个线程并发查询不加锁也不会有问题，但是当有线程修改DNS服务的ip记录或者增减记录时，其他线程不能查询，需等待修改完再查询。或者等待查询完，线程才能修改。也就是说读操作并不是互斥的，同一时间可以有多个线程同时读，但是写和读是互斥的，写与写是互斥的，简而言之，写操作需要独占锁。而读操作需要共享锁。</p>
<p>要想使用共享锁，需要使用互斥量<code>std::shared_mutex</code> , <code>std::shared_mutex</code>是C++17标准提出的， C++14标准可以使用<code>std::shared_timed_mutex</code></p>
<p><code>std::shared_mutex</code>和<code>std::shared_timed_mutex</code>都是用于实现多线程并发访问共享数据的互斥锁，但它们之间存在一些区别</p>
<ol>
<li><code>std::shared_mutex</code></li>
</ol>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.* 提供了lock()和try_lock_for()以及`try_lock_until`函数，这些函数都可以用于获取互斥锁。</span><br><span class="line">2.* 提供了try_lock_shared()和lock_shared()函数，这些函数可以用于获取共享锁</span><br><span class="line">3.* 当std::shared_mutex被锁定之后，其他尝试获取该锁的线程将会被阻塞，直到该锁被解锁。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li><code>std::shared_timed_mutex</code></li>
</ol>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.* 与std::shared_mutex类似，也提供了lock() , try_lock_for() , try_lock_until() 函数用于获取互斥锁。</span><br><span class="line">2.* 与std::shared_mutex不同的是，它还提供了try_lock_shared()和lock_shared()函数用于获取共享锁，这些函数在尝试获取共享锁时具有超时机制。</span><br><span class="line">3.* 当std::shared_timed_mutex被锁定之后，其他尝试获取该锁的线程将会被阻塞，直到该锁被解锁，这与std::shared_mutex相同。然而，当尝试获取共享锁时，如果不能立即获得锁，std::shared_timed_mutex会设置一个超时，超时过后如果仍然没有获取到锁，则操作将返回失败</span><br></pre></td></tr></table></figure></div>

<p>C++11标准没有共享互斥量，可以使用boost提供的<code>boost::shared_mutex</code></p>
<p>如果我们想构造共享锁，可以使用<code>std::shared_lock</code>，如果我们想构造独占锁，可以使用<code>std::lock_guard</code></p>
<p>我们可以用一个类<code>DNService</code>表示DNS服务，查询操作使用共享锁，写操作使用独占锁</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DNService</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DNService</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">//读操作使用共享锁</span></span><br><span class="line">    <span class="function">std::string <span class="title">QueryDNS</span><span class="params">(<span class="type">const</span> std::string&amp; dnsname)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::shared_lock&lt;std::shared_mutex&gt; <span class="title">shared_locks</span><span class="params">(_shared_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> iter = _dns_info.<span class="built_in">find</span>(dnsname);</span><br><span class="line">        <span class="keyword">if</span>(iter != _dns_info.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> iter-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写操作使用独占锁</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddDNSInfo</span><span class="params">(<span class="type">const</span> std::string&amp; dnsname , <span class="type">const</span> std::string&amp; dnsentry)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::shared_mutex&gt; <span class="title">guard_locks</span><span class="params">(_shared_mutex)</span></span>;</span><br><span class="line">        _dns_info.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(dnsname , dnsentry));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::map&lt;std::string , std::string&gt; _dns_info;</span><br><span class="line">    <span class="keyword">mutable</span> std::shared_mutex _shared_mutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><code>QueryDNS</code>用来查询dns信息，多个线程可以同时访问<br><code>AddDNSInfo</code>用来写入dns信息，属于独占锁，同一时刻只有一个线程在修改</p>
<h4 id="递归锁"><a href="#递归锁" class="headerlink" title="递归锁"></a>递归锁</h4><p>有时候我们在实现接口的时候内部加锁，接口内部调用结束自动解锁。会出现一个接口调用另一个接口的情况。如果用普通的<code>std::mutex</code>就会出现卡死，因为嵌套加锁导致卡死，我们可以使用递归锁。</p>
<p>但可以从设计源头规避嵌套加锁的情况，我们可以将接口相同的功能抽象出来，统一加锁。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RecursiveDemo</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RecursiveDemo</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">QueryStudent</span><span class="params">(<span class="type">const</span> std::string &amp;name)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::recursive_mutex&gt; <span class="title">recursive_lock</span><span class="params">(_recursive_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> iter = _student_info.<span class="built_in">find</span>(name);</span><br><span class="line">        <span class="keyword">if</span>(iter == _student_info.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddScore</span><span class="params">(<span class="type">const</span> std::string &amp;name , <span class="type">const</span> <span class="type">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::recursive_mutex&gt; <span class="title">recursive_lock</span><span class="params">(_recursive_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">QueryStudent</span>(name)) &#123;</span><br><span class="line">            _student_info[name] = score;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _student_info[name] = _student_info[name] + score;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> 不推荐采用递归锁，使用递归锁说明设计思路并不理想，需要优化设计</span></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> 推荐拆分逻辑，将共有逻辑拆分为同一接口</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddScoreAtomic</span><span class="params">(<span class="type">const</span> std::string&amp; name , <span class="type">const</span> <span class="type">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::recursive_mutex&gt; <span class="title">recursive_lock</span><span class="params">(_recursive_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> iter = _student_info.<span class="built_in">find</span>(name);</span><br><span class="line">        <span class="keyword">if</span>(iter == _student_info.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            _student_info.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(name , score));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _student_info[name] = _student_info[name] + score;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::map&lt;std::string , <span class="type">int</span>&gt; _student_info;</span><br><span class="line">    std::recursive_mutex _recursive_mutex;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> recursive_mutex可以在同一个线程被锁多次</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>我们可以看到<code>AddScore</code>函数内部调用了<code>QueryStudent</code>，所以采用了递归锁，但是我们同样可以改变设计，将两者共有的部分抽离出来生成一个新的接口<code>AddScoreAtomic</code>， <code>AddScoreAtomic</code>可以不适用于递归锁，照样能完成线程安全的操作。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>CPP-类</title>
    <url>/2024/03/17/cpp-oop-1/</url>
    <content><![CDATA[<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>类就是对一种类型的抽象，例如纸箱、木箱都是箱子，箱子就是类，而木箱、纸箱就是类实例化的对象</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>类相当于定义了一个新的类型，该类型生成在堆或栈上的对象时内存排布与C语言相同。C++规定有在类对象创建时就在对应内存将数据初始化的能力，这就是构造函数</p>
<p>例子:</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">Box</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">// 普通构造函数</span></span><br><span class="line">    <span class="built_in">Box</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> <span class="type">int</span> cap) : <span class="built_in">id_</span>(name) , <span class="built_in">capacity_</span>(cap) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Box Constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 复制构造函数</span></span><br><span class="line">    <span class="built_in">Box</span>(<span class="type">const</span> Box&amp; other) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Box copy constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        id_ = other.id_;</span><br><span class="line">        capacity_ = other.capacity_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">Box</span>(Box&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Box move constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        id_ = std::<span class="built_in">move</span>(other.id_);</span><br><span class="line">        capacity_ = other.capacity_;</span><br><span class="line">        capacity_ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Box</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string id_;</span><br><span class="line">    std::<span class="type">size_t</span> capacity_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Box <span class="title">b1</span><span class="params">(<span class="string">&quot;Paper Box&quot;</span>, <span class="number">100</span>)</span></span>; <span class="comment">// 创建一个对象</span></span><br><span class="line">    <span class="function">Box <span class="title">b2</span><span class="params">(b1)</span></span>; <span class="comment">// 复制一个对象</span></span><br><span class="line">    Box b3 = std::<span class="built_in">move</span>(b2); <span class="comment">// 移动构造</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>输出如下</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Box Constructor</span><br><span class="line">Box copy constructor</span><br><span class="line">Box move constructor</span><br></pre></td></tr></table></figure></div>

<p>上面的例子演示了构造函数的几种类型:</p>
<ul>
<li>普通构造函数: 如代码所示</li>
<li>复制构造函数：用另一个对象来初始化对象</li>
<li>移动构造函数：用另一个对象来初始化对象, 可以避免复制带来的开销</li>
<li>默认构造函数：当没有定义任何构造函数时，编译器会为该类生成一个默认构造函数，默认构造函数什么都没做，内存没被初始化 例如<code>Box() &#123;&#125;</code></li>
</ul>
<h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>当类对象被销毁时，就会调用析构函数。栈上对象的销毁就是函数栈的销毁时</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">Box</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">// 普通构造函数</span></span><br><span class="line">    <span class="built_in">Box</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> <span class="type">int</span> cap) : <span class="built_in">id_</span>(name) , <span class="built_in">capacity_</span>(cap) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Box Constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 复制构造函数</span></span><br><span class="line">    <span class="built_in">Box</span>(<span class="type">const</span> Box&amp; other) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Box copy constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        id_ = other.id_;</span><br><span class="line">        capacity_ = other.capacity_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">Box</span>(Box&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Box move constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        id_ = std::<span class="built_in">move</span>(other.id_);</span><br><span class="line">        capacity_ = other.capacity_;</span><br><span class="line">        capacity_ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Box</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Box destructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string id_;</span><br><span class="line">    std::<span class="type">size_t</span> capacity_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Box <span class="title">b1</span><span class="params">(<span class="string">&quot;Paper Box&quot;</span>, <span class="number">100</span>)</span></span>; <span class="comment">// 创建一个对象</span></span><br><span class="line">    <span class="function">Box <span class="title">b2</span><span class="params">(b1)</span></span>; <span class="comment">// 复制一个对象</span></span><br><span class="line">    Box b3 = std::<span class="built_in">move</span>(b2); <span class="comment">// 移动构造</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出如下</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Box Constructor</span><br><span class="line">Box copy constructor</span><br><span class="line">Box move constructor</span><br><span class="line">Box destructor</span><br><span class="line">Box destructor</span><br><span class="line">Box destructor</span><br></pre></td></tr></table></figure></div>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>构造函数就是C++提供的<strong>必须有的</strong>在对象创建时初始化对象的方法(默认什么都不做也是一种初始化的方式)</p>
</li>
<li><p>当类对象销毁时有一些我们必须手动操作的步骤时，析构函数就派上了用场（例如手动释放内存</p>
</li>
</ol>
<p>所以，几乎所有的类都需要写一个构造函数，但是析构函数却未必需要</p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程-3</title>
    <url>/2024/03/26/concurrency-programming-3/</url>
    <content><![CDATA[<h1 id="利用条件变量实现线程安全队列"><a href="#利用条件变量实现线程安全队列" class="headerlink" title="利用条件变量实现线程安全队列"></a>利用条件变量实现线程安全队列</h1><blockquote>
<p>本文介绍如何使用条件变量控制并发的同步操作  </p>
</blockquote>
<h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p>试想有一个线程A一直输出1，另一个线程B一直输出2。我想让两个线程交替输出1，2，1，2…之类的效果，该如何实现？有的同学可能会说不是有互斥量mutex吗？可以用一个全局变量num表示应该哪个线程输出，比如num为1则线程A输出1，num为2则线程B输出2，mutex控制两个线程访问num，如果num和线程不匹配，就让该线程睡一会，这不就实现了吗？比如线程A加锁后发现当前num为2则表示它不能输出1，就解锁，将锁的使用权交给线程A，线程B就sleep一会。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PoorImplemention</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">( []() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> ( <span class="literal">true</span> ) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::lock_guard&lt;std::mutex&gt; lock( mtx );</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">if</span> ( num == <span class="number">1</span> ) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                    std::cout &lt;&lt; <span class="string">&quot;This thread A print &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">                    ;</span></span></span><br><span class="line"><span class="params"><span class="function">                    num++;</span></span></span><br><span class="line"><span class="params"><span class="function">                &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::this_thread::sleep_for( std::chrono::seconds( <span class="number">1</span> ) );</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125; )</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">( []() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> ( <span class="literal">true</span> ) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::lock_guard&lt;std::mutex&gt; lock( mtx );</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">if</span> ( num == <span class="number">2</span> ) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                    std::cout &lt;&lt; <span class="string">&quot;This thread B print &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">                    num--;</span></span></span><br><span class="line"><span class="params"><span class="function">                &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::this_thread::sleep_for( std::chrono::seconds( <span class="number">1</span> ) );</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125; )</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>(), t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><code>PoorImplement</code>虽然能实现我们交替打印的功能，会造成消息处理的不及时处理，因为线程A要循环检测<code>num</code>值，如果<code>num</code>不为1,则线程A就睡眠了，在线程A睡眠这段时间里面很可能线程B已经处理完了，此时A还在睡眠，是对资源的浪费，也错过了最佳的处理时机。所以我们提出了用条件变量来通知线程的机制，当线程A发现条件不满足时可以挂起，等待线程B通知，线程B通知线程A后，A被唤醒继续处理</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cvA , cvB;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReasonableImplemention</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">( []() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> ( <span class="literal">true</span> ) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::unique_lock&lt;std::mutex&gt; lock(mtx);</span></span></span><br><span class="line"><span class="params"><span class="function">            cvA.wait(lock , []()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">return</span> num == <span class="number">1</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;);</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">            num++;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;Thread A print 1....&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            cvB.notify_one();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125; )</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">( []() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> ( <span class="literal">true</span> ) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::unique_lock&lt;std::mutex&gt; lock(mtx);</span></span></span><br><span class="line"><span class="params"><span class="function">            cvB.wait(lock , []()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">return</span> num == <span class="number">2</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;);</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">            num--;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;Thread B print 2....&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            cvA.notify_one();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125; )</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>(), t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>当条件不满足时(num !&#x3D; 1)<code>cvA.wait</code>就会挂起，等待线程B通知线程A唤醒，线程B采用<code>cvA.notify_one</code>。这么做的好处是线程交替处理十分及时，比起<code>sleep</code>的方式，我们可以从控制台看出差异效果，<code>sleep</code>的方式看出日志基本是每隔1秒才打印一次，效率不高</p>
<h2 id="线程安全队列"><a href="#线程安全队列" class="headerlink" title="线程安全队列"></a>线程安全队列</h2><p>之前我们实现过线程安全的栈，对于pop操作，我们如果在线程中调用empty判断是否为空，如果不为空，则pop，因为empty和pop内部分别加锁，是两个原子操作，导致pop时可能会因为其他线程提前pop导致队列为空，从而引发崩溃。我们当时的处理方式是实现了两个版本的pop，一种是返回智能指针类型，一种通过参数为引用的方式返回。对于智能指针版本我们发现队列为空则返回空指针，对于引用版本，<br>发现队列为空则抛出异常，这么做并不是很友好，所以我们可以通过条件变量完善之前的程序，不过这次我们重新实现一个线程安全队列。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Queue_Thread_Safe</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::queue&lt;T&gt; data_;</span><br><span class="line">    std::mutex mtx_;</span><br><span class="line">    std::condition_variable cvq_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Queue_Thread_Safe</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Queue_Thread_Safe</span>( <span class="type">const</span> Queue_Thread_Safe &amp; );</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">( T &amp;&amp; )</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wait_and_pop</span><span class="params">( T &amp;&amp; )</span></span>;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">wait_and_pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">try_pop</span><span class="params">( T&amp; )</span></span>;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Queue_Thread_Safe&lt;T&gt;::<span class="built_in">Queue_Thread_Safe</span>( <span class="type">const</span> Queue_Thread_Safe &amp;other ) &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">( other.mtx_ )</span></span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;data_ = other.data_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> Queue_Thread_Safe&lt;T&gt;::<span class="built_in">push</span>( T &amp;&amp;param ) &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">( mtx_ )</span></span>;</span><br><span class="line">    data_.<span class="built_in">emplace</span>( param );</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> 这里通知线程是因为如果别的线程有pop操作，由于队列可能是空的会被挂起，所以要通知一个线程</span></span><br><span class="line">    cvq_.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> Queue_Thread_Safe&lt;T&gt;::<span class="built_in">wait_and_pop</span>( T &amp;&amp;value ) &#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">( mtx_ )</span></span>;</span><br><span class="line">    cvq_.<span class="built_in">wait</span>( lock, [<span class="keyword">this</span>]() &#123; <span class="keyword">return</span> !data_.<span class="built_in">empty</span>(); &#125; );</span><br><span class="line">    value = data_.<span class="built_in">front</span>();</span><br><span class="line">    data_.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; std::shared_ptr&lt;T&gt; Queue_Thread_Safe&lt;T&gt;::<span class="built_in">wait_and_pop</span>() &#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">( mtx_ )</span></span>;</span><br><span class="line">    cvq_.<span class="built_in">wait</span>( lock, [<span class="keyword">this</span>]() &#123; <span class="keyword">return</span> !data_.<span class="built_in">empty</span>(); &#125; );</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">res</span><span class="params">( std::make_shared&lt;T&gt;( data_.front() ) )</span></span>;</span><br><span class="line">    data_.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">bool</span> Queue_Thread_Safe&lt;T&gt;::<span class="built_in">try_pop</span>(T&amp; value) &#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    value = data_.<span class="built_in">front</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::shared_ptr&lt;T&gt; Queue_Thread_Safe&lt;T&gt;::<span class="built_in">try_pop</span>() &#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    cvq_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]()&#123;</span><br><span class="line">        <span class="keyword">return</span> !data_.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">res</span><span class="params">( std::make_shared&lt;T&gt;(data_.front()) )</span></span>;</span><br><span class="line">    data_.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">bool</span> Queue_Thread_Safe&lt;T&gt;::<span class="built_in">empty</span>() &#123;</span><br><span class="line">    <span class="comment">// WARN:这里记得要加个锁，因为在判断队列是否为空的时候，要保证状态一致</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> data_.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_thread_safe_queue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    thread_safe_queue&lt;<span class="type">int</span>&gt; safe_queue;</span><br><span class="line">    std::mutex mtx_print;</span><br><span class="line">    <span class="function">std::thread <span class="title">producer</span><span class="params">( [&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>;; i++ ) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            safe_queue.push( std::forward&lt;<span class="keyword">decltype</span>(i)&gt;(i) );</span></span></span><br><span class="line"><span class="params"><span class="function">            &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::lock_guard&lt;std::mutex&gt; lock_print( mtx_print );</span></span></span><br><span class="line"><span class="params"><span class="function">                std::cout &lt;&lt; <span class="string">&quot;producer push data is &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::this_thread::sleep_for( std::chrono::milliseconds( <span class="number">200</span> ) );</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125; )</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">consumer1</span><span class="params">( [&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> ( <span class="literal">true</span> ) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">auto</span> data = safe_queue.wait_and_pop();</span></span></span><br><span class="line"><span class="params"><span class="function">            &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::lock_guard&lt;std::mutex&gt; lock_print( mtx_print );</span></span></span><br><span class="line"><span class="params"><span class="function">                std::cout &lt;&lt; <span class="string">&quot;consumer1 wait and pop data is &quot;</span> &lt;&lt; *data</span></span></span><br><span class="line"><span class="params"><span class="function">                          &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::this_thread::sleep_for( std::chrono::milliseconds( <span class="number">500</span> ) );</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125; )</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">consumer2</span><span class="params">( [&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> ( <span class="literal">true</span> ) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">auto</span> data = safe_queue.try_pop();</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">if</span> ( data != <span class="literal">nullptr</span> ) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                    std::lock_guard&lt;std::mutex&gt; lock_print( mtx_print );</span></span></span><br><span class="line"><span class="params"><span class="function">                    std::cout &lt;&lt; <span class="string">&quot;consumer2 try pop data is &quot;</span> &lt;&lt; *data</span></span></span><br><span class="line"><span class="params"><span class="function">                              &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">                &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::this_thread::sleep_for( std::chrono::milliseconds( <span class="number">500</span> ) );</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125; )</span></span>;</span><br><span class="line"></span><br><span class="line">    producer.<span class="built_in">join</span>();</span><br><span class="line">    consumer1.<span class="built_in">join</span>();</span><br><span class="line">    consumer2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出如下:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">producer push data is 0</span><br><span class="line">consumer1 wait and pop data is 0</span><br><span class="line">producer push data is 1</span><br><span class="line">producer push data is 2</span><br><span class="line">consumer2 try pop data is 1</span><br><span class="line">consumer1 wait and pop data is 2</span><br><span class="line">producer push data is 3</span><br><span class="line">producer push data is 4</span><br><span class="line">consumer1 wait and pop data is 3</span><br><span class="line">consumer2 try pop data is 4</span><br><span class="line">producer push data is 5</span><br><span class="line">producer push data is 6</span><br><span class="line">producer push data is 7</span><br><span class="line">consumer2 try pop data is 5</span><br><span class="line">consumer1 wait and pop data is 6</span><br><span class="line">producer push data is 8</span><br><span class="line">producer push data is 9</span><br><span class="line">consumer2 try pop data is 7</span><br><span class="line">consumer1 wait and pop data is 8</span><br><span class="line">producer push data is 10</span><br><span class="line">producer push data is 11</span><br><span class="line">producer push data is 12</span><br><span class="line">consumer2 try pop data is 9</span><br><span class="line">consumer1 wait and pop data is 10</span><br><span class="line">producer push data is 13</span><br><span class="line">producer push data is 14</span><br><span class="line">consumer2 try pop data is 11</span><br><span class="line">consumer1 wait and pop data is 12</span><br><span class="line">producer push data is 15</span><br><span class="line">producer push data is 16</span><br></pre></td></tr></table></figure></div>

<h1 id="C-异步"><a href="#C-异步" class="headerlink" title="C++异步"></a>C++异步</h1><p>在C++中<code>future</code>, <code>promise</code>和<code>async</code>是C++标准库中的一些重要概念，它们可以用于实现异步编程。它们的具体用法可以参考<a class="link"   href="https://en.cppreference.com/w/cpp/thread/future" >官方文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<h2 id="async用法"><a href="#async用法" class="headerlink" title="async用法"></a>async用法</h2><p><code>std::async</code>是用于异步执行函数的函数模板，它返回一个<code>future</code>对象，该对象用于获取函数的返回值</p>
<p>例子:</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个异步任务</span></span><br><span class="line"><span class="function">std::string <span class="title">FetchFromDB</span><span class="params">(<span class="type">const</span> std::string&amp; query)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//模拟一个异步任务，比如从数据库中获取数据</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">200</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Data: &quot;</span> + query;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">async_demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> 使用std::async异步调用FetchFromDB</span></span><br><span class="line">    std::future&lt;std::string&gt; resultFromDB = std::<span class="built_in">async</span>(std::launch::async , FetchFromDB , <span class="string">&quot;Data&quot;</span>);</span><br><span class="line">    <span class="comment">// 主线程中做其他事情</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Doing something else&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 从future对象中获取数据</span></span><br><span class="line">    std::string dbData = resultFromDB.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; dbData &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">async_demo</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在这个事例中，<code>std::async</code>创建了一个新的线程(或从内部线程池中挑选了一个线程)并自动与一个<code>std::promise</code>对象相关联。<code>std::promise</code>对象被传递给<code>FetchFromDB</code>函数，函数返回值被存储在<code>std::future</code>对象中，在主线程中，我们可以使用<code>std::future::get</code>方法从<code>std::future</code>对象中获取数据。注意，在使用<code>std::async</code>的情况下，我们必须使用<code>std::launch::async</code>标志来明确表示我们希望函数异步执行。</p>
<p>输出如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Doing something else</span><br><span class="line">Data: Data</span><br></pre></td></tr></table></figure></div>

<h2 id="async的启动策略"><a href="#async的启动策略" class="headerlink" title="async的启动策略"></a>async的启动策略</h2><p><code>std::async</code>函数可以接受几个不同的启动策略，这些策略在<code>std::launch</code>枚举中定义。除了<code>std::launch::async</code>之外，还有以下启动策略</p>
<ol>
<li><code>std::launch::deferred</code>:这种策略意味着任务将在调用<code>std::future::get()</code>或<code>std::future::wait()</code>函数时延迟执行。换句话说，任务将在需要结果时同步执行。</li>
<li><code>std::launch::async | std::launch::deferred</code>: 这种策略是上面两个策略的组合。任务可以在一个单独的线程上异步执行，也可以延迟执行，具体取决于实现。</li>
</ol>
<p>默认情况下，<code>std::async</code>使用<code>std::launch::async|std::launch::deferred</code>策略。这意味着任务可能异步执行，也可能延迟执行，具体取决于实现。需要注意的是，不同的编译器和操作系统可能会有不同的默认行为。</p>
<h2 id="future的wait和get"><a href="#future的wait和get" class="headerlink" title="future的wait和get"></a>future的wait和get</h2><p><code>std::future::get()</code>和<code>std::future::wait()</code>是c++中用于处理异步人物的两个方法，它们的功能和用法有一些重要区别。</p>
<ol>
<li>std::future::get()</li>
</ol>
<p><code>std::future::get()</code>是一个阻塞调用，用于获取<code>std::future</code>对象表示的值或异常。如果异步任务还没有完成，<code>get()</code>会阻塞当前线程，直到任务完成。如果任务已经完成，<code>get()</code>会立即返回结果。重要的是，<code>get()</code>只能调用一次，因为它会移动或消耗掉<code>std::future</code>对象的状态。一旦<code>get()</code>被调用，<code>std::future</code>对象就不能再被用来获取结果。</p>
<ol start="2">
<li>std::future::wait()</li>
</ol>
<p><code>std::future::wait</code>也是一个阻塞调用，但它与<code>get()</code>的主要区别在与<code>wait()</code>不会返回任务的结果。它只是等待异步任务完成。如果任务已经完成，<code>wait()</code>会立即返回。如果任务没有完成，<code>wait()</code>会阻塞当前线程，直到任务完成。与<code>get()</code>不同，<code>wait()</code>可以被多次调用，它不会消耗掉<code>std::future</code>对象的状态。</p>
<p>总结：</p>
<ul>
<li><code>std::future::get()</code>用于获取并返回任务的结果，而<code>std::future::wait()</code>只是等待任务完成。</li>
<li><code>get()</code>只能被调用一次，而<code>wait()</code>可以被多次调用。</li>
<li>如果任务还没有完成，<code>get()</code>和<code>wait()</code>都会阻塞当前线程，但<code>get()</code>会一直阻塞知道任务完成并返回结果，而<code>wait()</code>只是在等待任务完成。</li>
</ul>
<p>你可以使用<code>std::future</code>的<code>wait_for()</code>或<code>wait_until()</code>方法来检查异步操作是否完成。这些方法返回一个表示操作状态的<code>std::future_status</code>的值</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(fut.<span class="built_in">wait_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">0</span>)) == std::future_status::ready) &#123;</span><br><span class="line"><span class="comment">// 操作完成</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 操作尚未完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="将任务和future关联"><a href="#将任务和future关联" class="headerlink" title="将任务和future关联"></a>将任务和future关联</h3><p><code>std::packaged_task</code>和<code>std::future</code>是C++11中引入的两个类，它们用于处理异步任务的结果。</p>
<p><code>std::packaged_task</code>是一个可调用目标，它包装了一个任务，该任务可以在另一个线程上运行。它可以捕获任务的返回值或异常，并将其存储在<code>std::future</code>对象中，一边以后使用。</p>
<p>以下是使用<code>std::packaged_task</code>和<code>std::future</code>对象的基本步骤：</p>
<ol>
<li>创建一个<code>std::packaged_task</code>对象，该对象包装了要执行的任务。</li>
<li>调用<code>std::packaged_task</code>对象的<code>get_future()</code>方法，该方法返回一个与任务关联的<code>std::future</code>对象</li>
<li>在另一个线程上调用<code>std::packaged_task</code>对象的<code>operator()</code>，用于执行任务</li>
<li>在需要任务结果的地方，调用与任务关联的<code>std::future</code>对象的<code>get()</code>方法，以获取任务的返回值或异常</li>
</ol>
<p>例子:</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">mytask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;my task run 5s&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">52</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_package</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建了一个包装了任务的std::packaged_task对象</span></span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">(mytask)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取与任务关联的std::future对象</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; result = task.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在另一个线程上执行任务</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(std::move(task))</span></span>; <span class="comment">// <span class="doctag">NOTE:</span> std::packaged_task对象不能被复制，只能移动。因为std::packaged_task内部保存了一个对应的执行任务，这个任务应该被唯一执行，并且任务的结果也应该唯一保存，因此不允许复制，只能移动。</span></span><br><span class="line">    t.<span class="built_in">detach</span>(); <span class="comment">// 将线程与主线程分离，以便主线程可以等待任务完成</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待任务完成并获取结果</span></span><br><span class="line">    <span class="type">int</span> value = result.<span class="built_in">get</span>(); <span class="comment">// get在获取结果之前会阻塞当前线程</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The result is: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在上面的实例中，我们创建了一个包装了任务的<code>std::packaged_task</code>对象，并获取了与任务关联的<code>std::future</code>对象，然后，我们在另一个线程上执行任务，并等待任务完成并获取结果。最后，我们输出结果。</p>
<p>我们可以使用<code>std::function</code>和<code>std::packaged_task</code>来包装带参数的函数。<code>std::packaged_task</code>是一个模板类，他包装了一个可调用对象，并允许我们将其作为异步任务传递。</p>
<h2 id="promise的用法"><a href="#promise的用法" class="headerlink" title="promise的用法"></a>promise的用法</h2><p>C++11引入了<code>std::promise</code>和<code>std::future</code>两个类，用于实现异步编程。<code>std::promise</code>用于在某一线程中设置某个值或异常，而<code>std::future</code>则用于在另一线程中获取这个值或异常。</p>
<p>例子：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_value</span><span class="params">(std::promise&lt;<span class="type">int</span>&gt; prom)</span> </span>&#123;</span><br><span class="line">    prom.<span class="built_in">set_value</span>(<span class="number">10</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;promise set value successfully by the thread\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">promise_demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; prom;</span><br><span class="line"></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; fut = prom.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(set_value , std::move(prom))</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Waiting for the thread to set value ...\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value set by the thread: &quot;</span> &lt;&lt; fut.<span class="built_in">get</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>输出:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Waiting for the thread to set value ...</span><br><span class="line">Value set by the thread: promise set value successfully by the thread</span><br><span class="line">10</span><br></pre></td></tr></table></figure></div>

<p>在上面的代码中，我们首先创建了一个<code>std::promise&lt;int&gt;</code>对象，然后通过调用<code>get_future()</code>方法获取与之相关联的<code>std::future&lt;int&gt;</code>对象。然后，我们在新线程中通过调用<code>set_value()</code>方法设置<code>promise</code>的值，并在主线程中通过调用<code>fut.get()</code>方法获取这个值。注意，在调用<code>fut.get()</code>方法时，如果<code>promise</code>的值还没有被设置，则该方法会阻塞当前线程，直到值被设置为止。</p>
<p>除了<code>set_value</code>方法外，<code>std::promise</code>还有一个<code>set_exception()</code>方法，用于设置异常。该方法接受一个<code>std::exception_ptr</code>参数，该参数可以通过调用<code>std::current_exception()</code>方法获取。</p>
<p>例子如下：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_exception</span><span class="params">(std::promise&lt;<span class="type">void</span>&gt; prom)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 抛出一个异常</span></span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;An error occurred\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="built_in">catch</span>(...) &#123; <span class="comment">// <span class="doctag">NOTE:</span> ... 表示捕获任意类型的异常</span></span><br><span class="line">        <span class="comment">// 设置promise的异常</span></span><br><span class="line">        prom.<span class="built_in">set_exception</span>(std::<span class="built_in">current_exception</span>());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">promise_exception_demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">void</span>&gt; prom;</span><br><span class="line">    <span class="comment">// 获取与promise相关联的对象</span></span><br><span class="line">    std::future&lt;<span class="type">void</span>&gt; fut = prom.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="comment">// 创建一个线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(set_exception , std::move(prom))</span></span>;</span><br><span class="line">    <span class="comment">// 在主线程获取future的异常</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Waiting for the thread to set exception....\n&quot;</span>;</span><br><span class="line">        fut.<span class="built_in">get</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span>(<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Exception set by the thread: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出如下</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Waiting for the thread to set exception....</span><br><span class="line">Exception set by the thread: An error occurred</span><br></pre></td></tr></table></figure></div>

<p>当然我们在使用<code>std::promise</code>时要注意一点，如果<code>std::promise</code>被释放了，而其他线程还未使用与<code>std::promise</code>关联的future,当其使用这个<code>std::future</code>时会报错。</p>
<p>例子：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_promise_destruct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::thread t;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; fut;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        std::promise&lt;<span class="type">int</span>&gt; prom;</span><br><span class="line">        fut = prom.<span class="built_in">get_future</span>();</span><br><span class="line">        t = std::<span class="built_in">thread</span>(set_value , std::<span class="built_in">move</span>(prom));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Waiting for the thread to set value ...\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value set by the thread: &quot;</span> &lt;&lt; fut.<span class="built_in">get</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>随着局部<code>&#125;</code>的结束，<code>prom</code>可能被释放也可能会被延迟释放，如果立即释放则<code>fut.get()</code>获取的值会报<code>error_value</code>的错误</p>
<h2 id="共享型的future"><a href="#共享型的future" class="headerlink" title="共享型的future"></a>共享型的future</h2><p>当我们需要多个线程等待同一个执行结果时，需要使用<code>std::shared_future</code></p>
<p>以下是一个适合使用<code>std::shared_future</code>的场景，多个线程等待一个异步操作的结果</p>
<p>假设你有一个异步任务，需要多个线程等待其完成，然后这些线程需要访问任务的结果。在这种情况下，你可以使用<code>std::shared_future</code>来共享异步结果</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">(std::promise&lt;<span class="type">int</span>&gt;&amp;&amp; prom)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟一些工作</span></span><br><span class="line"></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    prom.<span class="built_in">set_value</span>(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">(std::shared_future&lt;<span class="type">int</span>&gt; fut)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="type">int</span> result = fut.<span class="built_in">get</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125; <span class="built_in">catch</span>(<span class="type">const</span> std::future_error&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Future error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shared_future_demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; prom;</span><br><span class="line">    std::shared_future&lt;<span class="type">int</span>&gt; shared_fut = prom.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> 第一个线程先去执行任务，后面两个线程等待std::shared_future的值</span></span><br><span class="line">    <span class="function">std::thread <span class="title">myThread1</span><span class="params">(myFunction , std::move(prom))</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">myThread2</span><span class="params">(threadFunction, shared_fut)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">myThread3</span><span class="params">(threadFunction , shared_fut)</span></span>;</span><br><span class="line">    myThread1.<span class="built_in">join</span>() , myThread2.<span class="built_in">join</span>() , myThread3.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>我们创建了一个<code>std::promise&lt;int&gt;</code>对象<code>prom</code>和一个与之关联的<code>std::shared_future&lt;int&gt;</code>对象<code>shared_fut</code>。然后我们将<code>promise</code>对象移动到另一个线程<code>myThread1</code>中，该线程将执行<code>myFunction</code>函数，并在完成后设置<code>prom</code>的值，那么<code>shared_fut.get()</code>将返回该值。这些线程可以同时访问和等待<code>future</code>对象的结果，而不会相互干扰</p>
<p>注意，如果一个<code>future</code>被移动给两个<code>shared_future</code>是错误的</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">(std::shared_future&lt;<span class="type">int</span>&gt; fut)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="type">int</span> result = fut.<span class="built_in">get</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125; <span class="built_in">catch</span>(<span class="type">const</span> std::future_error&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Future error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shared_future_demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; prom;</span><br><span class="line">    std::shared_future&lt;<span class="type">int</span>&gt; shared_fut = prom.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">myThread1</span><span class="params">(myFunction , std::move(prom))</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">myThread2</span><span class="params">(threadFunction, std::move(shared_fut))</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">myThread3</span><span class="params">(threadFunction , std::move(shared_fut))</span></span>;</span><br><span class="line">    myThread1.<span class="built_in">join</span>() , myThread2.<span class="built_in">join</span>() , myThread3.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>这种用法是错误的，一个<code>future</code>通过隐式构造传递给<code>shared_future</code>之后，这个<code>shared_future</code>被移动传递给两个线程是不合理的，因为第一次移动之后<code>shared_future</code>的生命周期被转移了，接下俩<code>myThread3</code>构造时用的<code>std::move(future)</code>future已经失效了，会报错，一般都是<code>no state</code>之类的错误。</p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p><code>std::future</code>是一个模板类，它用于表示一个可能还没有准备好的异步操作的结果。你可以通过调用<code>std::future::get()</code>方法来获取这个结果。如果在获取结果是发生了异常，那么<code>std::future::get()</code>会重新抛出这个异常</p>
<p>例子：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">may_throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Oops, something went wrong!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_future_error</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个异步任务</span></span><br><span class="line">    <span class="function">std::future&lt;<span class="type">void</span>&gt; <span class="title">result</span><span class="params">(std::async(std::launch::async , may_throw))</span></span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result.<span class="built_in">get</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span>(<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Caught exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在这个例子中，我们创建了一个异步任务<code>may_throw</code>，这个任务会抛出一个异常。然后，我们创建一个<code>std::future</code>对象<code>result</code>来表示这个任务的结果。在<code>get_future_error</code>函数中，我们调用<code>result.get()</code>来获取任务的结果。如果在获取结果时发生了异常，那么<code>result.get()</code>会重新抛出这个异常，然后我们在<code>catch</code>块中捕获了并打印这个异常。</p>
<p>输出：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Caught exception: Oops, something went wrong!</span><br></pre></td></tr></table></figure></div>

<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>我们可以利用上面提到的<code>std::packaged_task</code>和<code>std::promise</code>构建线程池，提高程序的并发能力</p>
<p>线程池的知识:</p>
<p>线程池是一种多线程处理形式，它处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。如果某个线程在托管代码中空闲（如正在等待某个事件）,则线程池将插入另一个辅助线程来使所有处理器保持繁忙。如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后创建另一个辅助线程但线程的数目永远不会超过最大值。超过最大值的线程可以排队，但他们要等到其他线程完成后才启动。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">TD</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ThreadPool</span>( <span class="type">const</span> ThreadPool &amp; )            = <span class="keyword">delete</span>;</span><br><span class="line">    ThreadPool &amp;<span class="keyword">operator</span>=( <span class="type">const</span> ThreadPool &amp; ) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> ThreadPool &amp;<span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> ThreadPool ins;</span><br><span class="line">        <span class="keyword">return</span> ins;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> Task = std::packaged_task&lt;<span class="built_in">void</span>()&gt;;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ThreadPool</span>() &#123; <span class="built_in">stop</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> 用于将任务队列中的任务提交到pool_里面</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">class</span>... Args&gt;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">commit</span><span class="params">( F &amp;&amp;func, Args &amp;&amp;...args )</span></span></span><br><span class="line"><span class="function">        -&gt; std::future&lt;<span class="title">decltype</span><span class="params">( func( args... ) )</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> RetType = <span class="keyword">decltype</span>( <span class="built_in">func</span>( args... ) );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( stop_.<span class="built_in">load</span>() ) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">NOTE:</span> 这里如果触发异常处理，可以通过异常处理来了解状态</span></span><br><span class="line">            <span class="keyword">return</span> std::future&lt;RetType&gt;&#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span>关于这里为什么要使用std::shared_ptr</span></span><br><span class="line">        <span class="comment">// 1.</span></span><br><span class="line">        <span class="comment">// 避免对象过早的销毁，我们通常需要在另一个线程中执行task,可能会在创建的作用域之外。</span></span><br><span class="line">        <span class="comment">// 2.</span></span><br><span class="line">        <span class="comment">// 允许对象的共享，比如说，你可以在一个线程中安排一个任务，并在另一个线程中等待该任务完成并获取其结果。</span></span><br><span class="line">        <span class="comment">// 这样的话，任务对象就需要在多个线程中共享，而</span></span><br><span class="line">        <span class="comment">// std::shared_ptr 正好可以满足这个要求。</span></span><br><span class="line">        <span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">RetType</span>()&gt;&gt;(</span><br><span class="line">            std::<span class="built_in">bind</span>( std::forward&lt;F&gt;( func ), std::forward&lt;Args&gt;( args )... ) );</span><br><span class="line"></span><br><span class="line">        std::future&lt;RetType&gt; ret = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">cv_mt</span><span class="params">( cv_mt_ )</span></span>;</span><br><span class="line">            tasks_.<span class="built_in">emplace</span>( [task] &#123; ( *task )(); &#125; );</span><br><span class="line">        &#125;</span><br><span class="line">        cv_lock_.<span class="built_in">notify_one</span>();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">idleThreadCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> thread_num_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">ThreadPool</span>( <span class="type">unsigned</span> <span class="type">int</span> num = <span class="number">5</span> ) : <span class="built_in">stop_</span>( <span class="literal">false</span> ) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( num &lt; <span class="number">1</span> ) &#123;</span><br><span class="line">            thread_num_ = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            thread_num_ = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">start</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; thread_num_; i++ ) &#123;</span><br><span class="line">            pool_.<span class="built_in">emplace_back</span>( [<span class="keyword">this</span>]() &#123;</span><br><span class="line">                <span class="keyword">while</span> ( !<span class="keyword">this</span>-&gt;stop_.<span class="built_in">load</span>() ) &#123;</span><br><span class="line">                    Task task;</span><br><span class="line">                    std::unique_lock&lt;std::mutex&gt; <span class="built_in">cv_mt</span>( cv_mt_ );</span><br><span class="line">                    <span class="keyword">this</span>-&gt;cv_lock_.<span class="built_in">wait</span>( cv_mt, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">                        <span class="comment">// <span class="doctag">NOTE:</span> 当stop_为true,或者任务队列不空时，线程都会醒来。</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;stop_.<span class="built_in">load</span>() || !<span class="keyword">this</span>-&gt;tasks_.<span class="built_in">empty</span>();</span><br><span class="line">                    &#125; );</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> ( <span class="keyword">this</span>-&gt;tasks_.<span class="built_in">empty</span>() ) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    task = std::<span class="built_in">move</span>( <span class="keyword">this</span>-&gt;tasks_.<span class="built_in">front</span>() );</span><br><span class="line">                    <span class="keyword">this</span>-&gt;tasks_.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="comment">// 拿到一个任务，空闲线程-1</span></span><br><span class="line">                    <span class="keyword">this</span>-&gt;thread_num_--;</span><br><span class="line">                    <span class="built_in">task</span>(); <span class="comment">// <span class="doctag">NOTE:</span> 拿到一个新任务，进行异步调用，执行任务。</span></span><br><span class="line">                    <span class="comment">// 任务执行完之后，空闲线程又回来了，空闲线程+1</span></span><br><span class="line">                    <span class="keyword">this</span>-&gt;thread_num_++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stop_.<span class="built_in">store</span>( <span class="literal">true</span> );</span><br><span class="line">        cv_lock_.<span class="built_in">notify_all</span>();</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span> &amp;td : pool_ ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( td.<span class="built_in">joinable</span>() ) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;join thread &quot;</span> &lt;&lt; td.<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">                td.<span class="built_in">join</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::mutex cv_mt_;</span><br><span class="line">    std::condition_variable cv_lock_;</span><br><span class="line">    std::atomic_bool stop_;</span><br><span class="line">    std::atomic_int thread_num_;</span><br><span class="line">    std::queue&lt;Task&gt; tasks_;</span><br><span class="line">    std::vector&lt;std::thread&gt; pool_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>注意：</p>
<ol>
<li>线程池做的任务是并发的、无序的，无法保证有序性</li>
<li>如果执行的任务是强关联或者互斥性很大，建议使用单线程，线程池的意义不大</li>
</ol>
<p><a class="link"   href="https://github.com/Encounter005/Notes/tree/main/C%2B%2B/src" >源码链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>智能指针</title>
    <url>/2024/07/10/cpp-pointer/</url>
    <content><![CDATA[<h1 id="智能指针概述"><a href="#智能指针概述" class="headerlink" title="智能指针概述"></a>智能指针概述</h1><ol>
<li><p>为什么要有智能指针：直接用<code>new</code>和<code>delete</code>运算符极其容易导致内存泄露，而且非常难以避免，于是人们发明了智能指针这种可以自动回收内存的的工具</p>
</li>
<li><p>智能指针一共就三种：普通的指针可以单独一个指针占用一块内存，也可以多个指针共享一块内存</p>
<ol>
<li>共享型智能指针：<code>shared_ptr</code><blockquote>
<p>同一块堆内存可以被多个<code>shared_ptr</code>共享</p>
</blockquote>
</li>
<li>独享型智能指针：<code>unique_ptr</code><blockquote>
<p>同一块堆内存只能被一个<code>unique_ptr</code>拥有</p>
</blockquote>
</li>
<li>弱引用智能指针：<code>weak_ptr</code><blockquote>
<p>也是一种共享型智能指针，可以视为对共享型智能指针的一种补充</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> *pi = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">  <span class="function"><span class="type">int</span> *<span class="title">pi2</span><span class="params">(pi)</span></span>; <span class="comment">//<span class="doctag">NOTE:</span> pi和pi2共享同一块内存</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li><p>智能指针的注意事项</p>
<p>智能指针和裸指针不要混用</p>
</li>
</ol>
<h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol>
<li><p>我们在动态内存分配时，堆上的内存必须通过栈上的内存来寻址，也就是说栈上的指针(堆上的指针也可以指向堆内存，但终究是要通过栈来寻址)是寻找堆内存的唯一方式</p>
</li>
<li><p>所以我们可以给堆内存添加一个引用计数，有几个指针指向它，它的引用计数就是几。当引用计数为 0 时，操作系统就会释放掉这块内存</p>
</li>
</ol>
<h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><h4 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1. 初始化"></a>1. 初始化</h4><p>使用<code>new</code>运算符初始化</p>
<blockquote>
<p>一般来说不推荐使用<code>new</code>进行初始化，因为 C++标准提供了专门创建<code>shared_ptr</code>的函数<code>make_shared()</code>，该函数是经过优化的，效率更高</p>
</blockquote>
<p>使用<code>make_shared()</code>初始化</p>
<p><code>注意</code> ： 千万不要用裸指针初始化<code>shared_ptr</code>，容易出现内存泄露的问题</p>
<p>使用复制构造函数初始化也行</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">shared1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span> (<span class="number">100</span>))</span></span>;</span><br><span class="line">  std::shared_ptr&lt;<span class="type">int</span>&gt; shared2 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line">  <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">shared3</span><span class="params">(shared2)</span></span>;<span class="comment">// 使用复制构造函数初始化也行</span></span><br><span class="line">  <span class="type">int</span> *pi = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">shared4</span><span class="params">(pi)</span></span>;</span><br><span class="line">  <span class="comment">// delete pi; // <span class="doctag">NOTE:</span> 会造成二次释放(堆内存的重复释放)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h4 id="2-shared-ptr-的引用计数"><a href="#2-shared-ptr-的引用计数" class="headerlink" title="2. shared_ptr 的引用计数"></a>2. shared_ptr 的引用计数</h4><p>智能指针就是通过引用计数来判断释放内存的时机的<br><code>use_count()</code>函数可以得到<code>shared_ptr</code>对象的引用计数</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  std::shared_ptr&lt;<span class="type">int</span>&gt; shared1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line">  std::cout &lt;&lt; shared1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">shared2</span><span class="params">(shared1)</span></span>;</span><br><span class="line">  std::cout &lt;&lt; shared1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  shared2.<span class="built_in">reset</span>(); <span class="comment">// <span class="doctag">NOTE:</span> 释放掉该指针对对象的控制权</span></span><br><span class="line">  std::cout &lt;&lt; shared1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h4 id="3-把-shared-ptr-当成普通指针使用"><a href="#3-把-shared-ptr-当成普通指针使用" class="headerlink" title="3. 把 shared_ptr 当成普通指针使用"></a>3. 把 shared_ptr 当成普通指针使用</h4><p>智能指针可以像普通指针那样使用，<code>shared_ptr</code>早已对各种操作进行了重载，就当它是普通指针就可以了</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  std::shared_ptr&lt;<span class="type">int</span>&gt; shared1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line">  std::cout &lt;&lt; *shared1 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h4 id="4-常用函数"><a href="#4-常用函数" class="headerlink" title="4. 常用函数"></a>4. 常用函数</h4><ol>
<li><code>unique</code>函数<blockquote>
<p>判断该<code>shared_ptr</code>对象是否独占，若独占，返回<code>true</code>，否则返回<code>false</code></p>
</blockquote>
</li>
</ol>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  std::shared_ptr&lt;<span class="type">int</span>&gt; shared1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line">  std::cout &lt;&lt; shared1.<span class="built_in">unique</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">shared2</span><span class="params">(shared1)</span></span>;</span><br><span class="line">  std::cout &lt;&lt; shared1.<span class="built_in">unique</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  shared2.<span class="built_in">reset</span>();</span><br><span class="line">  std::cout &lt;&lt; shared1.<span class="built_in">unique</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li><p><code>reset</code>函数</p>
<ol>
<li>当<code>reset</code>函数有参数时，改变此<code>shared_ptr</code>对象指向的内存</li>
<li>当<code>reset</code>函数无参数时，将此<code>shared_ptr</code>对象置空，也就是将对象内存的指针设置为<code>nullptr</code></li>
</ol>
</li>
</ol>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  std::shared_ptr&lt;<span class="type">int</span>&gt; shared1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line">  std::cout &lt;&lt; shared1.<span class="built_in">unique</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  std::shared_ptr&lt;<span class="type">int</span>&gt; shared2 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">  shared1.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">  shared2 = shared1;</span><br><span class="line">  shared1.<span class="built_in">reset</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li><code>get</code>函数， 强烈不推荐使用</li>
</ol>
<p>如果一定要用，那么一定不能<code>delete</code>返回的指针</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  std::shared_ptr&lt;<span class="type">int</span>&gt; shared1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line">  std::cout &lt;&lt; shared1.<span class="built_in">unique</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> shared1.<span class="built_in">get</span>(); <span class="comment">// <span class="doctag">NOTE:</span> 堆内存重复释放</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<ol start="4">
<li><p><code>swap</code>函数</p>
<blockquote>
<p>交换两个智能指针所指向的内存</p>
</blockquote>
</li>
<li><p><code>std</code>命名空间中全局的<code>swap</code>函数</p>
</li>
<li><p><code>shared_ptr</code>类提供的<code>swap</code>函数</p>
</li>
</ol>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::shared_ptr&lt;<span class="type">int</span>&gt; shared1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line">  std::shared_ptr&lt;<span class="type">int</span>&gt; shared2 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  shared1.<span class="built_in">swap</span>(shared2);</span><br><span class="line">  std::cout &lt;&lt; *shared1 &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; *shared2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  std::<span class="built_in">swap</span>(shared1, shared2);</span><br><span class="line">  std::cout &lt;&lt; *shared1 &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; *shared2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h4 id="5-关于智能指针创建数组的问题"><a href="#5-关于智能指针创建数组的问题" class="headerlink" title="5. 关于智能指针创建数组的问题"></a>5. 关于智能指针创建数组的问题</h4><h4 id="6-用智能指针作为参数传递时直接值传递就行"><a href="#6-用智能指针作为参数传递时直接值传递就行" class="headerlink" title="6. 用智能指针作为参数传递时直接值传递就行"></a>6. 用智能指针作为参数传递时直接值传递就行</h4><p><code>shared_ptr</code>的大小为固定的<code>8</code>或<code>16</code>字节</p>
<blockquote>
<p>也就是两倍指针的大小，32 位系统指针为<code>4</code>个字节，64 位系统指针为<code>8</code>个字节，<code>shared_ptr</code>中就两个指针，所以直接按值传递就行了</p>
</blockquote>
<h4 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h4><p>在现代程序中，当想要共享一块堆内存时，优先使用<code>shared_ptr</code>，可以极大的减少内存泄露的问题</p>
<h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h3><ol>
<li>这个智能指针是在 C++11 的时候引入标准库，它的出现完全是为了弥补<code>shared_ptr</code>的天生缺陷，其实<code>shared_ptr</code>可以说是几乎完美</li>
<li>只是通过引用计数实现的方式也引来了引用成环的问题，这种问题靠他自己是没法解决的，所以在 C++11 的时候将<code>shared_ptr</code>和<code>weak_ptr</code>一起引入了标准库，依次来解决循环引用的问题</li>
</ol>
<h3 id="2-shared-ptr-循环引用的问题"><a href="#2-shared-ptr-循环引用的问题" class="headerlink" title="2. shared_ptr 循环引用的问题"></a>2. shared_ptr 循环引用的问题</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  std::shared_ptr&lt;B&gt; sharedB;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  std::weak_ptr&lt;A&gt; sharedA; <span class="comment">// <span class="doctag">NOTE:</span> 只有把其中一个堆内存用weak_ptr来控制，这两块堆内存才会被释放</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// std::shared_ptr&lt;int&gt; shared1 = std::make_shared&lt;int&gt;(100);</span></span><br><span class="line">  <span class="comment">// std::cout &lt;&lt; shared1.use_count() &lt;&lt; std::endl;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// std::weak_ptr&lt;int&gt; weak1(shared1);</span></span><br><span class="line">  <span class="comment">// std::cout &lt;&lt; shared1.use_count() &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  std::shared_ptr&lt;A&gt; sharedA1 = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">  std::shared_ptr&lt;B&gt; sharedB1 = std::<span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line"></span><br><span class="line">  sharedA1-&gt;sharedB = sharedB1; <span class="comment">// <span class="doctag">NOTE:</span> 两个堆内存，你指我，我指你，双方都在等着对方释放</span></span><br><span class="line">  引用计数都为<span class="number">1</span>，当引用计数为<span class="number">0</span>的时候，堆内存才会被释放，所以这就造成了内存泄露</span><br><span class="line">  sharedB1-&gt;sharedA = sharedA1;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="3-weak-ptr-的作用原理"><a href="#3-weak-ptr-的作用原理" class="headerlink" title="3. weak_ptr 的作用原理"></a>3. weak_ptr 的作用原理</h3><p><code>weak_ptr</code>的作用对象需要绑定到<code>shared_ptr</code>对象上，作用原理是<code>weak_ptr</code>不会改变<code>shared_ptr</code>的引用计数，只要<code>shared_ptr</code>对象的引用计数为 0，就会释放内存，<code>weak_ptr</code>不会影响到释放内存的功能</p>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p><code>weak_ptr</code>是用比较少，就是为了处理<code>shared_ptr</code>循环引用问题设计的</p>
<h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><h3 id="1-介绍-1"><a href="#1-介绍-1" class="headerlink" title="1. 介绍"></a>1. 介绍</h3><p>独占式智能指针，在是用智能指针时，我们一般优先考虑独占式智能指针，因为消耗更小，如果发现内存需要共享，那么再去是用<code>shared_ptr</code></p>
<h3 id="2-unique-ptr-的初始化"><a href="#2-unique-ptr-的初始化" class="headerlink" title="2. unique_ptr 的初始化"></a>2. unique_ptr 的初始化</h3><blockquote>
<p>和 shared_ptr 完全类似</p>
</blockquote>
<ol>
<li>使用<code>new</code>运算符初始化</li>
<li>使用<code>make_unique</code>初始化</li>
</ol>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">unique1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">100</span>))</span></span>;</span><br><span class="line">  std::unique_ptr&lt;<span class="type">int</span>&gt; unique2 = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">1000</span>);</span><br><span class="line">  std::cout &lt;&lt; *unique1 &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; *unique2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="3-unique-ptr-的常用操作"><a href="#3-unique-ptr-的常用操作" class="headerlink" title="3. unique_ptr 的常用操作"></a>3. unique_ptr 的常用操作</h3><ol>
<li><code>unique_ptr</code>禁止复制构造函数，他禁止赋值运算符的重载运算。否则独占毫无意义</li>
<li><code>unique_ptr</code>允许移动构造，移动赋值。移动语义代表之前的对象已经失去了意义，移动操作自然不影响独占的特性</li>
</ol>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  std::unique_ptr&lt;<span class="type">int</span>&gt; unique1 = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line">  std::unique_ptr&lt;<span class="type">int</span>&gt; unique2 = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  unique2 = std::<span class="built_in">move</span>(unique1);</span><br><span class="line">  std::cout &lt;&lt; *unique2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="4">
<li><code>reset()</code>函数<ol>
<li>不带参数的情况下，释放智能指针的对象，并将智能指针置空</li>
<li>带参数的情况下，释放智能指针的对象，并将智能指针指向新的对象</li>
</ol>
</li>
</ol>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  std::unique_ptr&lt;<span class="type">int</span>&gt; unique1 = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line">  std::unique_ptr&lt;<span class="type">int</span>&gt; unique2 = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  unique1.<span class="built_in">reset</span>();</span><br><span class="line">  unique2.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">12</span>));</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; *unique2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="4">
<li>将<code>unique_ptr</code>的对象转化为<code>shared_ptr</code>的对象，当<code>unique_ptr</code>的对象作为一个右值时，就可以将该对象转化为<code>shared_ptr</code>的对象<blockquote>
<p>这个使用的并不多，需要将独占式指针转化为共享式指针常常是因为先前设计失误<br>注意：shared_ptr 对象无法将其转化为 unique_ptr 对象</p>
</blockquote>
</li>
</ol>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myfunc</span><span class="params">(std::unique_ptr&lt;<span class="type">int</span>&gt; unique3)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">shared1</span><span class="params">(std::move(unique3))</span></span>;</span><br><span class="line">&#125; <span class="comment">// NOTES: 一旦将一个对象转化成右值时，必须保证以后不再单独是用这个对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  std::unique_ptr&lt;<span class="type">int</span>&gt; unique1 = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line">  std::unique_ptr&lt;<span class="type">int</span>&gt; unique2 = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="智能指针的适用范围"><a href="#智能指针的适用范围" class="headerlink" title="智能指针的适用范围"></a>智能指针的适用范围</h3><h4 id="1-能使用智能指针就尽量是用智能指针-，-但是有些情况下不能使用智能指针"><a href="#1-能使用智能指针就尽量是用智能指针-，-但是有些情况下不能使用智能指针" class="headerlink" title="1. 能使用智能指针就尽量是用智能指针 ， 但是有些情况下不能使用智能指针"></a>1. 能使用智能指针就尽量是用智能指针 ， 但是有些情况下不能使用智能指针</h4><p>有些函数必须使用 C 语言的指针，这些函数又没有替代，这种情况下，才使用普通的指针，其他情况一律是用智能指针</p>
<p>必须使用 C 语言的指针包括:</p>
<ol>
<li>网络传输函数：比如 windows 下的<code>send</code>,<code>recv</code>函数，智能使用 C 语言的指针，无法替代</li>
<li>C 语言文件操作部分：这方面 C++已经有了替代品，C++的文件部分完全支持智能指针，所以在做大型项目时，推荐使用 C++的文件操作功能</li>
</ol>
<h4 id="2-我们应该是用哪个智能指针呢？"><a href="#2-我们应该是用哪个智能指针呢？" class="headerlink" title="2. 我们应该是用哪个智能指针呢？"></a>2. 我们应该是用哪个智能指针呢？</h4><ol>
<li>优先使用<code>unique_ptr</code>，内存需要共享时使用<code>shared_ptr</code></li>
<li>当使用<code>shared_ptr</code>时，如果出现循环引用的情况下，再去考虑<code>weak_ptr</code></li>
</ol>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>docker常用命令</title>
    <url>/2024/10/04/dockerUsage/</url>
    <content><![CDATA[<p>Docker 是一个开源的容器化平台，允许开发者将应用程序及其依赖项打包到一个轻量级、可移植的容器中。以下是一些常用的 Docker 命令：</p>
<h3 id="1-镜像相关命令"><a href="#1-镜像相关命令" class="headerlink" title="1. 镜像相关命令"></a>1. 镜像相关命令</h3><ul>
<li><p><strong><code>docker pull &lt;image&gt;</code></strong>: 从 Docker Hub 或其他镜像仓库拉取镜像。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull ubuntu</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>docker images</code></strong>: 列出本地所有的镜像。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>docker rmi &lt;image&gt;</code></strong>: 删除指定的镜像。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker rmi ubuntu</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>docker build -t &lt;tag&gt; .</code></strong>: 使用 Dockerfile 构建镜像，并指定标签。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t myapp:1.0 .</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="2-容器相关命令"><a href="#2-容器相关命令" class="headerlink" title="2. 容器相关命令"></a>2. 容器相关命令</h3><ul>
<li><p><strong><code>docker run &lt;image&gt;</code></strong>: 运行一个容器。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it ubuntu</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>docker ps</code></strong>: 列出正在运行的容器。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>docker ps -a</code></strong>: 列出所有容器，包括已停止的。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>docker start &lt;container&gt;</code></strong>: 启动一个已停止的容器。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker start mycontainer</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>docker stop &lt;container&gt;</code></strong>: 停止一个正在运行的容器。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker stop mycontainer</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>docker rm &lt;container&gt;</code></strong>: 删除一个容器。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> mycontainer</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>docker exec -it &lt;container&gt; &lt;command&gt;</code></strong>: 在运行的容器中执行命令。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mycontainer bash</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="3-网络相关命令"><a href="#3-网络相关命令" class="headerlink" title="3. 网络相关命令"></a>3. 网络相关命令</h3><ul>
<li><p><strong><code>docker network ls</code></strong>: 列出所有网络。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker network <span class="built_in">ls</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>docker network create &lt;network&gt;</code></strong>: 创建一个新的网络。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker network create mynetwork</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>docker network connect &lt;network&gt; &lt;container&gt;</code></strong>: 将容器连接到网络。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker network connect mynetwork mycontainer</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="4-卷相关命令"><a href="#4-卷相关命令" class="headerlink" title="4. 卷相关命令"></a>4. 卷相关命令</h3><ul>
<li><p><strong><code>docker volume ls</code></strong>: 列出所有卷。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker volume <span class="built_in">ls</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>docker volume create &lt;volume&gt;</code></strong>: 创建一个新的卷。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker volume create myvolume</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>docker volume rm &lt;volume&gt;</code></strong>: 删除一个卷。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker volume <span class="built_in">rm</span> myvolume</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="5-其他常用命令"><a href="#5-其他常用命令" class="headerlink" title="5. 其他常用命令"></a>5. 其他常用命令</h3><ul>
<li><p><strong><code>docker logs &lt;container&gt;</code></strong>: 查看容器的日志。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker logs mycontainer</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>docker inspect &lt;container&gt;</code></strong>: 查看容器的详细信息。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker inspect mycontainer</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>docker system prune</code></strong>: 清理未使用的数据（包括停止的容器、未使用的网络、未使用的镜像等）。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker system prune</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="6-Docker-Compose-命令"><a href="#6-Docker-Compose-命令" class="headerlink" title="6. Docker Compose 命令"></a>6. Docker Compose 命令</h3><ul>
<li><p><strong><code>docker-compose up</code></strong>: 启动 Docker Compose 定义的服务。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>docker-compose down</code></strong>: 停止并删除 Docker Compose 定义的服务。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose down</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>docker-compose ps</code></strong>: 列出 Docker Compose 定义的服务。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose ps</span><br></pre></td></tr></table></figure></div></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂模式</title>
    <url>/2024/07/13/factory/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在软件开发中，工厂模式是一种设计模式，主要用于创建对象而不暴露具体类的创建细节。这种模式的主要目标是封装创建过程，并将创建逻辑从客户端代码中解耦出来。</p>
<h2 id="定义和意图："><a href="#定义和意图：" class="headerlink" title="定义和意图："></a>定义和意图：</h2><p><strong>工厂模式</strong>的意图在于提供一个创建一系列相关或相互依赖的对象的过程，而无需指定这些对象的具体类。它通过定义一个工厂类来实现这一功能，该工厂类负责根据输入参数决定创建哪个具体类的实例。</p>
<h2 id="常见形式"><a href="#常见形式" class="headerlink" title="常见形式"></a>常见形式</h2><p>工厂模式通常有以下几种常见形式：</p>
<ol>
<li><p><strong>简单工厂（Simple Factory）</strong>：<br>这是最基础的形式，它不依赖于类层次结构，并且通常被用于静态语言中。工厂只创建一个类族中的对象，通过传入参数来决定创建哪个具体类。</p>
</li>
<li><p><strong>抽象工厂（Abstract Factory）</strong>：<br>抽象工厂模式提供了一系列的工厂方法，用于创建一组相关的产品对象。这些产品可以属于不同的家族，但必须遵循共同的接口或抽象定义。其目的是在多个产品的上下文之间进行隔离，使得客户端代码只需要知道如何使用产品而不是如何创建它们。</p>
</li>
<li><p><strong>单例工厂（Singleton Factory）</strong>：<br>在此模式中，工厂类是单例的，确保了在整个应用范围内只有一个实例存在，并且提供一个公共的方法来访问这个实例。这是一种常见的设计模式，用于限制资源访问或配置设置。</p>
</li>
<li><p><strong>构造函数工厂（Constructor Factory）</strong>：<br>这种形式在面向对象语言中较为常见，它通过构造方法创建和初始化对象。构造函数工厂可以接受参数构建具有特定配置的对象，提供了一种动态调整对象属性的机制。</p>
</li>
</ol>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li>在需要根据环境或运行时条件选择具体类时。</li>
<li>当客户端代码不应该依赖于具体的类实现细节，而是应该通过抽象接口进行交互时。</li>
<li>当创建复杂对象需要多个步骤、参数和依赖关系时（例如，配置文件中的信息用于决定对象实例的创建）。</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>假设我们有一个简单工厂模式的例子。假设我们要根据用户输入创建不同类型的形状：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Abstract product</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Shape</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Concrete Product</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;this is a circle&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;this is a square&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Abstract Creator</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShapeFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::shared_ptr&lt;Shape&gt; <span class="title">createShape</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ShapeFactory</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircleFactory</span> : <span class="keyword">public</span> ShapeFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Shape&gt; <span class="title">createShape</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;Circle&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareFactory</span> : <span class="keyword">public</span> ShapeFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::shared_ptr&lt;Shape&gt; <span class="title">createShape</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;Square&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Client</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;CircleFactory&gt; circleFactory = std::<span class="built_in">make_unique</span>&lt;CircleFactory&gt;();</span><br><span class="line">    std::unique_ptr&lt;SquareFactory&gt; squareFactory = std::<span class="built_in">make_unique</span>&lt;SquareFactory&gt;();</span><br><span class="line">    <span class="keyword">auto</span> circle = circleFactory-&gt;<span class="built_in">createShape</span>();</span><br><span class="line">    <span class="keyword">auto</span> square = squareFactory-&gt;<span class="built_in">createShape</span>();</span><br><span class="line">    circle-&gt;<span class="built_in">draw</span>();</span><br><span class="line">    square-&gt;<span class="built_in">draw</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在这个例子中，<code>Shape</code> 和 <code>ShapeFactory</code> 是接口和抽象类的例子。工厂模式通过创建具体实现的实例（即 <code>Circle</code> 或 <code>Square</code>）来满足客户端的不同需求，而不需要在代码中硬编码具体的类名。</p>
<h3 id="具体分析："><a href="#具体分析：" class="headerlink" title="具体分析："></a>具体分析：</h3><ol>
<li><p><strong>接口（Abstract Class）</strong>：</p>
<ul>
<li><code>Shape</code>：这是抽象产品类，定义了一个纯虚函数<code>draw()</code>，用于绘制形状。</li>
<li><code>CircleFactory</code>, <code>SquareFactory</code>：这些是抽象创建者类的实现。它们都实现了从抽象创建者类继承的<code>createShape()</code>接口方法。</li>
</ul>
</li>
<li><p><strong>具体类</strong>：</p>
<ul>
<li><code>Circle</code> 和 <code>Square</code> 是具体产品类。它们各自实现了<code>draw()</code>函数以表示不同形状的绘制方式。</li>
</ul>
</li>
<li><p><strong>工厂模式</strong>：</p>
<ul>
<li>在这个例子中，通过使用抽象创建者（<code>ShapeFactory</code>）和具体创建者（<code>CircleFactory</code>, <code>SquareFactory</code>），我们可以在不直接引用具体产品类的情况下创建产品对象。这种方法使得客户端代码与具体的产品实现解耦。</li>
</ul>
</li>
<li><p><strong>测试函数</strong>：</p>
<ul>
<li><code>test_func()</code> 函数展示了如何通过工厂模式实例化不同的产品。它首先创建了<code>CircleFactory</code>和<code>SquareFactory</code>的实例，然后调用每个工厂的<code>createShape()</code>方法来获取相应的形状对象，并调用它们的<code>draw()</code>方法来验证是否正确创建并绘制出了圆形和正方形。</li>
</ul>
</li>
</ol>
<h2 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h2><ul>
<li>当需要在运行时决定使用哪个具体产品类时。</li>
<li>需要将产品的创建过程与产品的客户端代码分离，以提高代码可维护性和灵活性。</li>
<li>避免类的爆炸问题（即大量的相似类），通过一个工厂类来管理类的选择和实例化。</li>
</ul>
<p>通过这种方式，工厂模式提供了一种灵活的方式来根据特定需求动态地生成不同类型的对象。在实际开发中，这种设计模式常用于UI组件、数据库连接器等场景，以提高代码的可扩展性和维护性。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>工厂模式为创建对象提供了极大的灵活性和封装性，并有助于降低耦合度和提高代码的可维护性。它通过提供一个统一的方式来实例化特定类型的对象或一组相关的对象，使得系统结构更加清晰、更易于调整和扩展。</p>
<h3 id="工厂模式的缺点"><a href="#工厂模式的缺点" class="headerlink" title="工厂模式的缺点"></a>工厂模式的缺点</h3><p>虽然工厂模式在对象创建时提供了便利性和灵活性，但它同样存在一些潜在的局限和问题：</p>
<ol>
<li><p><strong>代码复杂性</strong>：随着功能的增加或需求的变化，工厂类可能会变得非常大且难以维护。每个产品都需要对应的创建方法或工厂实例，这可能导致代码结构混乱，尤其是在有大量相关产品的大型项目中。</p>
</li>
<li><p><strong>单一职责原则违背</strong>：在某些情况下，一个工厂类可能需要处理多个不同类的创建问题，这违反了单一职责原则（SRP）。理想的工厂应该只负责创建特定类型的产品，如果必须同时处理多种类型，则其职责会变得过于广泛。</p>
</li>
<li><p><strong>依赖增加</strong>：使用工厂模式引入了一个新的接口或抽象层，这可能导致代码中对工厂类的依赖增加。在某些情况下，这种依赖可能难以去除，尤其是当工厂类成为多个客户端组件之间的耦合点时。</p>
</li>
<li><p><strong>动态性限制</strong>：虽然工厂模式允许通过传递参数或配置文件来控制创建过程中的决策（如产品实例的选择），但这些设置往往需要在代码中硬编码。如果需要在运行时进行更复杂的自定义逻辑，可能需要更复杂的方法或额外的工厂类，这会增加系统的复杂性。</p>
</li>
<li><p><strong>调用链复杂</strong>：当一个工厂负责多个层次的对象创建时（例如，父工厂创建子工厂），可能会形成复杂的调用链。这种结构可能难以理解、测试和维护，尤其是在对象树非常深的情况下。</p>
</li>
<li><p><strong>资源管理问题</strong>：在处理大量或动态创建的对象时，工厂模式可能导致资源管理问题，如内存泄露或未正确关闭的资源（例如数据库连接）。如果产品实例需要特定生命周期管理，那么必须仔细考虑如何在工厂中实现这一点，以避免这些问题。</p>
</li>
<li><p><strong>非确定性创建过程</strong>：如果产品的创建过程依赖于外部因素（比如用户输入、配置文件、环境变量等），则工厂模式可能难以保证创建过程的确定性和可预测性。这可能会导致在某些情况下（如自动化测试）出现预期之外的结果或错误。</p>
</li>
<li><p><strong>对需求变化的适应性差</strong>：如果产品的需求或类型经常发生变化，那么需要频繁地修改工厂类以支持这些新需求。这可能导致代码库中大量重复的工作和维护负担。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>函数式编程</title>
    <url>/2024/04/08/functional-programming/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>函数式编程是一种编程范式，它将计算视为数学函数的求值，并避免使用程序状态以及易变对象。其核心概念是使用函数来抽象作用在数据上的操作，而这些函数相互之间几乎没有或没有任何副作用。以下是一些函数式编程的关键特点：</p>
<ol>
<li><p><strong>不可变性</strong>：在函数式编程中，状态是不可变的。这意味着一旦创建，数据就不能改变。所有的变化都通过返回新的数据副本来完成，而不是直接修改现有数据。</p>
</li>
<li><p><strong>纯函数</strong>：这些是没有副作用的函数。这意味着给定相同的输入，一个纯函数总是会产生相同的输出，并且在执行过程中不会对系统的其他部分产生影响（例如，不会修改全局变量或状态）。</p>
</li>
<li><p><strong>高阶函数</strong>：函数在函数式编程中可以作为参数传递给其他函数，也可以作为结果返回。这允许创建抽象和组合函数。</p>
</li>
<li><p><strong>函数组合</strong>：这是一种将两个或更多函数结合起来形成一个新函数的技术。组合的结果是一个包装了原来函数行为的新函数。</p>
</li>
<li><p><strong>递归</strong>：由于不使用循环语句，函数式编程通常依赖于递归来执行重复或循环任务。</p>
</li>
<li><p><strong>延迟计算（惰性求值）</strong>：这是一种技术，其中表达式不会立即计算，而是在需要结果之前延迟计算。</p>
</li>
<li><p><strong>模式匹配</strong>：这常用于代数数据类型的解构和分析，允许直接根据数据的结构来处理数据。</p>
</li>
</ol>
<p>在C++中，函数式编程风格可能不像在一些其他语言中那样自然和直观，因为C++本身是一种多范式编程语言，它同时支持面向对象和过程式编程。然而，C++11及其之后的标准引入了一些特性，可以支持更函数式的编程风格。例如，C++提供了标准库中的算法和函数对象，使得函数式编程风格的应用成为可能。</p>
<p>以下是一个使用C++标准库实现<code>map</code>和<code>filter</code>的例子</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; nums = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>};</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; evenNums, doubleNums;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">transform</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), std::<span class="built_in">back_inserter</span>(doubleNums), [](<span class="type">int</span> x){</span><br><span class="line">        <span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">copy_if</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), std::<span class="built_in">back_inserter</span>(evenNums), [](<span class="type">int</span> x){</span><br><span class="line">        <span class="keyword">return</span> x % <span class="number">2</span>;</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"The even numbers are: "</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; x : evenNums) {</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"The double numbers are: "</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; x : doubleNums) {</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>在这个例子中，我们定义了一个数组<code>numbers</code>，使用<code>std::transform</code> 函数遍历它并创建一个新的数组<code>doubledNumbers</code>(其中包含 numbers 的每个元素乘以2的结果）。然后我们使用<code>std::copy_if</code> 函数过滤出偶数并创建了另一个数组 <code>evenNumbers</code>。</p>
<p>C++20标准加入了<code>ranges</code>库，对于支持这个标准的编译器，可以写出更接近函数式编程风格的代码。例如：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ranges&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; nums = { <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> };</span><br><span class="line">    <span class="keyword">auto</span> doubles =</span><br><span class="line">        nums | std::views::<span class="built_in">transform</span>( []( <span class="type">int</span> i ) { <span class="keyword">return</span> i * <span class="number">2</span>; } );</span><br><span class="line">    <span class="keyword">auto</span> evens =</span><br><span class="line">        nums | std::views::<span class="built_in">filter</span>( []( <span class="type">int</span> i ) { <span class="keyword">return</span> i % <span class="number">2</span> == <span class="number">0</span>; } );</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"The even numbers are: "</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> x : evens ) {</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"The double numbers are: "</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> x : doubles ) {</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>接下来演示一下如果通过并行和函数式编程提高运行效率</p>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>快速排序是一种高效的排序算法，它使用分而治之的策略来对一系列元素进行排序。其核心思想是选择一个“基准”（pivot）元素，然后将数组分为两部分，使得左边部分的所有元素都不大于基准元素，而右边部分的所有元素都不小于基准元素，然后对这两部分递归地进行快速排序。<br>以下是一个 C++ 实现的快速排序的示例代码：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//c++ 版本的快速排序算法</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort_recursive</span><span class="params">(T arr[], <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">    T key = arr[start];</span><br><span class="line">    <span class="type">int</span> left = start, right = end;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) {</span><br><span class="line">        <span class="keyword">while</span> (arr[right] &gt;= key &amp;&amp; left &lt; right) right--;</span><br><span class="line">        <span class="keyword">while</span> (arr[left] &lt;= key &amp;&amp; left &lt; right) left++;</span><br><span class="line">        std::<span class="built_in">swap</span>(arr[left], arr[right]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (arr[left] &lt; key) {</span><br><span class="line">        std::<span class="built_in">swap</span>(arr[left], arr[start]);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">quick_sort_recursive</span>(arr, start, left - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quick_sort_recursive</span>(arr, left + <span class="number">1</span>, end);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>{</span><br><span class="line">    <span class="built_in">quick_sort_recursive</span>(arr, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>排序演示</p>
<p>假设一开始序列<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.034ex" height="1.357ex" role="img" focusable="false" viewBox="0 -442 899 599.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mi" transform="translate(605,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container>是：5，3，7，6，4，1，0，2，9，10，8。</p>
<p>此时，ref=5，i=1，j=11，从后往前找，第一个比5小的数是x8=2，因此序列为：2，3，7，6，4，1，0，5，9，10，8。</p>
<p>此时i=1，j=8，从前往后找，第一个比5大的数是x3=7，因此序列为：2，3，5，6，4，1，0，7，9，10，8。</p>
<p>此时，i=3，j=8，从第8位往前找，第一个比5小的数是x7=0，因此：2，3，0，6，4，1，5，7，9，10，8。</p>
<p>此时，i=3，j=7，从第3位往后找，第一个比5大的数是x4=6，因此：2，3，0，5，4，1，6，7，9，10，8。</p>
<p>此时，i=4，j=7，从第7位往前找，第一个比5小的数是x6=1，因此：2，3，0，1，4，5，6，7，9，10，8。</p>
<p>此时，i=4，j=6，从第4位往后找，直到第6位才有比5大的数，这时，i=j=6，ref成为一条分界线，它之前的数都比它小，之后的数都比它大，对于前后两部分数，可以采用同样的方法来排序。</p>
<h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>我们用函数式编程来修改上面的快速排序</p>
<p>改进分为了两种版本，如下：</p>
<h3 id="迭代器版："><a href="#迭代器版：" class="headerlink" title="迭代器版："></a>迭代器版：</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// @brief 快速排序</span></span><br><span class="line"><span class="comment">// @param first 起始迭代器</span></span><br><span class="line"><span class="comment">// @param last 结束迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomAccessIterator&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last)</span> </span>{</span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> 4. 终止条件：</span></span><br><span class="line"><span class="comment">//          当递归到子数组长度为 0 或 1，即 first &gt;= last 时，排序函数返回，因为长度为 0 或 1 的数组自然是有序的，不需要进一步排序。</span></span><br><span class="line">    <span class="keyword">if</span> (first &gt;= last) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> 1. 选择基准元素：</span></span><br><span class="line"><span class="comment">//          函数首先选择一个基准（pivot）。在这个例子中，基准被选择为要排序部分的中间元素。</span></span><br><span class="line">    <span class="keyword">auto</span> pivot = *std::<span class="built_in">next</span>(first, std::<span class="built_in">distance</span>(first, last) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> 2. 划分操作：</span></span><br><span class="line"><span class="comment">//          使用两次 std::partition 函数，第一次将所有小于基准的元素移动到基准的左边，第二次将所有等于基准的元素移动到基准右边的起始位置。</span></span><br><span class="line"><span class="comment">//          这样一来，基准元素的正确位置就被找到了，即所有在基准左边的元素都不大于基准，所有在基准右边的元素都不小于基准。</span></span><br><span class="line">    RandomAccessIterator middle1 = std::<span class="built_in">partition</span>(first, last,</span><br><span class="line">        [pivot](<span class="type">const</span> <span class="keyword">auto</span>&amp; em) { <span class="keyword">return</span> em &lt; pivot; });</span><br><span class="line">    RandomAccessIterator middle2 = std::<span class="built_in">partition</span>(middle1, last,</span><br><span class="line">        [pivot](<span class="type">const</span> <span class="keyword">auto</span>&amp; em) { <span class="keyword">return</span> !(pivot &lt; em); });</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> 3. 递归排序：</span></span><br><span class="line"><span class="comment">//          对基准左边和右边的子数组递归地调用 quick_sort 函数。左子数组包含所有小于基准的元素，右子数组包含所有大于基准的元素。</span></span><br><span class="line">    <span class="built_in">quick_sort</span>(first, middle1);</span><br><span class="line">    <span class="built_in">quick_sort</span>(middle2, last);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>通过这个过程，数组被分为越来越小的部分，并且每个部分通过递归调用都被排序，最终得到整个数组的有序排列。</p>
<h3 id="std-list版"><a href="#std-list版" class="headerlink" title="std::list版:"></a>std::list版:</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@brief 快速排序</span></span><br><span class="line"><span class="comment">//@param input 待排序的list</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">std::list&lt;T&gt; <span class="title">sequential_quick_sort</span><span class="params">( std::list&lt;T&gt; input )</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> ( input.<span class="built_in">empty</span>() ) {</span><br><span class="line">        <span class="keyword">return</span> input;</span><br><span class="line">    }</span><br><span class="line">    std::list&lt;T&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> 1.</span></span><br><span class="line">    <span class="comment">// 将input中的第一个元素放入result中，并且将这第一个元素从input中删除</span></span><br><span class="line">    result.<span class="built_in">splice</span>( result.<span class="built_in">begin</span>(), input, input.<span class="built_in">begin</span>() );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> 2. 去result的第一个元素，将来用这个元素做切割，切割input中的列表</span></span><br><span class="line">    T <span class="type">const</span> &amp;pivot = *result.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> 3.</span></span><br><span class="line">    <span class="comment">// std::partition是一个标准库函数，用于将容器或数组中的元素按照指定的条件进行分区</span></span><br><span class="line">    <span class="comment">// 使得满足条件的元素排在不满足元素之前</span></span><br><span class="line">    <span class="comment">// 所以经过计算divide_point指向的是input中第一个大于等于pivot的元素</span></span><br><span class="line">    <span class="keyword">auto</span> divide_point = std::<span class="built_in">partition</span>(</span><br><span class="line">        input.<span class="built_in">begin</span>(), input.<span class="built_in">end</span>(), [&amp;]( T <span class="type">const</span> &amp;t ) { <span class="keyword">return</span> t &lt; pivot; } );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> 4. 我们将小于pivot的元素放入lower_part中</span></span><br><span class="line">    std::list&lt;T&gt; lower_part;</span><br><span class="line">    lower_part.<span class="built_in">splice</span>( lower_part.<span class="built_in">end</span>(), input, input.<span class="built_in">begin</span>(), divide_point );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> 5. 我们将lower_part传递给sequential_quick_sort返回一个新的有序的从小到大的序列</span></span><br><span class="line">    <span class="comment">// lower_part中都是小于divide_point的值</span></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">new_lower</span><span class="params">( sequential_quick_sort( std::move( lower_part ) ) )</span></span>;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> 6. 我们剩余的input列表传递给sequential_quick_sort递归调用，input中都是大于divide_point的值</span></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">new_higher</span><span class="params">( sequential_quick_sort( std::move( input ) ) )</span></span>;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> 7. 到此时new_hither和new_lower都是从小到大排序好的列表</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> 8. 进行拼接</span></span><br><span class="line">    <span class="comment">//          比divide_point的值小的部分从当前result的起始位置开始插入，大的部分从当前result的终止位置开始插入</span></span><br><span class="line">    result.<span class="built_in">splice</span>( result.<span class="built_in">end</span>(), new_higher );</span><br><span class="line">    result.<span class="built_in">splice</span>( result.<span class="built_in">begin</span>(), new_lower );</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>补充知识:</p>
<blockquote>
<p>关于list.splice()</p>
</blockquote>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">splice()函数是list中的一个剪贴函数，将另外一个list中的元素剪贴到本list中，共有三个重载</span><br><span class="line"></span><br><span class="line">list1为要操作的list</span><br><span class="line">list2为被剪去的list</span><br><span class="line">position为list1中的某个位置的迭代器</span><br><span class="line"></span><br><span class="line">list1调用splice()函数</span><br><span class="line"></span><br><span class="line">1. list1.splice(position , list2)  将list2中的所有元素剪贴到list1中的position位置</span><br><span class="line"></span><br><span class="line">2. list1.splice(position , list2 , iter) 将list2中某个位置的迭代器iter所指向的元素剪贴到list1中的position位置</span><br><span class="line"></span><br><span class="line">3. list1.splice(position , list2 , iter1 , iter2) 将list2中的某个范围迭代器iter1到iter2中的所有元素剪贴到list1中的从position开始的位置</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>调用如下</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_sequential_quick_sort</span><span class="params">()</span> </span>{</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; nums = {<span class="number">6</span> , <span class="number">1</span> , <span class="number">0</span> , <span class="number">7</span> , <span class="number">5</span> , <span class="number">2</span> , <span class="number">9</span> , <span class="number">-1</span>};</span><br><span class="line">    <span class="keyword">auto</span> sort_result = <span class="built_in">sequential_quick_sort</span>(nums);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"The result is: "</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; item : sort_result) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">" "</span> &lt;&lt; item;</span><br><span class="line">    }</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>这个函数是一个使用快速排序对链表进行排序的实现。快速排序是一种常用的排序算法，它的基本思想是选择一个基准元素，然后将数组分为两部分，一部分是小于基准元素的元素，另一部分是大于基准元素的元素。然后对这两部分再分别进行快速排序。这个函数使用了C++模板，可以处理任何数据类型的链表。函数的主要步骤包括：</p>
<ol>
<li><p>将链表的第一个元素作为基准元素，并将其从链表中删除。</p>
</li>
<li><p>使用<code>std::partition</code>函数将链表分为两部分，一部分是小于基准元素的元素，另一部分是大于或等于基准元素的元素。</p>
</li>
<li><p>对这两部分分别进行递归排序。将排序后的两部分和基准元素合并，返回排序后的链表。</p>
</li>
</ol>
<h2 id="并行方式"><a href="#并行方式" class="headerlink" title="并行方式"></a>并行方式</h2><p>我们提供并行方式的函数式编程，可以极大的利用cpu多核的优势，这在并行计算中很常见。</p>
<p>迭代器版本：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomAccessIterator&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sort</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (first &gt;= last) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> pivot = *std::<span class="built_in">next</span>(first, std::<span class="built_in">distance</span>(first, last) / <span class="number">2</span>);</span><br><span class="line">    RandomAccessIterator middle1 = std::<span class="built_in">partition</span>(first, last,</span><br><span class="line">        [pivot](<span class="type">const</span> <span class="keyword">auto</span>&amp; em) { <span class="keyword">return</span> em &lt; pivot; });</span><br><span class="line">    RandomAccessIterator middle2 = std::<span class="built_in">partition</span>(middle1, last,</span><br><span class="line">        [pivot](<span class="type">const</span> <span class="keyword">auto</span>&amp; em) { <span class="keyword">return</span> !(pivot &lt; em); });</span><br><span class="line"></span><br><span class="line">    std::future&lt;<span class="type">void</span>&gt; f1 = std::<span class="built_in">async</span>(std::launch::async, &amp;Sort&lt;RandomAccessIterator&gt;, first, middle1);</span><br><span class="line">    std::future&lt;<span class="type">void</span>&gt; f2 = std::<span class="built_in">async</span>( std::launch::async, &amp;Sort&lt;RandomAccessIterator&gt;, middle2, last );</span><br><span class="line">    f1.<span class="built_in">get</span>();</span><br><span class="line">    f2.<span class="built_in">get</span>();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>std::list版本：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">std::list&lt;T&gt; <span class="title">parrallel_quick_sort</span><span class="params">( std::list&lt;T&gt; input )</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(input.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="keyword">return</span> input;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    std::list&lt;T&gt; result;</span><br><span class="line">    result.<span class="built_in">splice</span>(result.<span class="built_in">begin</span>() , input , input.<span class="built_in">begin</span>());</span><br><span class="line">    T <span class="type">const</span>&amp; pivot = *result.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> divide_point = std::<span class="built_in">partition</span>(input.<span class="built_in">begin</span>() , input.<span class="built_in">end</span>() , [&amp;](T <span class="type">const</span> &amp;t){</span><br><span class="line">        <span class="keyword">return</span> t &lt; pivot;</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    std::list&lt;T&gt; lower_part;</span><br><span class="line">    lower_part.<span class="built_in">splice</span>(lower_part.<span class="built_in">end</span>() , input , input.<span class="built_in">begin</span>() , divide_point);</span><br><span class="line"></span><br><span class="line">    std::future&lt;std::list&lt;T&gt;&gt; <span class="built_in">new_lower</span>(std::<span class="built_in">async</span>(&amp;parrallel_quick_sort&lt;T&gt; , std::<span class="built_in">move</span>(lower_part)));</span><br><span class="line">    <span class="comment">// std::future&lt;std::list&lt;T&gt;&gt; new_higher(std::async(&amp;parrallel_quick_sort&lt;T&gt; , std::move(input)));</span></span><br><span class="line">    <span class="comment">// result.splice(result.end() , new_higher.get());</span></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">new_higher</span><span class="params">(parrallel_quick_sort(std::move(input)))</span></span>;</span><br><span class="line">    result.<span class="built_in">splice</span>(result.<span class="built_in">end</span>() , new_higher);</span><br><span class="line">    result.<span class="built_in">splice</span>(result.<span class="built_in">begin</span>() , new_lower.<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>我们对<code>lower_part</code>的排序调用了<code>std::async</code>并行处理，而<code>higher_part</code>则是串行执行的。这么做提高了计算的并行能力，但有人会问，如果一个数组的大小是1024,那么就是2的10次方，则需要启动10个线程执行，这仅是对一个1024大小的数组排序，如果有多个数组排序，开辟线程会不会很多？其实不用担心这个，因为<code>std::async</code>的实现方式是通过<code>std::launch::deffered</code>或者<code>std::launch::async</code>完成的。编译器会计算当前能否开辟线程，如果能则是使用<code>std::launch::async</code>模式开辟线程，如果不能则采用<code>std::launch::deffered</code>串行执行。当然，也可以通过线程池来实现并行计算</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">std::list&lt;T&gt; <span class="title">thread_pool_quicK_sort</span><span class="params">( std::list&lt;T&gt; input )</span> </span>{</span><br><span class="line">    ThreadPool &amp;ins = ThreadPool::<span class="built_in">getInstance</span>();</span><br><span class="line">    <span class="keyword">if</span> ( input.<span class="built_in">empty</span>() ) {</span><br><span class="line">        <span class="keyword">return</span> input;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    std::list&lt;T&gt; result;</span><br><span class="line">    result.<span class="built_in">splice</span>( result.<span class="built_in">begin</span>(), input, input.<span class="built_in">begin</span>() );</span><br><span class="line">    T <span class="type">const</span> &amp;pivot = *result.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> divide_point = std::<span class="built_in">partition</span>(</span><br><span class="line">        input.<span class="built_in">begin</span>(), input.<span class="built_in">end</span>(), [&amp;]( T <span class="type">const</span> &amp;t ) { <span class="keyword">return</span> t &lt; pivot; } );</span><br><span class="line"></span><br><span class="line">    std::list&lt;T&gt; lower_part;</span><br><span class="line">    lower_part.<span class="built_in">splice</span>( lower_part.<span class="built_in">end</span>(), input, input.<span class="built_in">begin</span>(), divide_point );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> new_lower =</span><br><span class="line">        ins.<span class="built_in">commit</span>( &amp;parrallel_quick_sort&lt;T&gt;, std::<span class="built_in">move</span>( lower_part ) );</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">new_higher</span><span class="params">( parrallel_quick_sort( std::move( input ) ) )</span></span>;</span><br><span class="line">    result.<span class="built_in">splice</span>( result.<span class="built_in">end</span>(), new_higher );</span><br><span class="line">    result.<span class="built_in">splice</span>( result.<span class="built_in">begin</span>(), new_lower.<span class="built_in">get</span>() );</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>并发编程</tag>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>GDB 使用指南-1</title>
    <url>/2024/03/18/gdb-1/</url>
    <content><![CDATA[<p>本文主要描述了GDB的基础命令使用</p>
<h1 id="GDB-介绍"><a href="#GDB-介绍" class="headerlink" title="GDB 介绍"></a>GDB 介绍</h1><p>GDB，全称GNU调试器（GNU Debugger），是一个强大的Unix系统下的源代码级调试工具。它可以帮助程序员查看程序在执行过程中的内部状态，从而更好地理解程序的运行机制。GDB主要用于调试C和C++语言编写的程序。它的存在，使得我们能够更深入地了解程序的运行过程，找出并修复程序中的错误。</p>
<h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><h2 id="启动GDB"><a href="#启动GDB" class="headerlink" title="启动GDB"></a>启动GDB</h2><p>假如我们有一个编译好的C++程序，名字是<code>a.out</code>，（记得编译的时候要带<code>-g</code>表示有调试信息），接下来我们需要启动GDB</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb a.out</span><br></pre></td></tr></table></figure></div>

<h2 id="查看源码"><a href="#查看源码" class="headerlink" title="查看源码"></a>查看源码</h2><p>在GDB中，我们可以通过<code>list</code>来查看源码信息</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) list</span><br></pre></td></tr></table></figure></div>

<p><a href="https://img.tg/image/Ogk3e6"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://ooo.0x0.ooo/2024/03/18/Ogk3e6.png"
                      alt="Ogk3e6.png"
                ></a></p>
<h2 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h2><p>断点是调试的核心，允许在程序特定的位置暂停执行，可以通过<code>break</code>来设置断点，通常只需要<code>b + 文件名: + 行号</code>即可</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) b main.cpp:5</span><br></pre></td></tr></table></figure></div>

<p><a href="https://img.tg/image/OgkXsD"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://ooo.0x0.ooo/2024/03/18/OgkXsD.png"
                      alt="OgkXsD.png"
                ></a></p>
<h2 id="查看断点"><a href="#查看断点" class="headerlink" title="查看断点"></a>查看断点</h2><p>在设置了多个断点之后，我们可能需要查看所有的断点信息，来确保没有遗漏或者打错位置的断点，可以使用<code>info breakpoints</code>来查看所有的断点</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) info breakpoints</span><br></pre></td></tr></table></figure></div>

<p><a href="https://img.tg/image/OgkIoF"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://ooo.0x0.ooo/2024/03/18/OgkIoF.png"
                      alt="OgkIoF.png"
                ></a></p>
<h2 id="运行代码"><a href="#运行代码" class="headerlink" title="运行代码"></a>运行代码</h2><p>接下来可以开始执行程序了，使用<code>run</code>来让程序跑起来</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) run</span><br></pre></td></tr></table></figure></div>

<p><a href="https://img.tg/image/OgkCGP"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://ooo.0x0.ooo/2024/03/18/OgkCGP.png"
                      alt="OgkCGP.png"
                ></a></p>
<p>当程序遇到断点时，它会暂停，等待我们的进一步指令。</p>
<h2 id="显示变量值"><a href="#显示变量值" class="headerlink" title="显示变量值"></a>显示变量值</h2><p>在调试过程中，如果需要查看变量，使用<code>print + variable_name</code></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) print b</span><br></pre></td></tr></table></figure></div>

<h2 id="观察变量"><a href="#观察变量" class="headerlink" title="观察变量"></a>观察变量</h2><p>在某些情况下，我们可能想要知道一个变量何时被修改。GDB提供了<code>watch</code>命令，允许我们观察变量的变化。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) watch variable_name</span><br></pre></td></tr></table></figure></div>

<p>每当variable_name的值发生变化时，程序会暂停执行。<br><a href="https://img.tg/image/OgxOhl"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://ooo.0x0.ooo/2024/03/18/OgxOhl.png"
                      alt="OgxOhl.png"
                ></a></p>
<h2 id="单步运行"><a href="#单步运行" class="headerlink" title="单步运行"></a>单步运行</h2><p>如果需要一行一行执行代码，可以使用<code>step</code>，一般用<code>s</code>即可</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) s</span><br></pre></td></tr></table></figure></div>

<p><a href="https://img.tg/image/Ogkw3b"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://ooo.0x0.ooo/2024/03/18/Ogkw3b.png"
                      alt="Ogkw3b.png"
                ></a></p>
<h2 id="继续执行"><a href="#继续执行" class="headerlink" title="继续执行"></a>继续执行</h2><p>如果设置了断点停止了程序，这时想让程序直接执行到下一个断点时，使用<code>continue</code></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) continue</span><br></pre></td></tr></table></figure></div>

<p><a href="https://img.tg/image/Ogk8yI"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://ooo.0x0.ooo/2024/03/18/Ogk8yI.png"
                      alt="Ogk8yI.png"
                ></a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>GDB 使用指南-2</title>
    <url>/2024/03/18/gdb-2/</url>
    <content><![CDATA[<p>本文主要描述了GDB中断点调试和数据命令的使用方法</p>
<h1 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h1><h2 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h2><p>要设置断点时，使用<code>break</code>或<code>b</code>来设置断点</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">b main.cpp:5</span><br></pre></td></tr></table></figure></div>

<h2 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h2><p>有时，我们只想在满足特定条件时暂停程序</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">b main.cpp:5 if i == 5</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/65f84de09f345e8d03ec1444.png"
                     
                ></p>
<h2 id="查看断点"><a href="#查看断点" class="headerlink" title="查看断点"></a>查看断点</h2><p>如果需要查看所有断点所在的位置信息，使用<code>info breakpoints</code></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">info breakpoints</span><br></pre></td></tr></table></figure></div>

<h2 id="清除断点"><a href="#清除断点" class="headerlink" title="清除断点"></a>清除断点</h2><p>有些断点我们不再需要，可以直接清除</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 清理第5行的断点</span><br><span class="line">clear main.cpp:5</span><br></pre></td></tr></table></figure></div>

<h2 id="观察点"><a href="#观察点" class="headerlink" title="观察点"></a>观察点</h2><p>观察点允许我们监视变量的值，并在其值发生变化时暂停程序。这对于跟踪变量的变化非常有用</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">watch variable_name</span><br></pre></td></tr></table></figure></div>

<h2 id="捕捉点"><a href="#捕捉点" class="headerlink" title="捕捉点"></a>捕捉点</h2><p>捕捉点是一种特殊类型的断点，它允许我们在发生特定事件，如抛出异常时暂停程序。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 设置捕捉点</span><br><span class="line">catch throw</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/65f84de19f345e8d03ec15c8.png"
                     
                ></p>
<p>这将设置一个捕捉点，当程序抛出异常时，它将暂停。</p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="显示表达式值"><a href="#显示表达式值" class="headerlink" title="显示表达式值"></a>显示表达式值</h2><p>在GDB中，可以通过<code>print</code>来评估表达式并显示其值</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">print variable_name</span><br></pre></td></tr></table></figure></div>

<h2 id="查看数据类型"><a href="#查看数据类型" class="headerlink" title="查看数据类型"></a>查看数据类型</h2><p>当我们需要查看一个变量的类型，（例如类型推断的变量），需要使用<code>whatis</code>命令</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">whatis variable_name</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/65f84de19f345e8d03ec1c4e.png"
                     
                ></p>
<h2 id="打印变量值"><a href="#打印变量值" class="headerlink" title="打印变量值"></a>打印变量值</h2><p><code>display</code>命令可以自动显示表达式的值，每次程序停止时都会显示</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">display x</span><br></pre></td></tr></table></figure></div>

<p>每次程序停止时，都会显示变量x的值</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/65f84de19f345e8d03ec185b.png"
                     
                ></p>
<h2 id="修改变量值"><a href="#修改变量值" class="headerlink" title="修改变量值"></a>修改变量值</h2><p>在某些情况下，需要在调试过程中修改变量值。假设要将变量x的值设置为5，使用<code>set</code>命令</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">set variable x = 5</span><br></pre></td></tr></table></figure></div>

<p>这将立即更改变量x的值，而不需要重新编译或重新启动程序。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/65f84de19f345e8d03ec1ad6.png"
                     
                ></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>GDB使用指南-3</title>
    <url>/2024/03/20/gdb-3/</url>
    <content><![CDATA[<h1 id="调试运行环境"><a href="#调试运行环境" class="headerlink" title="调试运行环境"></a>调试运行环境</h1><h2 id="设置运行参数"><a href="#设置运行参数" class="headerlink" title="设置运行参数"></a>设置运行参数</h2><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The arguments&#x27; count is: &quot;</span> &lt;&lt; argc &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; argv[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在GDB中，可以通过<code>set args</code>命令来设置运行参数</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) set args 参数1 参数2...</span><br></pre></td></tr></table></figure></div>

<h2 id="改变工作目录"><a href="#改变工作目录" class="headerlink" title="改变工作目录"></a>改变工作目录</h2><p>有时候我们需要在GDB跳转到别的文件目录中</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) cd /path/to/directory</span><br></pre></td></tr></table></figure></div>

<h2 id="设置输入输出"><a href="#设置输入输出" class="headerlink" title="设置输入输出"></a>设置输入输出</h2><p>假设我们有一个<code>input.txt</code>和一个<code>output.txt</code>作为程序的输入和输出文件，我们想让gdb在启动程序的时候进行重定向</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) run &lt; input.txt &gt; output.txt</span><br></pre></td></tr></table></figure></div>

<p>如果想保存整个程序的日志文件，我们需要<code>set logging</code>命令</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) set logging file 文件名</span><br><span class="line">(gdb) set logging on</span><br></pre></td></tr></table></figure></div>

<h2 id="线程调试"><a href="#线程调试" class="headerlink" title="线程调试"></a>线程调试</h2><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">( []() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::cout &lt;&lt; <span class="string">&quot;this is thread 1&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::this_thread::sleep_for(</span></span></span><br><span class="line"><span class="params"><span class="function">            std::chrono::duration( std::chrono::seconds( <span class="number">10</span> ) ) );</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125; )</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">( []() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::cout &lt;&lt; <span class="string">&quot;this is thread 2&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::this_thread::sleep_for(</span></span></span><br><span class="line"><span class="params"><span class="function">            std::chrono::duration( std::chrono::seconds( <span class="number">10</span> ) ) );</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125; )</span></span>;</span><br><span class="line">    t1.<span class="built_in">detach</span>(), t2.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在线程调试中，如果要查看线程信息可以使用<code>info thread</code></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) info thread</span><br></pre></td></tr></table></figure></div>

<p>如果需要切换到特定的线程里面</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) thread 线程号</span><br></pre></td></tr></table></figure></div>

<p>其他关于线程的命令</p>
<ul>
<li><p><code>break location thread thread-id</code>: 在指定线程上设置断点，仅当该特定线程执行时，它才会停止。</p>
</li>
<li><p><code>set scheduler-locking</code>: 控制在调试过程中其他线程的行为。可以设置以下模式：</p>
<p>off：不锁定，所有线程都可以运行。<br>on：锁定，只有当前线程可以运行。<br>step：只有一个线程在单步执行时才锁定其他线程。</p>
</li>
<li><p><code>thread apply all command</code>: 对所有线程执行指定的命令。</p>
</li>
<li><p><code>set follow-fork-mode</code>: 设置GDB在fork系统调用时如何跟踪进程。可以设置为 parent 或 child，分别表示跟踪父进程或子进程。</p>
</li>
<li><p><code>set detach-on-fork</code>: 控制GDB在fork后是否保持调试父进程和子进程。</p>
</li>
<li><p><code>catch thread</code>: 在任何线程创建或退出时设置断点。</p>
</li>
<li><p><code>thread select</code>: 切换到已经停止的线程（例如，通过断点或者异常）。</p>
</li>
</ul>
<h2 id="检查堆栈"><a href="#检查堆栈" class="headerlink" title="检查堆栈"></a>检查堆栈</h2><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">test</span>(i - <span class="number">1</span>);</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>在调试过程中，堆栈是经常需要查看的</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) info stack</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/65fae7ba9f345e8d03ce1ec5.png"
                      alt="stack"
                ></p>
<h1 id="跳转命令"><a href="#跳转命令" class="headerlink" title="跳转命令"></a>跳转命令</h1><p>在GDB中，我们可以使用jump命令（或简写为j）来实现跳转执行。例如，如果我们想从当前位置直接跳到第10行执行，可以使用以下命令：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">j 10</span><br></pre></td></tr></table></figure></div>

<p>这样程序就会直接跳转到第10行开始执行，跳过中间所有的代码</p>
<h2 id="跳转的限制"><a href="#跳转的限制" class="headerlink" title="跳转的限制"></a>跳转的限制</h2><p>虽然跳转命令很强大，但它也有一些限制。例如，我们不能跳到一个没有被加载的函数或模块中，也不能跳到一个已经执行完毕的函数或模块中。<br>此外，频繁地使用跳转命令可能会导致程序状态的不一致，因此在使用时需要格外小心。</p>
<h2 id="跳转应用的场景"><a href="#跳转应用的场景" class="headerlink" title="跳转应用的场景"></a>跳转应用的场景</h2><ol>
<li><strong>绕过错误或崩溃</strong>：如果你在调试过程中遇到了一个会导致程序崩溃的代码块，并且希望跳过这部分代码继续调试程序的其他部分，可以使用jump命令。</li>
<li><strong>重复执行代码</strong>：你可能想反复执行某段代码以观察问题，jump能够让你回到这段代码的起点。</li>
<li><strong>测试代码路径</strong>：在多个分支或执行路径的代码中，你可能想强制执行某个特定的路径，即使它实际上在当前的程序状态下不会被执行。</li>
<li><strong>跳过执行时间很长的函数</strong>：在调试时，你可能不想等待一个耗时的函数完成。你可以跳过这个函数的调用，直接跳到其后的代码执行。</li>
</ol>
<h1 id="信号命令"><a href="#信号命令" class="headerlink" title="信号命令"></a>信号命令</h1><p>信号是一种通知机制，用于告知进程某些事件已经发生。经常被用于处理异常情况（例如程序错误、外部中断等），在GDB中我们可以通过信号命令来处理、模拟这些信号</p>
<h2 id="生成和处理信号"><a href="#生成和处理信号" class="headerlink" title="生成和处理信号"></a>生成和处理信号</h2><p>在GDB中，我们可以使用signal命令来发送信号到正在调试的程序。例如，要发送一个SIGINT信号，我们可以使用以下命令：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) signal SIGINT</span><br></pre></td></tr></table></figure></div>

<p>这是模拟用户按下<code>Ctrl+C</code>的情况</p>
<h2 id="查看和设置信号"><a href="#查看和设置信号" class="headerlink" title="查看和设置信号"></a>查看和设置信号</h2><p>要查看当前程序如何处理各种信号，可以使用<code>info signals</code></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) info signals</span><br></pre></td></tr></table></figure></div>

<p>这将显示所有信号及其当前的处理方式。</p>
<p>如果我们想改变某个信号的处理方式，可以使用<code>handle</code>命令。例如，要让程序在接收到SIGINT信号时停止并打印消息，我们可以使用：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) handle SIGINT stop print</span><br></pre></td></tr></table></figure></div>

<p>这样，每当程序接收到<code>SIGINT</code>信号时，它都会停止执行并在GDB中打印消息</p>
<h1 id="运行SHELL命令"><a href="#运行SHELL命令" class="headerlink" title="运行SHELL命令"></a>运行SHELL命令</h1><p>要想运行shell命令，我们只需要在命令前加上shell关键字即可</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) shell ...</span><br></pre></td></tr></table></figure></div>

<h1 id="调试core文件"><a href="#调试core文件" class="headerlink" title="调试core文件"></a>调试core文件</h1><p>在软件开发过程中，程序可能会出现崩溃。为了更好地理解和解决这些崩溃，我们经常需要调试程序的core文件。core文件是程序崩溃时生成的，它包含了程序崩溃时的内存快照，帮助我们定位问题。</p>
<h2 id="生成core文件"><a href="#生成core文件" class="headerlink" title="生成core文件"></a>生成core文件</h2><p>先放一份源文件，方便调试</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">    std::<span class="built_in">iota</span>(a , a + <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; a[<span class="number">100001</span>] &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>当程序崩溃时，系统通常会生成一个core文件，要确保core文件被生成，需要设置<code>ulimit</code></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ulimit -c unlimited</span><br></pre></td></tr></table></figure></div>

<h2 id="使用GDB查看core文件"><a href="#使用GDB查看core文件" class="headerlink" title="使用GDB查看core文件"></a>使用GDB查看core文件</h2><p>要使用GDB查看core文件，我们需要两个文件：崩溃的程序的可执行文件和core文件。使用以下命令启动GDB：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb &lt;executable-file&gt; &lt;core-file&gt;</span><br></pre></td></tr></table></figure></div>

<p>这里可以使用coredumpctl来调用gdb</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 启动最新的core文件</span><br><span class="line">coredumpctl debug</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/65faf78d9f345e8d0337efe7.png"
                      alt="core"
                ></p>
<h2 id="实时观察进程Crash信息"><a href="#实时观察进程Crash信息" class="headerlink" title="实时观察进程Crash信息"></a>实时观察进程Crash信息</h2><p>有时，我们可能希望实时观察进程的崩溃信息，而不是等待程序崩溃后再查看core文件。为此，我们可以使用strace工具跟踪系统调用和信号。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">strace -o output.txt &lt;executable-file&gt;</span><br></pre></td></tr></table></figure></div>

<p>这将在output.txt文件中记录所有的系统调用和信号，帮助我们实时观察进程的行为。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>java语法</title>
    <url>/2024/03/16/java-grammar/</url>
    <content><![CDATA[<h1 id="the-grammar-of-java"><a href="#the-grammar-of-java" class="headerlink" title="the grammar of java"></a>the grammar of java</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>byte:</p>
<ul>
<li>数据类型是8位</li>
</ul>
<p>short:</p>
<ul>
<li>数据类型是16位</li>
</ul>
<p>int:</p>
<ul>
<li>数据类型是32位</li>
</ul>
<p>long:</p>
<ul>
<li>数据类型是64位</li>
</ul>
<p>float:</p>
<ul>
<li>单精度浮点数</li>
</ul>
<p>double:</p>
<ul>
<li>双精度浮点数</li>
</ul>
<p>boolean:</p>
<ul>
<li>存储bool量</li>
</ul>
<p>char:</p>
<ul>
<li>存储任何字符</li>
</ul>
<h2 id="number-math类"><a href="#number-math类" class="headerlink" title="number &amp; math类"></a>number &amp; math类</h2><h3 id="number子类"><a href="#number子类" class="headerlink" title="number子类"></a>number子类</h3><blockquote>
<p>java为每一个数据类型都封装了对应的包装类</p>
</blockquote>
<table>
<thead>
<tr>
<th>包装类</th>
<th>基本数据类型</th>
</tr>
</thead>
<tbody><tr>
<td>booleans</td>
<td>boolean</td>
</tr>
<tr>
<td>byte</td>
<td>byte</td>
</tr>
<tr>
<td>short</td>
<td>short</td>
</tr>
<tr>
<td>integer</td>
<td>int</td>
</tr>
<tr>
<td>long</td>
<td>long</td>
</tr>
<tr>
<td>character</td>
<td>char</td>
</tr>
<tr>
<td>float</td>
<td>float</td>
</tr>
<tr>
<td>double</td>
<td>double</td>
</tr>
</tbody></table>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span> &#123;</span><br><span class="line">        <span class="type">integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        system.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>一些基本方法</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>xxxvalue()</td>
<td>将number对象转换为xxx数据类型并返回</td>
</tr>
<tr>
<td>compareto()</td>
<td>将number对象与参数比较</td>
</tr>
<tr>
<td>equals()</td>
<td>判断number对象是否与参数相等</td>
</tr>
<tr>
<td>valueof()</td>
<td>返回一个number对象指定的内置数据类型</td>
</tr>
<tr>
<td>tostring()</td>
<td>以字符串形式返回值</td>
</tr>
<tr>
<td>paraseint()</td>
<td>将字符串解析为int类型</td>
</tr>
</tbody></table>
<p>用法</p>
<p>paraseint()</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span> &#123;</span><br><span class="line">        <span class="type">string</span> <span class="variable">re</span> <span class="operator">=</span> <span class="string">&quot;10.0&quot;</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="type">double</span>.parsedouble(re);</span><br><span class="line">        system.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="math类"><a href="#math类" class="headerlink" title="math类"></a>math类</h3><blockquote>
<p>math类包含了基本的数学运算<br>math类的方法都被定义为<code>static</code>形式，可以在主函数直接调用</p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span> &#123;</span><br><span class="line">        system.out.println(<span class="string">&quot;the sin value of 90 degree is: &quot;</span> + math.sin(math.pi / <span class="number">2.0</span>));</span><br><span class="line">        system.out.println(<span class="string">&quot;the cos value of 0 degree is: &quot;</span> + math.cos(<span class="number">0</span>));</span><br><span class="line">        system.out.println(<span class="string">&quot;the tan value of 60 degree is: &quot;</span> + math.tan(math.pi / <span class="number">3.0</span>));</span><br><span class="line">        system.out.println(<span class="string">&quot;the degree of pi / 2 is: &quot;</span> + math.todegrees(math.pi / <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>基本方法</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>abs()</td>
<td>返回参数的绝对值</td>
</tr>
<tr>
<td>ceil()</td>
<td>返回向上取整的给定参数的整数</td>
</tr>
<tr>
<td>floor()</td>
<td>返回向下取整的给定参数的整数</td>
</tr>
<tr>
<td>rint()</td>
<td>返回与参数最接近的整数，返回类型为double</td>
</tr>
<tr>
<td>round()</td>
<td>表示四舍五入 math.floor(x + 0.5)</td>
</tr>
<tr>
<td>min()</td>
<td>返回两个参数中的最小值</td>
</tr>
<tr>
<td>max()</td>
<td>返回两个参数中的最大值</td>
</tr>
<tr>
<td>pow()</td>
<td>返回第一个参数的第二个参数的次方</td>
</tr>
<tr>
<td>sqrt()</td>
<td>返回参数的算术平方根</td>
</tr>
<tr>
<td>random()</td>
<td>返回一个随机数</td>
</tr>
</tbody></table>
<h2 id="character类"><a href="#character类" class="headerlink" title="character类"></a>character类</h2><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//note: 定义一个字符串数组</span></span><br><span class="line">        <span class="type">char</span>[] test = &#123;<span class="string">&#x27;h&#x27;</span> , <span class="string">&#x27;e&#x27;</span> , <span class="string">&#x27;l&#x27;</span> , <span class="string">&#x27;l&#x27;</span> , <span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch : test) &#123;</span><br><span class="line">            system.out.print(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        system.out.println();</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="string">&#x27;h&#x27;</span>;</span><br><span class="line">        system.out.println(ch);</span><br><span class="line">        <span class="comment">//note: character字符串数组</span></span><br><span class="line">        character[] test_2 = &#123;<span class="string">&#x27;h&#x27;</span> , <span class="string">&#x27;e&#x27;</span> , <span class="string">&#x27;l&#x27;</span> , <span class="string">&#x27;l&#x27;</span> , <span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line">        system.out.println(test_2[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>基本方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>isletter()</td>
<td>是否是一个字母</td>
</tr>
<tr>
<td>isdigit()</td>
<td>是否是一个数字字符</td>
</tr>
<tr>
<td>iswhitespace()</td>
<td>是否是一个空白字符</td>
</tr>
<tr>
<td>isuppercase()</td>
<td>是否是大写字母</td>
</tr>
<tr>
<td>islowercase()</td>
<td>是否是小写字母</td>
</tr>
<tr>
<td>tostring()</td>
<td>返回字符的字符串形式，字符串的长度为1</td>
</tr>
</tbody></table>
<h2 id="string类"><a href="#string类" class="headerlink" title="string类"></a>string类</h2><blockquote>
<p>java提供了string类来创建和操作字符串</p>
</blockquote>
<p>字符串创建</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//note: 创建字符串</span></span><br><span class="line"><span class="type">string</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="string">&quot;noob&quot;</span>;</span><br><span class="line"><span class="type">string</span> <span class="variable">tmp2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">string</span>(<span class="string">&quot;awdawd&quot;</span>);</span><br><span class="line">system.out.println(tmp);</span><br><span class="line">system.out.println(tmp2);</span><br><span class="line"><span class="comment">//note: 用字符串数组创建字符串</span></span><br><span class="line"><span class="type">char</span>[] hello = &#123;<span class="string">&#x27;h&#x27;</span> , <span class="string">&#x27;e&#x27;</span> , <span class="string">&#x27;l&#x27;</span> , <span class="string">&#x27;l&#x27;</span> , <span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line"><span class="type">string</span> <span class="variable">tmp3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">string</span>(hello);</span><br><span class="line">system.out.println(tmp3);</span><br><span class="line"><span class="type">string</span> <span class="variable">tmp4</span> <span class="operator">=</span> tmp2; <span class="comment">// note: 这种创建方式是引用</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>求字符串长度</p>
<blockquote>
<p>length()</p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//note: 求字符串长度</span></span><br><span class="line"><span class="type">string</span> <span class="variable">world</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">system.out.println(world.length());</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>连接字符串</p>
<blockquote>
<p>concat(string) 返回一个连接好字符串</p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//note: 连接字符串</span></span><br><span class="line"><span class="type">string</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello, &quot;</span> , s2 = <span class="string">&quot;world!&quot;</span>;</span><br><span class="line"><span class="type">string</span> <span class="variable">s3</span> <span class="operator">=</span> s1.concat(s2);</span><br><span class="line">system.out.println(s3);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>创建格式化字符串</p>
<p>string类使用静态方法format()返回一个string对象而不是printstream对象<br>string类的静态方法format()能用来创建可复用的格式化字符串</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//note: 创建格式化字符串</span></span><br><span class="line">string fs;</span><br><span class="line">fs = string.format(<span class="string">&quot;float is: &quot;</span> + <span class="string">&quot;%f , int is: &quot;</span> + <span class="string">&quot;%d , string is: &quot;</span> + <span class="string">&quot;%s&quot;</span> , <span class="number">10.1</span> , <span class="number">12</span> , s3);</span><br><span class="line">system.out.println(fs);</span><br></pre></td></tr></table></figure></div>

<p>基本方法</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>char charat(int index)</td>
<td>返回指定索引处的char值</td>
</tr>
<tr>
<td>int compareto(string anotherstring)</td>
<td>按字典序比较两个字符串</td>
</tr>
<tr>
<td>int comparetoignorecase(string str)</td>
<td>按字典序比较两个字符串(忽略大小写)</td>
</tr>
<tr>
<td>boolean contentequals(stringbuffer sb)</td>
<td>当且仅当字符串与指定的stringbuffer有相同顺序的字符时候返回真。</td>
</tr>
<tr>
<td>int indexof(string str)</td>
<td>返回指定子字符串在此字符串中第一次出现处的索引。</td>
</tr>
<tr>
<td>int indexof(string str , int from index)</td>
<td>返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。</td>
</tr>
<tr>
<td>int lastindexof(int ch)</td>
<td>返回指定字符在此字符串中最后一次出现处的索引。</td>
</tr>
<tr>
<td>int lastindexof(int ch, int fromindex)</td>
<td>返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索。</td>
</tr>
<tr>
<td>int lastindexof(string str)</td>
<td>返回指定子字符串在此字符串中最右边出现处的索引。</td>
</tr>
<tr>
<td>int lastindexof(string str, int fromindex)</td>
<td>返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。</td>
</tr>
<tr>
<td>string touppercase()</td>
<td>使用默认语言环境的规则将此 string 中的所有字符都转换为大写。</td>
</tr>
<tr>
<td>string tolowercase()</td>
<td>使用默认语言环境的规则将此 string 中的所有字符都转换为小写。</td>
</tr>
<tr>
<td>char[] tochararray()</td>
<td>将此字符串转换为一个新的字符数组。</td>
</tr>
<tr>
<td>string substring(int beginindex, int endindex)</td>
<td>返回一个新字符串，它是此字符串的一个子字符串。</td>
</tr>
<tr>
<td>string substring(int beginindex)</td>
<td>返回一个新的字符串，它是此字符串的一个子字符串。</td>
</tr>
</tbody></table>
<h2 id="stringbuffer-string-builder类"><a href="#stringbuffer-string-builder类" class="headerlink" title="stringbuffer &amp; string builder类"></a>stringbuffer &amp; string builder类</h2><blockquote>
<p>在使用 stringbuffer 类时，每次都会对 stringbuffer 对象本身进行操作，而不是生成新的对象，所以如果需要对字符串进行修改推荐使用 stringbuffer。<br>在不要求线程安全的情况下，使用string builder类，string builder会比stringbuffer快。</p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// note: 先创建一个大小为10的空字符串</span></span><br><span class="line"><span class="type">stringbuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">stringbuilder</span>(<span class="number">10</span>);</span><br><span class="line">system.out.println(sb);</span><br><span class="line"><span class="comment">// note: 从尾部填充字符串</span></span><br><span class="line">sb.append(<span class="string">&quot;runoob..&quot;</span>);</span><br><span class="line">system.out.println(sb);</span><br><span class="line">sb.append(<span class="string">&quot;!&quot;</span>);</span><br><span class="line">system.out.println(sb);</span><br><span class="line"><span class="comment">// note: 从指定索引处开始填充字符串，不足部分会扩容</span></span><br><span class="line">sb.insert(<span class="number">8</span> , <span class="string">&quot;java&quot;</span>);</span><br><span class="line">system.out.println(sb);</span><br><span class="line"><span class="comment">// note: 删除指定区间的字符串</span></span><br><span class="line">sb.delete(<span class="number">5</span> , <span class="number">8</span>);</span><br><span class="line">system.out.println(sb);</span><br></pre></td></tr></table></figure></div>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   note: 创建数组</span></span><br><span class="line"><span class="comment">*   datatype[] array</span></span><br><span class="line"><span class="comment">*   datatype[] array = new datatype[size]</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">integer[] arr = &#123;<span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span> , <span class="number">4</span> , <span class="number">5</span>&#125;;</span><br><span class="line">integer[] arr2 = <span class="keyword">new</span> <span class="title class_">integer</span>[<span class="number">100</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="遍历数组及访问数组"><a href="#遍历数组及访问数组" class="headerlink" title="遍历数组及访问数组"></a>遍历数组及访问数组</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// note: 遍历数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    system.out.println(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// note: 范围遍历 for_each</span></span><br><span class="line"><span class="keyword">for</span>(integer value : arr) &#123;</span><br><span class="line">    system.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="数组作为函数参数"><a href="#数组作为函数参数" class="headerlink" title="数组作为函数参数"></a>数组作为函数参数</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printarray</span><span class="params">(integer[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(integer value : arr) &#123;</span><br><span class="line">        system.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">printarray(<span class="keyword">new</span> <span class="title class_">integer</span>[]&#123;<span class="number">10</span> , <span class="number">20</span> , <span class="number">30</span> , <span class="number">40</span>&#125;);</span><br></pre></td></tr></table></figure></div>

<h3 id="数组作为返回值"><a href="#数组作为返回值" class="headerlink" title="数组作为返回值"></a>数组作为返回值</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> integer[] reverse(integer[] arr) &#123;</span><br><span class="line">    integer[] res = <span class="keyword">new</span> <span class="title class_">integer</span>[arr.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = arr.length - <span class="number">1</span>; i &lt; arr.length; i++ , j--) &#123;</span><br><span class="line">        res[i] = arr[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">printarray(reverse(arr));</span><br></pre></td></tr></table></figure></div>

<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  note: type[][] typename = new type[length][length]</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line">string[][] arr = <span class="keyword">new</span> <span class="title class_">string</span>[<span class="number">20</span>][<span class="number">30</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="arrays类"><a href="#arrays类" class="headerlink" title="arrays类"></a>arrays类</h3><blockquote>
<p>包含了排序、查找、打印等内容</p>
</blockquote>
<p>要先<code>import java.util.arrays</code></p>
<ol>
<li>打印数组</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> [] a = &#123;<span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>&#125;;</span><br><span class="line">system.out.println(a);</span><br><span class="line">system.out.println(arrays.tostring(a)); <span class="comment">// 打印数组元素的值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>升序排序</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> [] b = &#123;<span class="number">2</span> , <span class="number">56</span>  ,<span class="number">12893</span> ,<span class="number">12</span> , <span class="number">23</span> ,<span class="number">3</span>  , <span class="number">5</span> , <span class="number">67123</span>&#125;;</span><br><span class="line">system.out.println(arrays.tostring(b)); <span class="comment">// 打印数组元素的值</span></span><br><span class="line">arrays.sort(b);</span><br><span class="line">system.out.println(arrays.tostring(b)); <span class="comment">// 打印数组元素的值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li>数组元素是引用类型的排序</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">man</span> <span class="keyword">implements</span> <span class="title class_">comparable</span>&#123;</span><br><span class="line">    <span class="type">int</span> age , id;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">man</span><span class="params">(<span class="type">int</span> age , string name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(); <span class="comment">// 父类型特征，先初始化父类型特征，再初始化子类</span></span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareto</span><span class="params">(object o)</span> &#123;</span><br><span class="line">        <span class="type">man</span> <span class="variable">man</span> <span class="operator">=</span> (man) o;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.age &lt; man.age) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.age &gt; man.age) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span> &#123;</span><br><span class="line">        man[] msmans = &#123;<span class="keyword">new</span> <span class="title class_">man</span>(<span class="number">3</span>, <span class="string">&quot;a&quot;</span>), <span class="keyword">new</span> <span class="title class_">man</span>(<span class="number">60</span>, <span class="string">&quot;b&quot;</span>),<span class="keyword">new</span> <span class="title class_">man</span>(<span class="number">2</span>, <span class="string">&quot;c&quot;</span>)&#125;;</span><br><span class="line">        arrays.sort(msmans);</span><br><span class="line">        system.out.println(arrays.tostring(msmans));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">integer[] arr = &#123;<span class="number">10</span> , <span class="number">20</span> , <span class="number">30</span> , <span class="number">40</span> , <span class="number">50</span> , <span class="number">60</span> , <span class="number">70</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> arrays.binarysearch(arr , <span class="number">30</span>);</span><br><span class="line">system.out.println(x);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<ol start="5">
<li>填充数组</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">323</span>,<span class="number">23</span>,<span class="number">543</span>,<span class="number">12</span>,<span class="number">59</span>&#125;;</span><br><span class="line">system.out.println(arrays.tostring(a));</span><br><span class="line">arrays.fill(a , <span class="number">10</span>);</span><br><span class="line">system.out.println(arrays.tostring(a));</span><br></pre></td></tr></table></figure></div>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ol>
<li>定义</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型 参数名)&#123;</span><br><span class="line">    ...</span><br><span class="line">    方法体</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>可变参数</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">double</span>... args)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(args.length == <span class="number">0</span>) &#123;</span><br><span class="line">        system.out.println(<span class="string">&quot;no argument passed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">double</span> val : args) &#123;</span><br><span class="line">        system.out.print(val + <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    system.out.println();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span> &#123;</span><br><span class="line">    print(<span class="number">10.1</span> , <span class="number">2.1</span> , <span class="number">3.2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li>finalize()方法 (弃用)</li>
</ol>
<blockquote>
<p>这种方法在对象被垃圾收集器析构前调用，用来清除回收对象</p>
</blockquote>
<p>在finalize()方法里，必须指定在对象销毁时候要执行的操作<br>一般格式是</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// note: terminate your code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>实例</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">cake</span> <span class="keyword">extends</span> <span class="title class_">object</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">cake</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        system.out.println(<span class="string">&quot;cake object &quot;</span> + id + <span class="string">&quot;is created&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> java.lang.throwable &#123;</span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        system.out.println(<span class="string">&quot;cake object &quot;</span> + id + <span class="string">&quot;is disposed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span> &#123;</span><br><span class="line">    <span class="type">cake</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">cake</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="type">cake</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">cake</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="type">cake</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">cake</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    c2 = c3 = <span class="literal">null</span>;</span><br><span class="line">    system.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="stream-file-io"><a href="#stream-file-io" class="headerlink" title="stream, file, io"></a>stream, file, io</h2><p><code>java.io</code>包含了所有操作输入、输出需要的类</p>
<p>使用这些类之前要先<code>import java.io.*</code></p>
<h3 id="读取控制台输入"><a href="#读取控制台输入" class="headerlink" title="读取控制台输入"></a>读取控制台输入</h3><p>java的控制台输入由<code>system.in</code>完成。<br>为了获得一个绑定到控制台的字符串，你可以把<code>system.in</code>包装在一个<code>buffererreader</code>对象中来创建一个字符串流。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">bufferedreader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">bufferedreader</span>(<span class="keyword">new</span> <span class="title class_">inputstreamreader</span>(system.in));</span><br></pre></td></tr></table></figure></div>

<p>创建完<code>bufferedreader</code>对象之后，可以使用其中的<code>read()</code>方法来获取控制台的一个字符，或者使用<code>readline()</code>方法来获取一个字符串</p>
<h3 id="从控制台读取多字符输入"><a href="#从控制台读取多字符输入" class="headerlink" title="从控制台读取多字符输入"></a>从控制台读取多字符输入</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span> <span class="keyword">throws</span> ioexception &#123;</span><br><span class="line">    <span class="type">bufferedreader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">bufferedreader</span>(<span class="keyword">new</span> <span class="title class_">inputstreamreader</span>(system.in));</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    system.out.println(<span class="string">&quot;input something, press &#x27;q&#x27; to quit&quot;</span>);</span><br><span class="line">    <span class="comment">// read</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        c = (<span class="type">char</span>) br.read();</span><br><span class="line">        system.out.println(c);</span><br><span class="line">    &#125; <span class="keyword">while</span>(c != <span class="string">&#x27;q&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="从控制台读取字符串"><a href="#从控制台读取字符串" class="headerlink" title="从控制台读取字符串"></a>从控制台读取字符串</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span> <span class="keyword">throws</span> ioexception &#123;</span><br><span class="line">    <span class="type">bufferedreader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">bufferedreader</span>(<span class="keyword">new</span> <span class="title class_">inputstreamreader</span>(system.in));</span><br><span class="line">    string read;</span><br><span class="line">    system.out.println(<span class="string">&quot;enter lines of text&quot;</span>);</span><br><span class="line">    system.out.println(<span class="string">&quot;enter \&quot;end\&quot; to quit&quot;</span>);</span><br><span class="line">    <span class="comment">// read</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">       read = br.readline();</span><br><span class="line">       system.out.println(read);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!read.equals(<span class="string">&quot;end&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image_post/iostream.png"
                      alt="io_stream"
                ></p>
<h4 id="fileinputstream"><a href="#fileinputstream" class="headerlink" title="fileinputstream"></a>fileinputstream</h4><p>该流用于从文件读取数据，它的对象可以用关键字 new 来创建。</p>
<p>创建方法:</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">inputstream</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">fileinputstream</span>(<span class="string">&quot;c:/java/hello&quot;</span>);</span><br><span class="line"><span class="type">file</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">file</span>(<span class="string">&quot;c:/java/hello&quot;</span>);</span><br><span class="line"><span class="type">inputstream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">fileinputstream</span>(f);</span><br></pre></td></tr></table></figure></div>

<p>基本方法</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>public void close() throws ioexception</td>
<td>关闭文件输入流并释放与此流相关的的所有系统资源。抛出ioexception异常</td>
</tr>
<tr>
<td>public int read(int r) throws ioexception</td>
<td>从inputstream对象读取指定字节的数据。返回下一字节的数据，如果已经到结尾则返回-1</td>
</tr>
<tr>
<td>public int read(byte[] r) throws ioexception</td>
<td>从输入流读取r.length长度的字节。返回读取的字节数，如果是文件结尾则返回-1</td>
</tr>
<tr>
<td>public int available() throws ioexception</td>
<td>返回下一次对此输入流调用的方法可以不接受阻塞地从此输入流读取的字节数。</td>
</tr>
</tbody></table>
<h4 id="fileoutputstream"><a href="#fileoutputstream" class="headerlink" title="fileoutputstream"></a>fileoutputstream</h4><p>该类用来创建一个文件并向文件中写数据。<br>如果该文件不存在，则会自动创建。</p>
<p>创建方法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">outputstream</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">fileoutputstream</span>(<span class="string">&quot;c:/java/hello&quot;</span>)</span><br><span class="line"><span class="type">file</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">file</span>(<span class="string">&quot;c:/java/hello&quot;</span>);</span><br><span class="line"><span class="type">outputstream</span> <span class="variable">fout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">fileoutputstream</span>(f);</span><br></pre></td></tr></table></figure></div>

<p>基本方法</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>public void close() throws ioexception</td>
<td>关闭此文件的输出流并释放有关的所有系统资源。抛出ioexception异常</td>
</tr>
<tr>
<td>public void write(int w) throws ioexception</td>
<td>把指定的字节写入到流中</td>
</tr>
<tr>
<td>public void write(byte[] w) throws ioexception</td>
<td>把指定的数组w.length长度的字节写到outputstream中</td>
</tr>
</tbody></table>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="type">byte</span> bwrite[] = &#123;<span class="number">11</span> , <span class="number">23</span> , <span class="number">3</span> , <span class="number">40</span> , <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="type">outputstream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">fileoutputstream</span>(<span class="string">&quot;output.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">byte</span> value : bwrite) &#123;</span><br><span class="line">            os.write(value);</span><br><span class="line">        &#125;</span><br><span class="line">        os.close();</span><br><span class="line"></span><br><span class="line">        <span class="type">inputstream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">fileinputstream</span>(<span class="string">&quot;input.txt&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> is.available();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            system.out.print((<span class="type">char</span>) is.read() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        is.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(ioexception e) &#123;</span><br><span class="line">        system.out.println(<span class="string">&quot;exception&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="scanner类"><a href="#scanner类" class="headerlink" title="scanner类"></a>scanner类</h4><p>可以通过scanner类来获取用户输入</p>
<p>创建方法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.scanner;</span><br><span class="line"><span class="type">scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">scanner</span>(system.in);</span><br></pre></td></tr></table></figure></div>

<p>在读取字符串的时候，通常需要使用<code>hasnext()</code>与<code>hasnextline</code>判断是否还有输入的数据</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span> &#123;</span><br><span class="line">    <span class="type">scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">scanner</span>(system.in);</span><br><span class="line">    <span class="comment">// read</span></span><br><span class="line">    system.out.println(<span class="string">&quot;input something&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (sc.hasnext()) &#123;</span><br><span class="line">        <span class="type">string</span> <span class="variable">str1</span> <span class="operator">=</span> sc.next();</span><br><span class="line">        system.out.println(str1);</span><br><span class="line">    &#125;</span><br><span class="line">    sc.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span> &#123;</span><br><span class="line">    <span class="type">scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">scanner</span>(system.in);</span><br><span class="line">    <span class="comment">// read</span></span><br><span class="line">    system.out.println(<span class="string">&quot;input something&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (sc.hasnextline()) &#123;</span><br><span class="line">        <span class="type">string</span> <span class="variable">str1</span> <span class="operator">=</span> sc.nextline();</span><br><span class="line">        system.out.println(str1);</span><br><span class="line">    &#125;</span><br><span class="line">    sc.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="next与nextline的区别"><a href="#next与nextline的区别" class="headerlink" title="next与nextline的区别"></a>next与nextline的区别</h5><p>next():</p>
<ol>
<li>一定要读取到有效字符后才可以结束输入</li>
<li>对输入有效字符之前遇到的空白，next()方法会自动将其去掉</li>
<li>只有输入有效字符之后才将其后面输入的空白作为分隔符或者结束符</li>
<li>next()不能的得到带有空格的字符串</li>
</ol>
<p>nextline():</p>
<ol>
<li>以<code>enter</code>为结束符，也就是说，nextline()方法返回的是输入回撤之前的所有字符</li>
<li>可以获得空白</li>
</ol>
<p>如果要输入int或float类型的数据，在scanner类中也有支持，但是在输入之前最好先使用hasnextxxx()方法进行验证，再使用nextxxx()来读取</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span> &#123;</span><br><span class="line">    <span class="type">scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">scanner</span>(system.in);</span><br><span class="line">    <span class="comment">// read</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">0.0f</span>;</span><br><span class="line">    system.out.println(<span class="string">&quot;input integer&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(sc.hasnextint()) &#123;</span><br><span class="line">        i = sc.nextint();</span><br><span class="line">    &#125;</span><br><span class="line">    system.out.println(<span class="string">&quot;the integer is: &quot;</span> + i);</span><br><span class="line"></span><br><span class="line">    system.out.println(<span class="string">&quot;input float&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(sc.hasnextfloat()) &#123;</span><br><span class="line">        f = sc.nextfloat();</span><br><span class="line">    &#125;</span><br><span class="line">    system.out.println(<span class="string">&quot;the float is: &quot;</span> + f);</span><br><span class="line">    sc.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>例如计算输入的数的总和和平均值</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span> &#123;</span><br><span class="line">    system.out.println(<span class="string">&quot;input some value&quot;</span>);</span><br><span class="line">    <span class="type">scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">scanner</span>(system.in);</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(sc.hasnextdouble()) &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">m</span> <span class="operator">=</span> sc.nextdouble();</span><br><span class="line">        sum += m;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// note: 如果需要退出循环，只需要输入一个非数字字符即可</span></span><br><span class="line"></span><br><span class="line">    system.out.println(<span class="string">&quot;the sum is: &quot;</span> + sum);</span><br><span class="line">    system.out.println(<span class="string">&quot;the avg is: &quot;</span> + sum / cnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>有三种异常类型：</p>
<ul>
<li>检查型异常: 最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。</li>
<li>运行时异常：运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。</li>
<li>错误： 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。</li>
</ul>
<h3 id="exception类的层次"><a href="#exception类的层次" class="headerlink" title="exception类的层次"></a>exception类的层次</h3><p>所有的异常类是从<code>java.lang.exception</code>类继承的子类</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image_post/exception-hierarchy.png"
                      alt="exception_hierarchy"
                ></p>
<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// your code</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(exceptionname e) &#123;</span><br><span class="line">    <span class="comment">// catch 块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>实例：<br>检测数组索引是否合法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span> &#123;</span><br><span class="line">   <span class="keyword">try</span>&#123;</span><br><span class="line">       <span class="type">int</span> a[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">       <span class="type">scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">scanner</span>(system.in);</span><br><span class="line">       system.out.println(<span class="string">&quot;please input a index&quot;</span>);</span><br><span class="line">       <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span>(sc.hasnextint()) &#123;</span><br><span class="line">           index = sc.nextint();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// note: 如果索引不合法，数组就会抛出arrayindexoutofboundsexception异常</span></span><br><span class="line">       system.out.println(<span class="string">&quot;access element successfully: &quot;</span> + a[index]);</span><br><span class="line">   &#125;  <span class="keyword">catch</span>(arrayindexoutofboundsexception e) &#123;</span><br><span class="line">       system.out.println(<span class="string">&quot;exception thrown: &quot;</span> + e);</span><br><span class="line">   &#125;</span><br><span class="line">   system.out.println(<span class="string">&quot;out of the block&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="多重捕获块"><a href="#多重捕获块" class="headerlink" title="多重捕获块"></a>多重捕获块</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span>(exceptiontype e1) &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span>(exceptionname e2) &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span>(exceptiontype e3) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    file = <span class="keyword">new</span> <span class="title class_">fileinputstream</span>(filename);</span><br><span class="line">    x = (<span class="type">byte</span>) file.read();</span><br><span class="line">&#125; <span class="keyword">catch</span>(filenotfoundexception f) &#123; <span class="comment">// not valid!</span></span><br><span class="line">    f.printstacktrace();</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span>(ioexception i) &#123;</span><br><span class="line">    i.printstacktrace();</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>上述代码中，抛出的异常会去匹配对应的异常类型的catch块</p>
<h4 id="throw-throws-关键字"><a href="#throw-throws-关键字" class="headerlink" title="throw &#x2F; throws 关键字"></a>throw &#x2F; throws 关键字</h4><p><code>throw</code>关键字用于在代码中抛出异常，<code>throws</code>关键字用于在方法声明中指定可能会抛出的异常类型</p>
<h5 id="throw-关键字"><a href="#throw-关键字" class="headerlink" title="throw 关键字"></a>throw 关键字</h5><p>通常情况下，当代码执行到某个条件下无法继续正常执行时，可以使用<code>throw</code>关键字抛出异常，已告知调用者当前代码的执行状态</p>
<p>例如下面的代码，用来判断参数是否小于0,如果是，则抛出一个illegalargumentexception异常</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">illegalargumentexception</span>(<span class="string">&quot;number must be greater than 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="throws-关键字"><a href="#throws-关键字" class="headerlink" title="throws 关键字"></a>throws 关键字</h5><p><code>throws</code>关键字用于在方法声明中指定该方法可能抛出异常。当方法内部抛出指定类型的异常时，该异常会被传递给调用该方法的代码，并在该代码中处理异常</p>
<p>例如下面的代码，当readfile方法内部发生异常时，会将该异常传递给调用该方法的代码。在调用该方法的代码中，必须捕获或声明处理ioexception</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readfile</span><span class="params">(string filepath)</span> <span class="keyword">throws</span> ioexception &#123;</span><br><span class="line">    <span class="type">bufferedreader</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">bufferedreader</span>(<span class="keyword">new</span> <span class="title class_">filereader</span>(filepath));</span><br><span class="line">    <span class="type">string</span> <span class="variable">line</span> <span class="operator">=</span> bf.readline();</span><br><span class="line">    <span class="keyword">while</span>(line != <span class="literal">null</span>) &#123;</span><br><span class="line">        system.out.println(line);</span><br><span class="line">        line = bf.readline();</span><br><span class="line">    &#125;</span><br><span class="line">    bf.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>一个方法可以声明抛出多个异常，多个异常之间用逗号隔开</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(<span class="type">double</span> amount)</span> <span class="keyword">throws</span> remoteexception, insufficientresourcesexception &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h4 id="finally-关键字"><a href="#finally-关键字" class="headerlink" title="finally 关键字"></a>finally 关键字</h4><p><code>finally</code> 关键字用来创建在 <code>try</code> 代码块后面执行的代码块。</p>
<p>无论是否发生异常，<code>finally</code> 代码块中的代码总会被执行。</p>
<p>在 <code>finally</code> 代码块中，可以运行清理类型等收尾善后性质的语句。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span>(exceptiontype e) &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>实例：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        system.out.println(<span class="string">&quot;access element three: &quot;</span> + a[<span class="number">3</span>]);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (arrayindexoutofboundsexception e) &#123;</span><br><span class="line">        system.out.println(<span class="string">&quot;exception thrown: &quot;</span> + e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        a[<span class="number">0</span>] = <span class="number">6</span>;</span><br><span class="line">        system.out.println(<span class="string">&quot;first element value: &quot;</span> + a[<span class="number">0</span>]);</span><br><span class="line">        system.out.println(<span class="string">&quot;the finally statement is excuted&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>注意：</p>
<ul>
<li>catch块不能独立于try块</li>
<li>try块后面不能没有catch块也没finally块</li>
<li>try, catch, finally块之间不能添加任何代码</li>
</ul>
<h4 id="try-with-source"><a href="#try-with-source" class="headerlink" title="try-with-source"></a>try-with-source</h4><p>我们可以使用<code>try-with-source</code>语法糖来打开资源，并且可以在语句执行完毕后确保每个资源都被自动关闭</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span> <span class="keyword">throws</span> ioexception &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">scanner</span>(system.in))&#123;</span><br><span class="line">        <span class="type">printwriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">printwriter</span>(<span class="keyword">new</span> <span class="title class_">file</span>(<span class="string">&quot;testwrite.txt&quot;</span>));</span><br><span class="line">        <span class="keyword">while</span>(sc.hasnext()) &#123;</span><br><span class="line">            writer.print(sc.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>多个资源回收时，<code>try-with-source</code>语句以相反的顺序关闭这些资源</p>
<h3 id="声明自定义异常"><a href="#声明自定义异常" class="headerlink" title="声明自定义异常"></a>声明自定义异常</h3><p>在java编写自定义异常时，要记住以下几点：</p>
<ul>
<li>所有异常都必须是<code>throwable</code>的子类</li>
<li>如果希望写一个检查性异常类，则需要继承<code>exception</code>类。</li>
<li>如果希望写一个运行时异常类，那么则需要继承<code>runtimeexception</code>类</li>
</ul>
<p>创建方式:</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">myexception</span> <span class="keyword">extends</span> <span class="title class_">exception</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>例如我们要做一个检查银行账户类，用户在取款时，有可能余额小于取款额，这时我们就可以设计一个资金不足异常类，用于在这种情况下抛出异常</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">insufficientfundsexception</span> <span class="keyword">extends</span> <span class="title class_">exception</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> amount;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">insufficientfundsexception</span><span class="params">(<span class="type">double</span> amount)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.amount = amount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getamount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>然后再设计一个检查账户类</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">checkingaccount</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// balance是余额，number是卡号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> balance;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">checkingaccount</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.number = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存钱</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deposit</span><span class="params">(<span class="type">double</span> amount)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取款</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(<span class="type">double</span> amount)</span> <span class="keyword">throws</span> insufficientfundsexception &#123;</span><br><span class="line">        <span class="keyword">if</span>(balance &gt;= amount) &#123;</span><br><span class="line">            balance -= amount;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">double</span> <span class="variable">needs</span> <span class="operator">=</span> amount - balance;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">insufficientfundsexception</span>(needs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回余额</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getbalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回卡号</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getnumber</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>测试如下：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span> &#123;</span><br><span class="line">    <span class="type">checkingaccount</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">checkingaccount</span>(<span class="number">123</span>);</span><br><span class="line">    system.out.println(<span class="string">&quot;deposit 5000.0...&quot;</span>);</span><br><span class="line">    c.deposit(<span class="number">5000.0</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        system.out.println(<span class="string">&quot;\nwithdrawing $1000...&quot;</span>);</span><br><span class="line">        c.withdraw(<span class="number">100</span>);</span><br><span class="line">        system.out.println(<span class="string">&quot;\nwithdrawing $6000...&quot;</span>);</span><br><span class="line">        c.withdraw(<span class="number">6000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(insufficientfundsexception e) &#123;</span><br><span class="line">        system.out.println(<span class="string">&quot;sorry, but you are shot $&quot;</span> + e.getamount());</span><br><span class="line">        e.printstacktrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>结果如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">insufficientfundsexception</span><br><span class="line">	at checkingaccount.withdraw(main.java:40)</span><br><span class="line">	at main.main(main.java:63)</span><br><span class="line">deposit 5000.0...</span><br><span class="line"></span><br><span class="line">withdrawing $1000...</span><br><span class="line"></span><br><span class="line">withdrawing $6000...</span><br><span class="line">sorry, but you are shot $1100.0</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>子类拥有父类非<code>private</code>属性、方法</li>
<li>子类拥有自己的属性和方法，即子类可以对父类进行扩展</li>
<li>子类可以用自己的方式实现父类的方法</li>
<li>java的继承是单继承，但是可以多重继承，无法多继承</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image_post/inherit.png"
                      alt="inherit"
                ></p>
<p>继承格式:</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">class 父类 &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class 子类 extends 父类 &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="继承关键字"><a href="#继承关键字" class="headerlink" title="继承关键字"></a>继承关键字</h3><p>继承可以使用<code>extends</code>和<code>implements</code>关键字，而且所有的类都是继承于<code>java.lang.object</code>，当一个类没有继承的两个关键字，则默认继承<code>object</code>祖先类</p>
<p><strong>extends, super, this</strong>关键字</p>
<ul>
<li>extends只能继承一个类</li>
<li>super用来实现对父类成员的访问，用来引用当前的父类对象</li>
<li>this，指向自己的引用</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> string name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">animal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&quot;none&quot;</span>;</span><br><span class="line">        <span class="built_in">this</span>.id = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">animal</span><span class="params">(string name , <span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        system.out.println(<span class="string">&quot;eating&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        system.out.println(<span class="string">&quot;sleeping&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">introduction</span><span class="params">()</span> &#123;</span><br><span class="line">        system.out.println(<span class="string">&quot;my name is: &quot;</span> + name + <span class="string">&quot; and my id is: &quot;</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        system.out.println(<span class="string">&quot;this is animal&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">penguin</span> <span class="keyword">extends</span> <span class="title class_">animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">penguin</span><span class="params">(string name , <span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name , id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mouse</span> <span class="keyword">extends</span> <span class="title class_">animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">mouse</span><span class="params">(string name , <span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name , id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dog</span> <span class="keyword">extends</span> <span class="title class_">animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        system.out.println(<span class="string">&quot;this is dog&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span> &#123;</span><br><span class="line">        <span class="type">mouse</span> <span class="variable">mou</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">mouse</span>(<span class="string">&quot;mou&quot;</span> , <span class="number">1</span>);</span><br><span class="line">        <span class="type">penguin</span> <span class="variable">pen</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">penguin</span>(<span class="string">&quot;pen&quot;</span> , <span class="number">1</span>);</span><br><span class="line">        pen.eat();</span><br><span class="line">        mou.introduction();</span><br><span class="line">        <span class="type">dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">dog</span>();</span><br><span class="line">        dog.test();</span><br><span class="line">        dog.test2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>implements</strong>关键字</p>
<blockquote>
<p>可以是java变相具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口</p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">a</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">b</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">c</span> <span class="keyword">implements</span> <span class="title class_">a</span> , b &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><strong>final</strong>关键字</p>
<ul>
<li>使用<code>final</code>关键字声明类，就是把类定义为最终类，不能被继承，或者用于修饰方法，该方法不能被子类重写</li>
</ul>
<p>格式：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 声明类</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">a</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明方法</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">public</span>, <span class="keyword">private</span>, <span class="keyword">default</span>, <span class="keyword">protected</span>) <span class="keyword">final</span> <span class="keyword">return</span> type <span class="title function_">functionname</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>如果父类的构造器带有参数，则必须在子类的构造器中显式地通过<code>super</code>关键字调用父类的构造器并配以适当的参数列表，如果父类没有则不需要，系统会自动调用父类的无参构造器</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">superclass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">superclass</span><span class="params">()</span> &#123;</span><br><span class="line">       system.out.println(<span class="string">&quot;call superclass()&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">superclass</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.n = n;</span><br><span class="line">       system.out.println(<span class="string">&quot;call superclass(int n)&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">subclass</span> <span class="keyword">extends</span> <span class="title class_">superclass</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">subclass</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">       <span class="built_in">super</span>(n);</span><br><span class="line">       system.out.println(<span class="string">&quot;subclass(n)&quot;</span>);</span><br><span class="line">       <span class="built_in">this</span>.n = n;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">subclass</span><span class="params">()</span> &#123;</span><br><span class="line">        system.out.println(<span class="string">&quot;subclass&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span> &#123;</span><br><span class="line">        system.out.println(<span class="string">&quot;------subclass 类继承------&quot;</span>);</span><br><span class="line">        <span class="type">subclass</span> <span class="variable">sc1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">subclass</span>();</span><br><span class="line">        <span class="type">subclass</span> <span class="variable">sc2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">subclass</span>(<span class="number">100</span>);</span><br><span class="line">        system.out.println(<span class="string">&quot;------subclass2 类继承------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="override-overload"><a href="#override-overload" class="headerlink" title="override &amp; overload"></a>override &amp; overload</h2><h3 id="重写-override"><a href="#重写-override" class="headerlink" title="重写(override)"></a>重写(override)</h3><p>重写是子类对父类的允许访问的方法的实现过程重写，返回值和形参都不改变。<br>重写方法不能抛出新的检查异常或者比被重写的方法声明更加广泛的异常。例如：父类的一个方法声明了一个检查异常ioexception，但是在重写这个方法的时候不能抛出exception异常，因为exception是ioexception的父类，抛出ioexception或者ioexception的子类异常</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span> &#123;</span><br><span class="line">        system.out.println(<span class="string">&quot;moving....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dog</span> <span class="keyword">extends</span> <span class="title class_">animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span> &#123;</span><br><span class="line">        system.out.println(<span class="string">&quot;the dog is moving...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span> &#123;</span><br><span class="line">        <span class="type">animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">animal</span>();</span><br><span class="line">        <span class="type">animal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">dog</span>();</span><br><span class="line">        a.move();</span><br><span class="line">        b.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>在上面的代码中，dog类继承自animal类并重写了move方法，尽管b是属于animal类型，但它运行的是dog类的move方法。注意，如果dog类存在animal类中没有的方法，并且在调用了这个方法，编译不会通过。</p>
<p>方法的重写原则</p>
<ul>
<li>参数列表和被重写的方法的参数列表必须完全相同</li>
<li>返回类型与被重写的方法的返回类型可以不相同，但是必须是父类返回值的派生类</li>
<li>访问权限不能比父类被重写的方法的访问权限更低。</li>
<li>父类的成员方法只能被它的子类重写</li>
<li>声明为 static 的方法不能被重写，但是能够被再次声明。</li>
<li>声明为 final 的方法不能被重写。</li>
<li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。</li>
<li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。</li>
<li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</li>
<li>构造方法不能被重写。</li>
</ul>
<p><strong>super</strong>关键字</p>
<p>当需要在子类中调用父类的被重写方法时，要使用 super 关键字。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span> &#123;</span><br><span class="line">        system.out.println(<span class="string">&quot;moving....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dog</span> <span class="keyword">extends</span> <span class="title class_">animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.move();</span><br><span class="line">        system.out.println(<span class="string">&quot;the dog is moving...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span> &#123;</span><br><span class="line">        <span class="type">animal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">dog</span>();</span><br><span class="line">        b.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="重载-overload"><a href="#重载-overload" class="headerlink" title="重载(overload)"></a>重载(overload)</h3><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口（英文：interface），在java编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。</p>
<h3 id="接口与类的区别"><a href="#接口与类的区别" class="headerlink" title="接口与类的区别:"></a>接口与类的区别:</h3><ul>
<li>接口不能用于实例化对象</li>
<li>接口没有构造方法</li>
<li>接口中所有的方法都必须是抽象方法</li>
<li>接口不能包含成员变量，除了<code>static</code>，<code>final</code>变量</li>
<li>接口不是被类继承了，而是要被类实现</li>
<li>接口支持多继承</li>
</ul>
<h3 id="接口特性"><a href="#接口特性" class="headerlink" title="接口特性"></a>接口特性</h3><ul>
<li>接口是隐式抽象的，当声明一个接口时，不必使用<code>abstract</code>关键字</li>
<li>接口中的每一个方法也是隐式抽象的，所有字段是隐式的<code>public static final</code>，因此没必要在接口内部指定访问说明符</li>
</ul>
<h3 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h3><p>和抽象类一样，无法创建接口的对象。可以使用<code>implements</code>关键字来实现接口</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">polygon</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">getarea</span><span class="params">(<span class="type">int</span> length, <span class="type">int</span> breadth)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">rectangle</span> <span class="keyword">implements</span> <span class="title class_">polygon</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getarea</span><span class="params">(<span class="type">int</span> length, <span class="type">int</span> breadth)</span> &#123;</span><br><span class="line">       system.out.println(<span class="string">&quot;the area is: &quot;</span> + length * breadth);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span> &#123;</span><br><span class="line">        <span class="type">rectangle</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">rectangle</span>();</span><br><span class="line">        r1.getarea(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="接口中的私有方法和静态方法"><a href="#接口中的私有方法和静态方法" class="headerlink" title="接口中的私有方法和静态方法"></a>接口中的私有方法和静态方法</h3><p>与类相似，可以使用其引用访问接口的静态方法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">polygon.staticmethod();</span><br></pre></td></tr></table></figure></div>

<h3 id="接口中的默认方法"><a href="#接口中的默认方法" class="headerlink" title="接口中的默认方法"></a>接口中的默认方法</h3><p>要在接口内使用默认方法，可以使用<code>default</code>关键字</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">getside</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>具体实现</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.math;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">polygon</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">getarea</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">getperimeter</span><span class="params">(<span class="type">int</span>... sides)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">perimeter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> side : sides) &#123;</span><br><span class="line">            perimeter += side;</span><br><span class="line">        &#125;</span><br><span class="line">        system.out.println(<span class="string">&quot;the total sides is: &quot;</span> + perimeter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">trangle</span> <span class="keyword">implements</span> <span class="title class_">polygon</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> a, b, c;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> s, area;</span><br><span class="line"></span><br><span class="line">    trangle(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">        s = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getarea</span><span class="params">()</span> &#123;</span><br><span class="line">        s = (<span class="type">double</span>) (a + b + c) / <span class="number">2</span>;</span><br><span class="line">        area = math.sqrt(s * (s - a) * (s - b) * (s - c));</span><br><span class="line">        system.out.println(<span class="string">&quot;the area is: &quot;</span> + area);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span> &#123;</span><br><span class="line">        <span class="type">trangle</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">trangle</span>(<span class="number">2</span> , <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        t1.getarea();</span><br><span class="line">        t1.getperimeter(<span class="number">2</span> , <span class="number">3</span> , <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="接口与extends关键字"><a href="#接口与extends关键字" class="headerlink" title="接口与extends关键字"></a>接口与extends关键字</h3><p>接口可以继承其他接口</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">line</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">polygon</span> <span class="keyword">extends</span> <span class="title class_">line</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>注意一个接口可以继承多个接口</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">a</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">b</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">c</span> <span class="keyword">extends</span> <span class="title class_">a</span>, b &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h2 id="java抽象类和抽象方法"><a href="#java抽象类和抽象方法" class="headerlink" title="java抽象类和抽象方法"></a>java抽象类和抽象方法</h2><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>java抽象类是无法实例化的类，使用<code>abstract</code>声明</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">animal</span> &#123;</span><br><span class="line">    <span class="comment">// doing something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><p>依然使用<code>abstract</code>关键字来创建抽象方法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">makesound</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="抽象类的继承"><a href="#抽象类的继承" class="headerlink" title="抽象类的继承"></a>抽象类的继承</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">displayinfo</span><span class="params">()</span> &#123;</span><br><span class="line">        system.out.println(<span class="string">&quot;i am a animal&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dog</span> <span class="keyword">extends</span> <span class="title class_">animal</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span> &#123;</span><br><span class="line">        <span class="type">dog</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">dog</span>();</span><br><span class="line">        d1.displayinfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>输出如下</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">i am a animal</span><br></pre></td></tr></table></figure></div>

<h3 id="重写抽象方法"><a href="#重写抽象方法" class="headerlink" title="重写抽象方法"></a>重写抽象方法</h3><p>在java中，必须在子类重写父类的抽象方法。如果子类也被声明为抽象，则不必强制重写抽象方法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">animal</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">makesound</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        system.out.println(<span class="string">&quot;i can eat...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dog</span> <span class="keyword">extends</span> <span class="title class_">animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makesound</span><span class="params">()</span> &#123;</span><br><span class="line">        system.out.println(<span class="string">&quot;barking...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span> &#123;</span><br><span class="line">        <span class="type">dog</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">dog</span>();</span><br><span class="line">        d1.eat();</span><br><span class="line">        d1.makesound();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="访问抽象类的构造函数"><a href="#访问抽象类的构造函数" class="headerlink" title="访问抽象类的构造函数"></a>访问抽象类的构造函数</h3><p>依旧使用<code>super()</code>关键字访问父类</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">animal</span> &#123;</span><br><span class="line">    animal() &#123;</span><br><span class="line">        <span class="comment">// doing something...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dog</span> <span class="keyword">extends</span> <span class="title class_">animal</span> &#123;</span><br><span class="line">    dog() &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="java抽象实例"><a href="#java抽象实例" class="headerlink" title="java抽象实例"></a>java抽象实例</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">animal</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">makesound</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dog</span> <span class="keyword">extends</span> <span class="title class_">animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makesound</span><span class="params">()</span> &#123;</span><br><span class="line">        system.out.println(<span class="string">&quot;barking...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cat</span> <span class="keyword">extends</span> <span class="title class_">animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makesound</span><span class="params">()</span> &#123;</span><br><span class="line">        system.out.println(<span class="string">&quot;meows...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(animal... ani)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(ani.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(animal val : ani) &#123;</span><br><span class="line">            val.makesound();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span> &#123;</span><br><span class="line">        <span class="type">dog</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">dog</span>();</span><br><span class="line">        <span class="type">cat</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">cat</span>();</span><br><span class="line"></span><br><span class="line">        test(d1, c1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>为了实现抽象类的功能，我们从其继承子类并创建该子类的对象。</li>
<li>类必须重写抽象类的所有抽象方法。但是，如果子类被声明为抽象的，则不必强制重写抽象方法。</li>
</ul>
<h2 id="嵌套静态类"><a href="#嵌套静态类" class="headerlink" title="嵌套静态类"></a>嵌套静态类</h2><p>与常规类一样，静态嵌套类可以同时包含静态和非静态方法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">animal</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">mammal</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>例子</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">animal</span> &#123;</span><br><span class="line">    <span class="comment">// 内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">reptile</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">displayinfo</span><span class="params">()</span> &#123;</span><br><span class="line">            system.out.println(<span class="string">&quot;i am a reptile...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">mammal</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">displayinfo</span><span class="params">()</span> &#123;</span><br><span class="line">            system.out.println(<span class="string">&quot;i am a mammal...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建外部类对象</span></span><br><span class="line">        <span class="type">animal</span> <span class="variable">ani</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">animal</span>();</span><br><span class="line">        <span class="comment">//非静态类的对象创建</span></span><br><span class="line">        animal.<span class="type">reptile</span> <span class="variable">rep</span> <span class="operator">=</span> ani.<span class="keyword">new</span> <span class="title class_">reptile</span>();</span><br><span class="line">        rep.displayinfo();</span><br><span class="line">        <span class="comment">//静态嵌套类的对象创建</span></span><br><span class="line">        animal.<span class="type">mammal</span> <span class="variable">ma</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">animal</span>.mammal();</span><br><span class="line">        ma.displayinfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在上面的实例中<br>关于非静态类reptile的创建，使用</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">animal.<span class="type">reptile</span> <span class="variable">rep</span> <span class="operator">=</span> ani.<span class="keyword">new</span> <span class="title class_">reptile</span>();</span><br></pre></td></tr></table></figure></div>

<p>关于静态类mammal的创建，使用</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">animal.<span class="type">mammal</span> <span class="variable">ma</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">animal</span>.mammal();</span><br></pre></td></tr></table></figure></div>

<h3 id="访问外部类的成员"><a href="#访问外部类的成员" class="headerlink" title="访问外部类的成员"></a>访问外部类的成员</h3><p>静态嵌套类只能访问外部类的成员（静态字段和方法）</p>
<p>示例：访问非静态成员</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">animal</span> &#123;</span><br><span class="line">    <span class="comment">// 内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">reptile</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">displayinfo</span><span class="params">()</span> &#123;</span><br><span class="line">            system.out.println(<span class="string">&quot;i am a reptile...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">mammal</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">displayinfo</span><span class="params">()</span> &#123;</span><br><span class="line">            system.out.println(<span class="string">&quot;i am a mammal...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        system.out.println(<span class="string">&quot;eating...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建外部类对象</span></span><br><span class="line">        <span class="type">animal</span> <span class="variable">ani</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">animal</span>();</span><br><span class="line">        <span class="comment">//非静态类的对象创建</span></span><br><span class="line">        animal.<span class="type">reptile</span> <span class="variable">rep</span> <span class="operator">=</span> ani.<span class="keyword">new</span> <span class="title class_">reptile</span>();</span><br><span class="line">        rep.displayinfo();</span><br><span class="line">        <span class="comment">//静态嵌套类的对象创建</span></span><br><span class="line">        animal.<span class="type">mammal</span> <span class="variable">ma</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">animal</span>.mammal();</span><br><span class="line">        ma.displayinfo();</span><br><span class="line">        ma.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">/home/encounter/code/java/learning/src/main.java:31:11</span><br><span class="line">java: 找不到符号</span><br><span class="line">  符号:   方法 eat()</span><br><span class="line">  位置: 类型为animal.mammal的变量 ma</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>在上面的实例中，animal类中创建了一个非静态的方法eat()，由于ma是静态类的对象，因此无法从静态类访问非静态方法</p>
<h3 id="静态顶级类"><a href="#静态顶级类" class="headerlink" title="静态顶级类"></a>静态顶级类</h3><p>只有嵌套类可以是静态的，不能有静态的顶级类</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">displayinfo</span><span class="params">()</span> &#123;</span><br><span class="line">        system.out.println(<span class="string">&quot;i am an animal&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span> &#123;</span><br><span class="line">        animal.displayinfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">/home/encounter/code/java/learning/src/main.java</span><br><span class="line">java: 此处不允许使用修饰符static</span><br></pre></td></tr></table></figure></div>

<h3 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h3><p>在java中，一个类可以包含另一个称为嵌套类的类。可以在不提供任何名称的情况下创建嵌套类。</p>
<p><em><strong>没有任何名称的嵌套类成为匿名类</strong></em></p>
<p>必须在另一个类定一个匿名类，因此也被成为匿名内部类</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">outerclass</span> &#123;</span><br><span class="line">    <span class="comment">// define</span></span><br><span class="line">    object1 = <span class="keyword">new</span> <span class="title class_">type</span>(paramenterlist) &#123;</span><br><span class="line">        <span class="comment">// doing something...</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>匿名类通常继承子类或实现接口<br>在这里, **类型(type)**可以是  </p>
<ol>
<li>匿名类继承的父类</li>
<li>匿名实现的接口</li>
</ol>
<p>实例：匿名内部类继承类  </p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">polygon</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        system.out.println(<span class="string">&quot;in class of polygon&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">anonymousdemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createclass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建匿名类，继承类polygon</span></span><br><span class="line">        <span class="type">polygon</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">polygon</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">                system.out.println(<span class="string">&quot;in class of anonymousdemo&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        p1.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span> &#123;</span><br><span class="line">        <span class="type">anonymousdemo</span> <span class="variable">any</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">anonymousdemo</span>();</span><br><span class="line">        any.createclass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">in class of anonymousdemo</span><br></pre></td></tr></table></figure></div>
<p>在上面的实例中，创建了一个类<code>polygon</code>，只有一个方法<code>display()</code>，然后创建了一个匿名类，该类继承类<code>polygon</code>并重写了<code>display()</code>方法，在运行时，将创建一个类p1,然后调用p1的<code>display()</code>方法</p>
<p>实例：实现接口的匿名类</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">polygon</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">anonymousdemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createclass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">polygon</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">polygon</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">                system.out.println(<span class="string">&quot;in class of anonymousdemo&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        p1.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span> &#123;</span><br><span class="line">        <span class="type">anonymousdemo</span> <span class="variable">any</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">anonymousdemo</span>();</span><br><span class="line">        any.createclass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>输出</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">in class of anonymousdemo</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="匿名类的优点"><a href="#匿名类的优点" class="headerlink" title="匿名类的优点"></a>匿名类的优点</h3><p>在匿名类中，只需要创建对象。即创建对象执行某些任务</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">object = <span class="keyword">new</span> <span class="title class_">example</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        system.out.println(<span class="string">&quot;overwrite display()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>socket的创建和连接</title>
    <url>/2024/06/30/linux-socket-programming-1/</url>
    <content><![CDATA[<h1 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h1><h2 id="socket的概念"><a href="#socket的概念" class="headerlink" title="socket的概念"></a>socket的概念</h2><p>Socket（套接字）是计算机网络编程中的一个基本概念，它为应用程序提供了访问底层网络协议的接口，使得进程间能够通过网络进行通信。在更广泛的意义上，Socket 是操作系统提供的一个抽象层，用于简化网络编程并隐藏复杂的网络协议细节。</p>
<p>Socket 是两个进程间通信的端点，每个 Socket 都有唯一的地址，这个地址包括 IP 地址和端口号。IP 地址用于定位网络上的主机，而端口号则用于区分同一台主机上的不同服务。</p>
<h2 id="socket的类型"><a href="#socket的类型" class="headerlink" title="socket的类型"></a>socket的类型</h2><p>socket 可以分为几种类型，主要依据它们支持的协议和通信模式：</p>
<ul>
<li><strong>流式 Socket (SOCK_STREAM)：</strong> 基于 TCP 协议，提供面向连接的服务，保证数据的顺序传输，且不会丢失数据。</li>
<li><strong>数据报 Socket (SOCK_DGRAM)：</strong> 基于 UDP 协议，提供无连接服务，数据报文独立传输，不保证数据的顺序和完整性，但传输效率较高。</li>
<li><strong>原始 Socket (SOCK_RAW)：</strong> 直接访问 IP 层，允许应用程序直接处理 IP 数据包，常用于网络分析或特殊用途的软件。</li>
</ul>
<h2 id="socket提供的函数"><a href="#socket提供的函数" class="headerlink" title="socket提供的函数"></a>socket提供的函数</h2><ul>
<li><code>socket()</code> 创建一个新的确定类型的套接字，类型用一个整型数值标识，并为它分配系统资源。</li>
<li><code>bind()</code> 一般用于服务器端，将一个套接字与一个套接字地址结构相关联，比如，一个指定的本地端口和IP地址。</li>
<li><code>listen()</code> 用于服务器端，使一个绑定的TCP套接字进入监听状态。</li>
<li><code>connect()</code>用于客户端，为一个套接字分配一个自由的本地端口号。 如果是TCP套接字的话，它会试图获得一个新的TCP连接。</li>
<li><code>accept()</code>用于服务器端。 它接受一个从远端客户端发出的创建一个新的TCP连接的接入请求，创建一个新的套接字，与该连接相应的套接字地址相关联。</li>
<li><code>send()</code>和<code>recv()</code>,或者<code>write()</code>和<code>read()</code>,或者<code>recvfrom()</code>和<code>sendto()</code>,用于往&#x2F;从远程套接字发送和接受数据。</li>
<li><code>close()</code>用于系统释放分配给一个套接字的资源。 如果是TCP，连接会被中断。</li>
<li><code>gethostbyname()</code>和&#96;gethostbyaddr()</li>
<li><code>select()</code>用于修整有如下情况的套接字列表： 准备读，准备写或者是有错误。</li>
<li><code>poll()</code>用于检查套接字的状态。 套接字可以被测试，看是否可以写入、读取或是有错误。</li>
<li><code>getsockopt()</code>用于查询指定的套接字一个特定的套接字选项的当前值。</li>
<li><code>setsockopt()</code>用于为指定的套接字设定一个特定的套接字选项。</li>
</ul>
<h3 id="1-socket"><a href="#1-socket" class="headerlink" title="1. socket()"></a>1. <code>socket()</code></h3><ul>
<li><strong>作用</strong>：创建一个新的 Socket。</li>
<li><strong>参数</strong>：<ul>
<li><code>int domain</code>：地址族，如 <code>AF_INET</code>（IPv4）或 <code>AF_INET6</code>（IPv6）。</li>
<li><code>int type</code>：Socket 类型，如 <code>SOCK_STREAM</code>（面向连接，流式）或 <code>SOCK_DGRAM</code>（无连接，数据报）。</li>
<li><code>int protocol</code>：协议，通常是 <code>0</code>，表示使用与 <code>type</code> 关联的默认协议。</li>
</ul>
</li>
</ul>
<h3 id="2-bind"><a href="#2-bind" class="headerlink" title="2. bind()"></a>2. <code>bind()</code></h3><ul>
<li><strong>作用</strong>：将 Socket 与本地地址（IP 地址和端口号）相关联。</li>
<li><strong>参数</strong>：<ul>
<li><code>int sockfd</code>：Socket 文件描述符。</li>
<li><code>const struct sockaddr *addr</code>：指向包含地址信息的 <code>sockaddr</code> 结构体的指针。</li>
<li><code>socklen_t addrlen</code>：<code>sockaddr</code> 结构体的长度。</li>
</ul>
</li>
</ul>
<h3 id="3-listen"><a href="#3-listen" class="headerlink" title="3. listen()"></a>3. <code>listen()</code></h3><ul>
<li><strong>作用</strong>：使 Socket 准备接收连接，通常用于服务器端。</li>
<li><strong>参数</strong>：<ul>
<li><code>int sockfd</code>：Socket 文件描述符。</li>
<li><code>int backlog</code>：待处理连接请求的最大队列长度。</li>
</ul>
</li>
</ul>
<h3 id="4-accept"><a href="#4-accept" class="headerlink" title="4. accept()"></a>4. <code>accept()</code></h3><ul>
<li><strong>作用</strong>：接受传入的连接请求，并返回一个新的 Socket 文件描述符用于通信。</li>
<li><strong>参数</strong>：<ul>
<li><code>int sockfd</code>：监听的 Socket 文件描述符。</li>
<li><code>struct sockaddr *addr</code>：可选参数，用于存储客户端的地址信息。</li>
<li><code>socklen_t *addrlen</code>：可选参数，用于存储地址信息的长度。</li>
</ul>
</li>
</ul>
<h3 id="5-connect"><a href="#5-connect" class="headerlink" title="5. connect()"></a>5. <code>connect()</code></h3><ul>
<li><strong>作用</strong>：初始化与远程主机的连接，通常用于客户端。</li>
<li><strong>参数</strong>：<ul>
<li><code>int sockfd</code>：Socket 文件描述符。</li>
<li><code>const struct sockaddr *addr</code>：指向包含远程主机地址信息的 <code>sockaddr</code> 结构体的指针。</li>
<li><code>socklen_t addrlen</code>：<code>sockaddr</code> 结构体的长度。</li>
</ul>
</li>
</ul>
<h3 id="6-send"><a href="#6-send" class="headerlink" title="6. send()"></a>6. <code>send()</code></h3><ul>
<li><strong>作用</strong>：发送数据到已连接的 Socket。</li>
<li><strong>参数</strong>：<ul>
<li><code>int sockfd</code>：Socket 文件描述符。</li>
<li><code>const void *buf</code>：指向要发送数据的缓冲区的指针。</li>
<li><code>size_t len</code>：要发送的数据长度。</li>
<li><code>int flags</code>：发送标志，如 <code>MSG_DONTROUTE</code>。</li>
</ul>
</li>
</ul>
<h3 id="7-recv"><a href="#7-recv" class="headerlink" title="7. recv()"></a>7. <code>recv()</code></h3><ul>
<li><strong>作用</strong>：从 Socket 接收数据。</li>
<li><strong>参数</strong>：<ul>
<li><code>int sockfd</code>：Socket 文件描述符。</li>
<li><code>void *buf</code>：接收数据的缓冲区。</li>
<li><code>size_t len</code>：缓冲区的大小。</li>
<li><code>int flags</code>：接收标志，如 <code>MSG_PEEK</code>。</li>
</ul>
</li>
</ul>
<h3 id="8-sendto"><a href="#8-sendto" class="headerlink" title="8. sendto()"></a>8. <code>sendto()</code></h3><ul>
<li><strong>作用</strong>：向特定地址发送数据，通常用于无连接的 Socket（如 UDP）。</li>
<li><strong>参数</strong>：与 <code>send()</code> 类似，额外包括目标地址和地址长度。</li>
</ul>
<h3 id="9-recvfrom"><a href="#9-recvfrom" class="headerlink" title="9. recvfrom()"></a>9. <code>recvfrom()</code></h3><ul>
<li><strong>作用</strong>：接收数据并返回源地址信息，通常用于无连接的 Socket（如 UDP）。</li>
<li><strong>参数</strong>：与 <code>recv()</code> 类似，额外包括源地址信息和地址长度。</li>
</ul>
<h3 id="10-close"><a href="#10-close" class="headerlink" title="10. close()"></a>10. <code>close()</code></h3><ul>
<li><strong>作用</strong>：关闭 Socket 文件描述符，释放资源。</li>
<li><strong>参数</strong>：<ul>
<li><code>int sockfd</code>：要关闭的 Socket 文件描述符。</li>
</ul>
</li>
</ul>
<h3 id="11-setsockopt"><a href="#11-setsockopt" class="headerlink" title="11. setsockopt()"></a>11. <code>setsockopt()</code></h3><ul>
<li><strong>作用</strong>：设置 Socket 的选项，如超时、重用地址等。</li>
<li><strong>参数</strong>：<ul>
<li><code>int sockfd</code>：Socket 文件描述符。</li>
<li><code>int level</code>：设置选项的级别，如 <code>SOL_SOCKET</code> 或 <code>IPPROTO_TCP</code>。</li>
<li><code>int optname</code>：选项名称。</li>
<li><code>const void *optval</code>：指向选项值的指针。</li>
<li><code>socklen_t optlen</code>：选项值的长度。</li>
</ul>
</li>
</ul>
<h3 id="12-getsockopt"><a href="#12-getsockopt" class="headerlink" title="12. getsockopt()"></a>12. <code>getsockopt()</code></h3><ul>
<li><strong>作用</strong>：获取 Socket 的选项。</li>
<li><strong>参数</strong>：与 <code>setsockopt()</code> 类似。</li>
</ul>
<h3 id="13-shutdown"><a href="#13-shutdown" class="headerlink" title="13. shutdown()"></a>13. <code>shutdown()</code></h3><ul>
<li><strong>作用</strong>：关闭 Socket 的读取或写入方向。</li>
<li><strong>参数</strong>：<ul>
<li><code>int sockfd</code>：Socket 文件描述符。</li>
<li><code>int how</code>：关闭的方向，如 <code>SHUT_RD</code>（读取方向）或 <code>SHUT_WR</code>（写入方向）。</li>
</ul>
</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>使用 Socket 编程时，应确保正确处理错误情况，检查每个函数的返回值，并适当地处理任何错误代码。</li>
<li>对于某些函数，如 <code>send()</code> 和 <code>recv()</code>，如果在非阻塞模式下使用，可能需要处理 EAGAIN 或 EWOULDBLOCK 错误码，这表明操作无法立即完成。</li>
<li>在实际编程中，根据具体需求，可能还需要使用到其他函数，例如 <code>select()</code> 或 <code>poll()</code> 用于多路复用，或者 <code>fork()</code> 和 <code>exec()</code> 用于创建子进程处理连接。</li>
</ul>
<h2 id="TCP-socket通信流程"><a href="#TCP-socket通信流程" class="headerlink" title="TCP socket通信流程"></a>TCP socket通信流程</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/06/30/SPcvUQlrHe3F9ZI.png"
                      alt="tcp-socket.png"
                ></p>
<p>服务器端流程如下：</p>
<ol>
<li>创建服务器的<code>socket</code></li>
<li>初始化<code>sever_addr</code>(服务器地址)</li>
<li>将<code>socket</code>和<code>server_addr</code>绑定 bind</li>
<li>开始监听<code>listen</code></li>
<li>开一个循环保证服务器不会结束，不断的<code>accept</code>接入的客户端请求，进行读写操作<code>write</code>和<code>read</code> (send()和recv()也行)</li>
<li>关闭<code>socket</code></li>
</ol>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_PORT 10005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFLEN 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BACLOG 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新的socket，返回文件描述符</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">create_socket</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> res = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> 如果想要使用UDP协议，只需要将SOCK_STREAM改为SOCK_DGRAM即可</span></span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;create socket failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;create socket successfully\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化服务器地址信息</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initialize_address</span><span class="params">(<span class="keyword">struct</span> sockaddr_in *server_addr)</span> &#123;</span><br><span class="line">    <span class="built_in">memset</span>(server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(*server_addr));</span><br><span class="line">    server_addr-&gt;sin_family = AF_INET;</span><br><span class="line">    <span class="comment">// 监听所有可用地址</span></span><br><span class="line">    server_addr-&gt;sin_addr.s_addr = htons(INADDR_ANY);</span><br><span class="line">    server_addr-&gt;sin_port = htons(SERVER_PORT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定socket到指定的地址</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">try_bind</span><span class="params">(<span class="type">int</span> socket_fd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *server_addr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (bind(socket_fd, server_addr, <span class="keyword">sizeof</span>(*server_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;bind successfully&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理客户端请求</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">process_client_request</span><span class="params">(<span class="type">int</span> socket_client)</span> &#123;</span><br><span class="line">    <span class="type">char</span> send_buf[BUFFLEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span> recv_buf[BUFFLEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送的消息，以方便日后添加或修改</span></span><br><span class="line">    <span class="built_in">snprintf</span>(send_buf, BUFFLEN, <span class="string">&quot;Hello, this is the server&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">ssize_t</span> num_read = read(socket_client, recv_buf, BUFFLEN);</span><br><span class="line">        <span class="comment">// 客户端断开连接，或读取失败</span></span><br><span class="line">        <span class="keyword">if</span> (num_read &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num_read == <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;Client closed connection&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                perror(<span class="string">&quot;read failed&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        recv_buf[num_read] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 为接收的字符串添加结束字符</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;From Client: %s\n&quot;</span>, recv_buf);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strncmp</span>(recv_buf, <span class="string">&quot;exit&quot;</span>, <span class="number">4</span>) == <span class="number">0</span>) &#123; <span class="comment">// 客户端请求退出</span></span><br><span class="line">            <span class="comment">// 修改发送的消息</span></span><br><span class="line">            <span class="built_in">strcpy</span>(send_buf, <span class="string">&quot;bye!!!&quot;</span>);</span><br><span class="line">            <span class="comment">// 返回消息给客户端</span></span><br><span class="line">            write(socket_client, send_buf, <span class="built_in">strlen</span>(send_buf));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Me(Server)：%s\n&quot;</span>, send_buf);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向客户端写入发送缓冲区的内容</span></span><br><span class="line">        <span class="keyword">if</span> (write(socket_client, send_buf, <span class="built_in">strlen</span>(send_buf)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;write failed&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Me(Server): %s\n&quot;</span>, send_buf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清空接收缓冲区，准备下一次读取</span></span><br><span class="line">        <span class="built_in">memset</span>(recv_buf, <span class="number">0</span>, BUFFLEN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> socket_server = create_socket(); <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span> <span class="comment">// 声明地址结构</span></span><br><span class="line"></span><br><span class="line">    initialize_address(&amp;server_addr); <span class="comment">// 初始化地址结构</span></span><br><span class="line">    try_bind(socket_server, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr); <span class="comment">// 绑定地址到socket</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始监听连接请求，设定最大等待连接数量为BACLOG</span></span><br><span class="line">    <span class="keyword">if</span> (listen(socket_server, BACLOG) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;start listening&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> client_addr_size = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 初始化客户端地址结构</span></span><br><span class="line">        <span class="built_in">memset</span>(&amp;client_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(client_addr));</span><br><span class="line">        <span class="comment">// 接受新的连接请求</span></span><br><span class="line">        <span class="type">int</span> socket_client = accept(socket_server, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;client_addr_size);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Client %s:%d connected\n&quot;</span>,</span><br><span class="line">            inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));</span><br><span class="line">        <span class="keyword">if</span> (socket_client &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;receive failed&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 尝试接受另一个连接</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 满足要求后开始处理客户端请求</span></span><br><span class="line">        process_client_request(socket_client);</span><br><span class="line">        close(socket_client); <span class="comment">// 关闭客户端连接</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正常情况下不会执行到这一步</span></span><br><span class="line">    close(socket_server);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>客户端流程如下：</p>
<ol>
<li>创建客户端<code>socket</code></li>
<li>初始化<code>server_addr</code></li>
<li>连接到服务器<code>connect</code></li>
<li>利用<code>write</code>和<code>read</code>进行读写操作 (send()和recv()也行)</li>
<li>关闭<code>socket</code></li>
</ol>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_PORT 10005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFLEN 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建套接字并返回其文件描述符</span></span><br><span class="line"><span class="comment"> * 如果创建失败，程序将以状态1退出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">create_socket</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sock_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sock_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket创建失败&quot;</span>); <span class="comment">// 使用perror提供更多的错误信息</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;socket create successfully\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> sock_fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 初始化服务器地址结构的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initialize_address</span><span class="params">(<span class="keyword">struct</span> sockaddr_in *server_addr)</span> &#123;</span><br><span class="line">    <span class="built_in">memset</span>(server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(*server_addr));</span><br><span class="line">    server_addr-&gt;sin_family = AF_INET;</span><br><span class="line">    server_addr-&gt;sin_port = htons(SERVER_PORT);</span><br><span class="line">    server_addr-&gt;sin_addr.s_addr = inet_addr(<span class="string">&quot;192.168.5.120&quot;</span>); <span class="comment">// 服务器IP</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 建立到服务器的连接</span></span><br><span class="line"><span class="comment"> * 如果连接失败，程序将以状态1退出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">connect_to_server</span><span class="params">(<span class="type">int</span> socket_fd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *server_addr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (connect(socket_fd, server_addr, <span class="keyword">sizeof</span>(*server_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;connection failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connection successful\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 客户端程序开始的主函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> socket_fd = create_socket(); <span class="comment">// 创建socket</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    initialize_address(&amp;server_addr); <span class="comment">// 初始化服务器详细信息</span></span><br><span class="line"></span><br><span class="line">    connect_to_server(socket_fd, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr); <span class="comment">// 连接到服务器</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> send_buf[BUFFLEN] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 用于发送数据的缓冲区</span></span><br><span class="line">    <span class="type">char</span> recv_buf[BUFFLEN] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 用于接收数据的缓冲区</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 持续从用户获取输入并发送到服务器，直到从服务器接收到&quot;bye!!!&quot;</span></span><br><span class="line">    <span class="keyword">while</span> (fgets(send_buf, BUFFLEN, <span class="built_in">stdin</span>)) &#123;</span><br><span class="line">        <span class="comment">// 向服务器写入用户输入</span></span><br><span class="line">        <span class="keyword">if</span> (write(socket_fd, send_buf, strnlen(send_buf, BUFFLEN)) == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;write failed&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Me(Client):%s&quot;</span>, send_buf); <span class="comment">// 打印用户输入</span></span><br><span class="line">        <span class="built_in">memset</span>(send_buf, <span class="number">0</span>, BUFFLEN); <span class="comment">// 清除发送缓冲区</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取服务器的响应</span></span><br><span class="line">        <span class="keyword">if</span> (read(socket_fd, recv_buf, BUFFLEN) == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;receive failed&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Server:%s&quot;</span>, recv_buf); <span class="comment">// 打印服务器的响应</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(recv_buf, <span class="string">&quot;bye!!!&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(recv_buf, <span class="number">0</span>, BUFFLEN); <span class="comment">// 清除接收缓冲区</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(socket_fd); <span class="comment">// 关闭套接字</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>网络编程</tag>
        <tag>socket</tag>
        <tag>计算机网络</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>asio socket的创建和连接</title>
    <url>/2024/07/03/linux-socket-programming-2/</url>
    <content><![CDATA[<h1 id="终端节点的创建"><a href="#终端节点的创建" class="headerlink" title="终端节点的创建"></a>终端节点的创建</h1><p>所谓终端节点就是用来通信的端对端的节点，可以通过ip地址和端口构造，其的节点可以连接这个终端节点做通信</p>
<p>如果是客户端，可以通过对端的ip和端口构造一个<code>endpoint</code>对象</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">client_endpoint</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 定义需要解析的IP地址字符串和端口号</span></span><br><span class="line">    std::string raw_ip_address = <span class="string">"127.0.0.1"</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port_num   = <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">    boost::system::error_code error; <span class="comment">// 错误代码容器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Boost.Asio库中的ip::address_from_string()函数解析IP地址字符串</span></span><br><span class="line">    boost::asio::ip::address ip_address =</span><br><span class="line">        boost::asio::ip::address::<span class="built_in">from_string</span>( raw_ip_address, error );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查解析过程是否有错误发生，并输出相应的错误信息或返回错误代码</span></span><br><span class="line">    <span class="keyword">if</span> (error.<span class="built_in">value</span>() != <span class="number">0</span>) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Failed to parse IP address. Error code is: "</span></span><br><span class="line">                  &lt;&lt; error.<span class="built_in">value</span>() &lt;&lt; <span class="string">", Message: "</span></span><br><span class="line">                  &lt;&lt; error.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> error.<span class="built_in">value</span>(); <span class="comment">// 返回错误代码</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用解析的IP地址和端口号构建TCP endpoint对象</span></span><br><span class="line">    boost::asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">( ip_address, port_num )</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数返回值，表示操作是否成功执行（如果未抛出异常则假设为0）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>如果是服务端，则只需要本地地址绑定就可以生成<code>endpoint</code></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">server_endpoint</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port_num = <span class="number">8080</span>; <span class="comment">// 设置服务器监听端口号为8080</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用IPv4地址类型设置一个任意的本地IP地址。这意味着服务器将侦听来自任何合法的IPv4地址。</span></span><br><span class="line">    boost::asio::ip::address ip_address = boost::asio::ip::address_v4::<span class="built_in">any</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个TCP端点（endpoint），它将绑定到指定的本地IP地址和端口号上</span></span><br><span class="line">    boost::asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(ip_address, port_num)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 表示函数执行成功，返回值为0</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h1 id="创建socket"><a href="#创建socket" class="headerlink" title="创建socket"></a>创建socket</h1><ol>
<li>创建上下文<code>io_context</code></li>
<li>选择协议</li>
<li>生成<code>socket</code></li>
<li>打开<code>socket</code></li>
</ol>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">create_tcp_socket</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 使用boost::asio中的ip模块和tcp类定义协议版本v4的套接字</span></span><br><span class="line">    <span class="keyword">using</span> boost::asio::ip::tcp;</span><br><span class="line">    boost::asio::io_context ios; <span class="comment">// 创建IO上下文，用于处理异步操作</span></span><br><span class="line"></span><br><span class="line">    tcp protocol = tcp::<span class="built_in">v4</span>(); <span class="comment">// 初始化并配置为IPv4协议</span></span><br><span class="line"></span><br><span class="line">    <span class="function">tcp::socket <span class="title">sock</span><span class="params">( ios,</span></span></span><br><span class="line"><span class="params"><span class="function">        protocol )</span></span>; <span class="comment">// 使用给定的io_context创建一个新套接字，并将其初始化为指定协议版本</span></span><br><span class="line">    boost::system::error_code ec; <span class="comment">// 创建错误代码对象，用于捕获可能发生的异常</span></span><br><span class="line"></span><br><span class="line">    sock.<span class="built_in">open</span>( protocol, ec ); <span class="comment">// 尝试打开一个与指定协议兼容的新套接字</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( ec.<span class="built_in">value</span>() != <span class="number">0</span> ) { <span class="comment">// 检查是否发生任何错误</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Failed to open the socket! Error code: "</span> &lt;&lt; ec.<span class="built_in">value</span>()</span><br><span class="line">                  &lt;&lt; <span class="string">" Message: "</span> &lt;&lt; ec.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> ec.<span class="built_in">value</span>(); <span class="comment">// 如果打开套接字失败，返回错误代码作为结果值</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 成功的情况下，函数返回0表示成功创建了TCP套接字</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>上面的<code>socket</code>只是通信的<code>socket</code>,如果是服务端，我们还需要生成一个<code>acceptor</code>的<code>socket</code>,用来接受新的连接</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">create_acceptor_socket</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 使用boost::asio中的ip模块和tcp类定义协议版本v6的套接字接受器（acceptor）</span></span><br><span class="line">    <span class="keyword">using</span> boost::asio::ip::tcp;</span><br><span class="line">    boost::asio::io_context ios; <span class="comment">// 创建IO上下文，用于处理异步操作</span></span><br><span class="line"></span><br><span class="line">    tcp protocol = tcp::<span class="built_in">v6</span>(); <span class="comment">// 初始化并配置为IPv6协议</span></span><br><span class="line"></span><br><span class="line">    <span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ios )</span></span>; <span class="comment">// 使用给定的io_context创建一个新接受器（acceptor），用于监听连接请求</span></span><br><span class="line"></span><br><span class="line">    boost::system::error_code ec; <span class="comment">// 创建错误代码对象，用于捕获可能发生的异常</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试打开一个与指定协议兼容的新接受器</span></span><br><span class="line">    acceptor.<span class="built_in">open</span>( protocol, ec );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( ec.<span class="built_in">value</span>() != <span class="number">0</span> ) { <span class="comment">// 检查是否发生任何错误</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Failed to open the socket! Error code: "</span> &lt;&lt; ec.<span class="built_in">value</span>()</span><br><span class="line">                  &lt;&lt; <span class="string">" Message: "</span> &lt;&lt; ec.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> ec.<span class="built_in">value</span>(); <span class="comment">// 如果打开接受器失败，返回错误代码作为结果值</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 成功的情况下，函数返回0表示成功创建了IPv6协议的接受器（acceptor）</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h1 id="绑定acceptor"><a href="#绑定acceptor" class="headerlink" title="绑定acceptor"></a>绑定acceptor</h1><p>对于acceptor类型的socket,服务器需要将其绑定到指定的断点，所有连接这个端点的连接都可以被接收到</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind_acceptor_socket</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 使用boost::asio中的ip模块和tcp类定义协议版本v4的套接字接受器（acceptor）</span></span><br><span class="line">    <span class="keyword">using</span> boost::asio::ip::tcp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定要绑定的端口号，这里为8080</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port_num = <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">tcp::endpoint <span class="title">endpoint</span><span class="params">( boost::asio::ip::address_v4::any(),</span></span></span><br><span class="line"><span class="params"><span class="function">        port_num )</span></span>; <span class="comment">// 创建一个网络端点对象用于指定IP地址和端口</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建IO上下文，用于处理异步操作</span></span><br><span class="line"></span><br><span class="line">    boost::asio::io_context ios;</span><br><span class="line"></span><br><span class="line">    <span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">( ios,</span></span></span><br><span class="line"><span class="params"><span class="function">        endpoint )</span></span>; <span class="comment">// 使用给定的io_context创建并初始化一个新接受器（acceptor），同时绑定到指定的端点</span></span><br><span class="line"></span><br><span class="line">    boost::system::error_code ec; <span class="comment">// 创建错误代码对象，用于捕获可能发生的异常</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试将接受器（acceptor）绑定到指定的网络端点</span></span><br><span class="line">    acceptor.<span class="built_in">bind</span>( endpoint, ec );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( ec.<span class="built_in">value</span>() != <span class="number">0</span> ) { <span class="comment">// 检查是否发生任何错误</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Failed to bind the socket! Error code: "</span> &lt;&lt; ec.<span class="built_in">value</span>()</span><br><span class="line">                  &lt;&lt; <span class="string">" Message: "</span> &lt;&lt; ec.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ec.<span class="built_in">value</span>(); <span class="comment">// 如果绑定失败，返回错误代码作为结果值</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 成功的情况下，函数返回0表示成功绑定了接受器（acceptor）到指定端口</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h1 id="连接指定的端点"><a href="#连接指定的端点" class="headerlink" title="连接指定的端点"></a>连接指定的端点</h1><p>作为客户端可以连接服务器指定的端点进行连接</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect_to_endpoint</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// IP地址字符串和端口号定义</span></span><br><span class="line">    std::string raw_ip_address = <span class="string">"127.0.0.1"</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port_num    = <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用std::exception类来捕获可能抛出的异常</span></span><br><span class="line">    <span class="keyword">using</span> boost::asio::ip::tcp;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="function">tcp::endpoint <span class="title">endpoint</span><span class="params">(boost::asio::ip::address::from_string(raw_ip_address), port_num)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建IO上下文，用于处理异步操作</span></span><br><span class="line"></span><br><span class="line">        boost::asio::io_context ios;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建socket并初始化为指定协议版本的套接字</span></span><br><span class="line">        <span class="function">tcp::socket <span class="title">soc</span><span class="params">(ios, endpoint.protocol())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试连接到指定端点（endpoint）</span></span><br><span class="line">        soc.<span class="built_in">connect</span>(endpoint);</span><br><span class="line">    } <span class="built_in">catch</span> (std::exception &amp;e) {</span><br><span class="line">        <span class="comment">// 如果在尝试连接时抛出异常，捕获它并输出错误信息</span></span><br><span class="line"></span><br><span class="line">        std::cerr &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 返回一个非零值表示连接失败</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error.<span class="built_in">value</span>(); <span class="comment">// 函数返回0表示成功建立了与指定端点的连接</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h1 id="服务器接收连接"><a href="#服务器接收连接" class="headerlink" title="服务器接收连接"></a>服务器接收连接</h1><p>当有客户端连接时，服务器需要接收连接</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept_new_connection</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 指定要监听的端口号，这里为8080</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port_num = <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> boost::asio::ip::</span><br><span class="line">        tcp; <span class="comment">// 使用ip模块和tcp类定义协议版本v4的套接字接受器（acceptor）</span></span><br><span class="line"></span><br><span class="line">    <span class="function">tcp::endpoint <span class="title">endpoint</span><span class="params">( boost::asio::ip::address_v4::any(),</span></span></span><br><span class="line"><span class="params"><span class="function">        port_num )</span></span>; <span class="comment">// 创建一个网络端点对象用于指定IP地址为任何可用地址和指定的端口</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建IO上下文，用于处理异步操作</span></span><br><span class="line"></span><br><span class="line">    boost::asio::io_context ios;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">( ios,</span></span></span><br><span class="line"><span class="params"><span class="function">            endpoint.protocol() )</span></span>; <span class="comment">// 使用给定的io_context创建并初始化一个新接受器（acceptor），同时绑定到指定的端点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置最大连接队列长度为BACKLOG</span></span><br><span class="line">        acceptor.<span class="built_in">listen</span>( BACKLOG );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建socket并初始化为指定协议版本的套接字</span></span><br><span class="line">        <span class="function">tcp::socket <span class="title">socket</span><span class="params">( ios, endpoint.protocol() )</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接受新的客户端连接请求，并将其绑定到新的socket对象上</span></span><br><span class="line">        acceptor.<span class="built_in">accept</span>( socket );</span><br><span class="line">    } <span class="built_in">catch</span> ( std::exception &amp;e ) {</span><br><span class="line">        <span class="comment">// 如果在处理过程中抛出异常，捕获并输出错误信息</span></span><br><span class="line"></span><br><span class="line">        std::cerr &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 返回一个非零值表示接受新连接失败</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 成功接收新的客户端连接后返回0作为结果值</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h1 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h1><p>buffer就是用来接收和发送数据时缓存数据的接口</p>
<p><code>boost::asio提</code>供了<code>asio::mutable_buffer</code>和<code>asio::const_buffer</code>两种类型的buffer，他们是一段连续的空间，首字节存储了后续数据的长度。<code>asio::mutable_buffer</code>用于写服务，<code>asio::const_buffer</code>用于读服务。但是着这两个结构都没有被asio的api直接使用</p>
<p>对于api的buffer参数，asio提出了<code>MutableBufferSequence</code>和<code>ConstBufferSequence</code>两种类型的buffer参数，他们是由多个<code>asio::mutable_buffer</code>和多个<code>asio::const_buffer</code>组成的容器。<code>MutableBufferSequence</code>和<code>ConstBufferSequence</code>的具体类型是<code>boost::asio::mutable_buffer</code>和<code>boost::asio::const_buffer</code>。也就是说<code>boost::asio</code>为了节省空间，将一部分连续空间组合起来，交给api使用。可以理解为<code>MutableBufferSequence</code>的数据结构为<code>std::vector&lt;boost::asio::mutable_buffer&gt;</code>，<code>ConstBufferSequence</code>的数据结构为<code>std::vector&lt;boost::asio::const_buffer&gt;</code></p>
<p><code>std::vector&lt;boost::asio::mutable_buffer&gt;</code>的结构如下</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2024/07/03/kqJpCB9e13wNYVx.png" alt="mutable_buffer.png"></p>
<p>每个vector存储的都是<code>mutable_buffer</code>的地址，每个<code>mutable_buffer</code>的第一个字节表示数据的长度，后面跟着数据内容。</p>
<p>这么复杂的结构交给用户使用并不合适，所以asio提出了buffer()函数，该函数接收多种形式的字节流，该函数返回<code>asio::mutable_buffers_1</code>或者<code>asio::const_buffers_1</code>结构的对象。</p>
<p>如果传递给buffer()的参数是一个只读类型，则函数返回<code>asio::const_buffers_1 </code>类型对象。</p>
<p>如果传递给buffer()的参数是一个可写类型，则返回<code>asio::mutable_buffers_1 </code>类型对象。</p>
<p><code>asio::const_buffers_1</code>和<code>asio::mutable_buffers_1</code>是<code>asio::mutable_buffer</code>和<code>asio::const_buffer</code>的适配器，提供了符合<code>MutableBufferSequence</code>和<code>ConstBufferSequence</code>概念的接口，所以他们可以作为boost::asio的api函数的参数使用。</p>
<p>总的来说，我们可以用buffer()函数来生成我们要使用的缓存存储数据<br>比如boost的发送接口send要求的参数为<code>ConstBufferSequence</code>类型</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ConstBufferSequence&gt;</span></span><br><span class="line"><span class="function">std::<span class="type">size_t</span> <span class="title">send</span><span class="params">(<span class="type">const</span> ConstBufferSequence &amp;buffers)</span></span>;</span><br></pre></td></tr></table></figure></div>

<p>将”Hello World”转换成这种类型</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_const_buffer</span><span class="params">()</span> </span>{</span><br><span class="line">    std::string buf = <span class="string">"Hello World"</span>;</span><br><span class="line">    boost::<span class="function">asio::const_buffer <span class="title">asio_buf</span><span class="params">(buf.c_str(), buf.length())</span></span>;</span><br><span class="line">    std::vector&lt;boost::asio::const_buffer&gt; buffers;</span><br><span class="line">    buffers.<span class="built_in">push_back</span>(asio_buf);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>现在buffers就是可以传递给接口send的类型，但是这样太复杂了，可以直接使用buffer函数转为为send所需要的类型</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_buffer_str</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">asio::const_buffer <span class="title">asio_buf</span><span class="params">(<span class="string">"Hello World"</span>)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>asio_buf可以直接传递给send接口。也可以将数组转化为send接受的类型</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_buffer_array</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> BUF_SIZE = <span class="number">20</span>;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="type">char</span>[]&gt; <span class="title">buf</span><span class="params">(<span class="keyword">new</span> <span class="type">char</span>[BUF_SIZE])</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> input_buf = boost::asio::<span class="built_in">buffer</span>(<span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(buf.<span class="built_in">get</span>()), BUF_SIZE);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>对于流式操作，可以用<code>streambuf</code>，将输入输出流和<code>streambuf</code>组合起来，可以实现流式输入和输出</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_stream_buffer</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 创建一个 asio::streambuf 对象来存储和处理流操作。</span></span><br><span class="line">    asio::streambuf buf;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将 std::ostream 与作为参数传递给 `operator&lt;&lt;` 的 streambuf 关联起来，用于写入数据。</span></span><br><span class="line">    <span class="function">std::ostream <span class="title">output</span><span class="params">(&amp;buf)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 向输出流中写入两条消息，并以换行符分隔。</span></span><br><span class="line">    output &lt;&lt; <span class="string">"Message1\n"</span>;</span><br><span class="line">    output &lt;&lt; <span class="string">"Message2"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个 std::istream 与 streambuf 相关联，以便从其中读取数据。</span></span><br><span class="line">    <span class="comment">// 注意：这里传递的 `&amp;buf` 实际上是作为 `std::streambuf*` 的指针，而不是 `asio::streambuf` 类型。这是一个小错误示例代码中的注释可能未能正确地指出这一点。</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">std::istream <span class="title">input</span><span class="params">(&amp;buf)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义一个字符串变量用于存储读取的数据，并使用 getline() 函数从输入流中读取数据直到遇到换行符 '\n'。</span></span><br><span class="line">    std::string message1;</span><br><span class="line">    std::<span class="built_in">getline</span>(input, message1);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 现在，`message1` 变量将包含读取的 "Message1" 字符串（因为 getline() 函数停止在遇到下一个换行符之前）。</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>网络编程</tag>
        <tag>socket</tag>
        <tag>计算机网络</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenWrt TCP UDP 网络性能优化</title>
    <url>/2024/03/24/network-optimization/</url>
    <content><![CDATA[<p>写这篇文章的原因是今天在打2042的时候丢包严重，一开始以为是Dice的服务器又爆了，后面跟同学对比了之后发现完全是路由器的问题。<br>刚好拨号和主路由用的是R2S，可以学习一下linux内核的一些跟<code>TCP, UDP</code>有关的参数修改</p>
<blockquote>
<p>下面的参数可以在<code>/etc/sysctl.conf</code>这个文件中修改</p>
</blockquote>
<p>另外再多说一句，<code>Turbo acc</code>这个插件对这种500M一下的带宽基本没什么作用</p>
<h1 id="最大队列大小优化"><a href="#最大队列大小优化" class="headerlink" title="最大队列大小优化"></a>最大队列大小优化</h1><p>在通过<code>TCP\UDP</code>层处理数据之前，系统会将数据放入内核队列中。<code>net.core.netdev_max_backlog</code>值指定在传递到上层之前要放入队列的最大数据包数。对于高负载的网络，默认值是不够的.因此，我们可以适当地增加该值可以解决内核导致的性能损失。默认值为1000，将其增加到3000以上足以阻止数据包在10Gbps网络中被丢弃</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认值</span></span><br><span class="line">$ sysctl net.core.netdev_max_backlog</span><br><span class="line">sysctl net.core.netdev_max_backlog = 1000</span><br><span class="line"></span><br><span class="line">net.core.netdev_max_backlog = 4096</span><br></pre></td></tr></table></figure></div>

<p>还有一个类似的设置是<code>net.ipv4.tcp_max_syn_backlog</code>，这个指定的是记住的连接请求的最大数量，但仍未受到来自客户端的确认。对于内存超过128MB的系统，默认值为1024，对于低内存计算机，默认值为128。如果服务器过载，可以尝试增加该值</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认值</span></span><br><span class="line">$ sysctl net.ipv4.tcp_max_syn_backlog</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 128</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 4096</span><br></pre></td></tr></table></figure></div>

<h1 id="最大挂起连接数优化"><a href="#最大挂起连接数优化" class="headerlink" title="最大挂起连接数优化"></a>最大挂起连接数优化</h1><p>应用程序可以在处理一个连接之前指定要放入队列的最大待处理请求数，当此值达到最大值时，进一步的连接开始退出。对于发布大量连接的Web服务器等应用程序，此值必须很高才能使这些连接正常工作</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 默认值</span><br><span class="line">$ sysctl net.core.somaxconn</span><br><span class="line">net.core.somaxconn = 128</span><br><span class="line"></span><br><span class="line">net.core.somaxconn = 4096</span><br></pre></td></tr></table></figure></div>

<h1 id="TCP-FIN超时优化"><a href="#TCP-FIN超时优化" class="headerlink" title="TCP FIN超时优化"></a>TCP FIN超时优化</h1><p>在TCP连接中，双方必须独立关闭连接。在Linux下，发送FIN数据包以关闭连接并等待<code>FINACK</code>知道定义超时值。这玩意的默认值是60，可以减少到20或者30使TCP关闭连接并释放资源以进行另一个连接</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ sysctl net.ipv4.tcp_fin_timeout</span><br><span class="line">sysctl net.ipv4.tcp_fin_timeout = 60</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_fin_timeout = 30</span><br></pre></td></tr></table></figure></div>

<h1 id="重用TIME-WAIT状态的套接字进行新连接"><a href="#重用TIME-WAIT状态的套接字进行新连接" class="headerlink" title="重用TIME_WAIT状态的套接字进行新连接"></a>重用TIME_WAIT状态的套接字进行新连接</h1><p>在处理必须处理<code>TIME_WAIT</code>状态下的许多短<code>TCP</code>连接的Web服务器时，或许会有用</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sysctl net.ipv4.tcp_tw_reuse</span><br><span class="line">net.ipv4.tcp_tw_reuse = 0</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br></pre></td></tr></table></figure></div>

<h1 id="tcp-keepalive-time优化"><a href="#tcp-keepalive-time优化" class="headerlink" title="tcp_keepalive_time优化"></a>tcp_keepalive_time优化</h1><p>TCP连接是由两个socket组成，每个socket在连接的两端。当一方想要终止连接时，它会发送另一方确认的<code>RST</code>数据包并关闭其socket</p>
<p>然而，在此之前，双方将无期限地sochi其socket开放。这使得一方可能有意或者由于某些错误而关闭其插座，而无需通过<code>RST</code>通知另一端。为了检测此场景并关闭过时连接，可以使用<code>TCP Keep Alive</code>处理</p>
<p>Linux中有三个可配置属性来确定<code>Keep-Alives</code>的属性:</p>
<ul>
<li>tcp_keepalive_time 默认是7200</li>
<li>tcp_keepalive_probes 默认是9</li>
<li>tcp_keepalive_intvl 默认是75</li>
</ul>
<p>具体过程如下:</p>
<ol>
<li>客户端打开TCP连接</li>
<li>如果<code>tcp_keepalive_time</code>秒的连接是静默的，则发送一个空的<code>ACK</code>数据包</li>
<li>服务器是否使用自己的相应的<code>ACK</code>进行响应<ul>
<li>没有<ul>
<li>等待tcp_keepalive_intvl秒，然后发送另一个<code>ACK</code></li>
<li>重复，直到已发送的<code>ACk</code>探测数等于<code>tcp_keepalive_probes</code></li>
<li>如果此时未收到响应，请发送<code>RST</code>并终止连接</li>
</ul>
</li>
<li>有<ul>
<li>返回第二步</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>默认情况下，在大多数操作系统上启动了此过程的处理，因此一旦另一端无响应2小时11分钟( 7200s + 75 * 9 ), 则会定期移除死TCP连接</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ sysctl net.ipv4.tcp_keepalive_time</span><br><span class="line">net.ipv4.tcp_keepalive_time = 7200</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_keepalive_time = 1200</span><br></pre></td></tr></table></figure></div>

<h1 id="启用智能MTU黑同检测优化"><a href="#启用智能MTU黑同检测优化" class="headerlink" title="启用智能MTU黑同检测优化"></a>启用智能MTU黑同检测优化</h1><p>一旦启用，系统将尝试使用路径MTU发现机制在客户端和服务器之间找到MTU，可以通过<code>ip a</code>检查接口上的MTU:</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ ip a | grep <span class="string">&#x27;mtu&#x27;</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000</span><br><span class="line">3: ip6tnl0@NONE: &lt;NOARP&gt; mtu 1452 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">4: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel master br-lan state UP group default qlen 1000</span><br><span class="line">5: br-lan: &lt;BROADCAST,MULTICAST,PROMISC,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000</span><br><span class="line">6: pppoe-wan: &lt;POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP&gt; mtu 1492 qdisc fq_codel state UNKNOWN group default qlen 3</span><br></pre></td></tr></table></figure></div>

<p><a class="link"   href="https://zhuanlan.zhihu.com/p/360516704" >关于MTU <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>要在Linux上启用此功能，运行下面的命令：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ sysctl net.ipv4.tcp_mtu_probing</span><br><span class="line">net.ipv4.tcp_mtu_probing = 0</span><br><span class="line">$ sysctl net.ipv4.tcp_base_mss</span><br><span class="line">net.ipv4.tcp_base_mss = 1024</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_mtu_probing = 1</span><br></pre></td></tr></table></figure></div>

<p><code>tcp_mtu_probing</code>，控制TCP分组化-层路径MTU发现，有三个可选值：</p>
<ul>
<li>0 已禁用</li>
<li>1 默认情况下禁用，在检测到ICMP黑洞时起用</li>
<li>2 始终启用，使用<code>tcp_base_mss</code>的初始MSS</li>
</ul>
<h1 id="内核缓冲区优化"><a href="#内核缓冲区优化" class="headerlink" title="内核缓冲区优化"></a>内核缓冲区优化</h1><p>系统默认的socket缓冲区大小:</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ sysctl net.core.wmem_default</span><br><span class="line">net.core.wmem_default = 212992</span><br><span class="line">$ sysctl net.core.rmem_default</span><br><span class="line">net.core.rmem_default = 212992</span><br><span class="line">$ sysctl net.core.rmem_max</span><br><span class="line">sysctl net.core.rmem_max = 212992</span><br><span class="line">$ sysctl net.core.wmem_max</span><br><span class="line">net.core.wmem_max = 212992</span><br></pre></td></tr></table></figure></div>

<p>这些参数显示分配给任何类型连接的默认和最大写入、读取缓冲区大小。 由于分配的空间来自RAM，因此默认值设置总是有点低。增加这一点可能会提高运行NFS等服务器的系统的性能。 将它们增加到256k &#x2F; 4MB将最有效，否则您必须对这些值进行基准测试，以找到系统配置的理想值</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 256 KB / 4 MB</span></span><br><span class="line">net.core.rmem_default = 262144</span><br><span class="line">net.core.wmem_default = 262144</span><br><span class="line">net.core.rmem_max = 4194304</span><br><span class="line">net.core.wmem_max = 4194304</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Or 256 Kb / 64 MB</span></span><br><span class="line">net.core.rmem_default = 262144</span><br><span class="line">net.core.wmem_default = 262144</span><br><span class="line">net.core.rmem_max = 67108864</span><br><span class="line">net.core.wmem_max = 67108864</span><br></pre></td></tr></table></figure></div>

<h1 id="TCP缓冲区大小优化"><a href="#TCP缓冲区大小优化" class="headerlink" title="TCP缓冲区大小优化"></a>TCP缓冲区大小优化</h1><p>确认一下默认值:</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ sysctl net.ipv4.tcp_rmem</span><br><span class="line">net.ipv4.tcp_rmem = 4096        131072   6291456</span><br><span class="line">$ sysctl net.ipv4.tcp_wmem</span><br><span class="line">net.ipv4.tcp_wmem = 4096        16384   4194304</span><br></pre></td></tr></table></figure></div>

<p>这些值是三个整数的数组，分别指定TCP读取和发送缓冲区的最小，平均和最大值</p>
<blockquote>
<p> [!WARNING]<br> 值要以页为单位。如果需要查看页面大小，可以使用<code>getconf PAGE_SIZE</code>来查看</p>
</blockquote>
<p>TCP缓冲区最大值修改：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 64MB</span></span><br><span class="line">net.ipv4.tcp_rmem = 4096 87380 67108864</span><br><span class="line">net.ipv4.tcp_wmem = 4096 16384 67108864</span><br><span class="line"></span><br><span class="line"><span class="comment"># 12MB:</span></span><br><span class="line">net.ipv4.tcp_rmem = 4096 87380 12582912</span><br><span class="line">net.ipv4.tcp_wmem = 4096 16384 12582912</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4MB:</span></span><br><span class="line">net.ipv4.tcp_rmem = 4096 87380 4194304</span><br><span class="line">net.ipv4.tcp_wmem = 4096 16384 4194304</span><br></pre></td></tr></table></figure></div>

<h1 id="Time-Wait优化"><a href="#Time-Wait优化" class="headerlink" title="Time Wait优化"></a>Time Wait优化</h1><p><code>TIME WAIT TCP</code>套接字状态是套接字关闭但等待处理仍在网络中的数据包的状态。 参数tcp_max_tw_buckets是 TIME_WAIT 状态下的最大套接字数。 达到此数字后，系统将开始在此状态下销毁套接字</p>
<p>此限制仅用于防止简单的DoS攻击，您不得人为地降低限制，而是增加它（可能在增加安装的内存之后），如果网络条件需要超过默认值</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ sysctl net.ipv4.tcp_max_tw_buckets</span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 4096</span><br><span class="line"></span><br><span class="line">$ sudo vi /etc/sysctl.d/98-network-custom.conf</span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 5000</span><br></pre></td></tr></table></figure></div>

<p>如果遇到大量的TCP 错误，如：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">__ratelimit: 33491 callbacks suppressed</span><br><span class="line">TCP: time <span class="built_in">wait</span> bucket table overflow</span><br></pre></td></tr></table></figure></div>

<p>可以增加<code>net.ipv4.tcp_max_tw_buckets</code>的值，比如 654320，前提是拥有足够的内存</p>
<p>请尝试以下命令来确定您是否有来自一个地址的大量连接，或者您是否受到分布式攻击</p>
<p><code>netstat -nt | cut -c 40- | cut -d: -f1 | sort | uniq -c | sort -n netstat -nt | cut -d: -f2 | sort | uniq -c | sort -n</code></p>
<p>如果您从几个IP地址获得高数字，则更容易限制连接。 然后，您可以向 iptables 添加拒绝规则或速率限制规则，以限制从这些地址访问</p>
<p>经测试，优化此项可能造成上传文件至某些网站超时或错误</p>
<h1 id="开启TCP时间戳"><a href="#开启TCP时间戳" class="headerlink" title="开启TCP时间戳"></a>开启TCP时间戳</h1><p>关于<a class="link"   href="https://zhuanlan.zhihu.com/p/612010050" >tcp_timestamps <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>Linux 系统中的 tcp_timestamps 参数控制是否启用 TCP 时间戳。要启用该功能可以用下面的命令：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">net.ipv4.tcp_timestamps=1</span><br></pre></td></tr></table></figure></div>

<p>通常，出于性能考虑，默认情况下，在现代操作系统上该参数会启用，除非有特定安全上的考虑需要关闭它。在某些情况下，为了提高安全性，可能会选择关闭时间戳功能，因为时间戳可以被恶意用户用来估算服务上次重启的时间，或者进行更精细的网络流量分析。</p>
<h1 id="TCP-Sack"><a href="#TCP-Sack" class="headerlink" title="TCP Sack"></a>TCP Sack</h1><p><code>tcp_sack</code> 表示 TCP Selective Acknowledgment (选择性确认)，这是一个 TCP&#x2F;IP 的性能优化特性。在 TCP 通信中，数据是按顺序发送的，如果包丢失了，底层 TCP 协议需要进行重传。传统的 TCP 重传机制是累积确认的，也就是说，只有当所有的包按顺序全部接收时，接收端才会发送一个 ACK (确认)。<br>选择性确认允许接收方告诉发送方哪些数据包已经成功接收，即使它们不是按顺序到达的。这样，如果一些数据包丢失，发送方可以只重传那些未被确认接收的数据包，而不用从丢失的数据包或者先前已经被确认接收的部分开始重传整个数据流。这可以大大提高网络通信的效率，尤其是在丢包率较高或者网络延迟较大的环境下。</p>
<p>要启用该功能:</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">net.ipv4.tcp.sack = 1</span><br></pre></td></tr></table></figure></div>


<h1 id="TCP窗口大小"><a href="#TCP窗口大小" class="headerlink" title="TCP窗口大小"></a>TCP窗口大小</h1><p><code>tcp_window_scaling</code> 是 TCP 协议提供的一个特性，用于支持较大的窗口大小，从而使得在高延迟和高带宽的网络上可以有更好的性能。在TCP中，窗口大小决定了不需要等待确认应答就可以发送的数据的最大值。这个值也就是说，在任一时刻，可以无确认地发送在网络上未确认的数据的最大量。<br>正常情况下，TCP 窗口的大小由一个 16 位的字段控制，这限制了最大的窗口大小为 65,535 字节（64 KB）。随着网络的发展，这个大小变得不足以利用高速网络的潜力。通过启用窗口缩放选项，TCP 可以使用最多 14 位的移位计数来扩大这个值，从而扩大可能的窗口大小，最大可达 1GB。</p>
<p>要启用该功能:</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">net.ipv4.tcp_window_scaling = 1</span><br></pre></td></tr></table></figure></div>

<p>禁用 tcp_window_scaling 会限制 TCP 窗口的最大值为 64 KB，这可能会降低网络性能，尤其是在高速宽带连接上。因此，在不需要兼容老旧网络设备或特定网络配置的情况下，建议保持该选项为启用状态，以便能够充分利用网络带宽。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>Linux</tag>
        <tag>软路由</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统笔记01</title>
    <url>/2024/07/02/operating-system-1/</url>
    <content><![CDATA[<h1 id="操作系统的概念、功能、目标"><a href="#操作系统的概念、功能、目标" class="headerlink" title="操作系统的概念、功能、目标"></a>操作系统的概念、功能、目标</h1><p>作为用户和计算机硬件之间的接口</p>
<ul>
<li><p>提供的功能：</p>
<ul>
<li>命令接口：<ul>
<li>联机命令接口(输入一次，输出一次)</li>
<li>脱机命令接口(批处理命令)</li>
</ul>
</li>
<li>程序接口：<ul>
<li>提供系统调用(广义指令)</li>
</ul>
</li>
</ul>
</li>
<li><p>目标： 方便用户使用</p>
</li>
</ul>
<h2 id="关于库函数和系统调用的区别"><a href="#关于库函数和系统调用的区别" class="headerlink" title="关于库函数和系统调用的区别"></a>关于库函数和系统调用的区别</h2><ul>
<li>库函数是语言或应用程序的一部分，可以运行在运行在用户空间中</li>
<li>系统调用是操作系统的一部分，是内核为用户提供的程序接口，运行在内核空间中，并且许多库函数都是用系统调用来实现功能</li>
</ul>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>未使用系统调用的库函数，其执行效率通常要比系统调用的高。因为使用系统调用时，需要上下文的切换及状态转换(由用户态转向核心态)</p>
<h1 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h1><h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><p>并发: 是指两个或多个时间在统一时间间隔发生(宏观同时发生，微观交替发生)</p>
<p>并行: 是指在同一时刻能同时完成两种或两种以上的工作</p>
<h2 id="互斥和共享"><a href="#互斥和共享" class="headerlink" title="互斥和共享"></a>互斥和共享</h2><p>互斥: 在一段时间内只允许一个进程访问资源(例如写入操作)</p>
<p>共享: 在一段时间内允许多个进程访问资源(例如读取操作)</p>
<h2 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h2><p>是指将一个物理上的实体变为若干逻辑上的对应物(例如虚拟机)</p>
<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停的，以不可预知的速度向前推进。只有系统拥有并发性，才有可能导致异步性。(例如C++的<code>async</code>，开辟一个一次性的线程执行并行任务，主线程可以通过<code>future</code>在合适的时机执行等待汇总结果。)</p>
<h1 id="操作系统的发展与分类"><a href="#操作系统的发展与分类" class="headerlink" title="操作系统的发展与分类"></a>操作系统的发展与分类</h1><h2 id="手工操作阶段"><a href="#手工操作阶段" class="headerlink" title="手工操作阶段"></a>手工操作阶段</h2><ul>
<li>纸带机(用户独占全机，人机速度矛盾)<ul>
<li>缺点： 用户独占全机，CPU需要等待人工操作，人机速度矛盾，资源利用率低</li>
</ul>
</li>
</ul>
<h2 id="批处理阶段"><a href="#批处理阶段" class="headerlink" title="批处理阶段"></a>批处理阶段</h2><ul>
<li><p>单道批处理阶段(外围及–磁带)</p>
<ul>
<li>优点：解决了人机矛盾和CPU与I&#x2F;O设备速度不匹配问题</li>
<li>缺点： 每次只能运行一道程序，不能充分地利用系统资源</li>
</ul>
</li>
<li><p>多道批处理系统(操作系统开始出现)</p>
</li>
</ul>
<h2 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h2><ul>
<li>轮流处理作业</li>
<li>不能处理紧急任务</li>
</ul>
<h2 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h2><ul>
<li>优先处理紧急任务</li>
<li>硬实时系统: 必须在严格的时间内完成处理</li>
<li>软实时系统: 可以偶尔犯错</li>
</ul>
<h2 id="网络操作系统"><a href="#网络操作系统" class="headerlink" title="网络操作系统"></a>网络操作系统</h2><h2 id="分布式操作系统"><a href="#分布式操作系统" class="headerlink" title="分布式操作系统"></a>分布式操作系统</h2><h2 id="个人计算机操作系统"><a href="#个人计算机操作系统" class="headerlink" title="个人计算机操作系统"></a>个人计算机操作系统</h2><h1 id="操作系统的运行环境"><a href="#操作系统的运行环境" class="headerlink" title="操作系统的运行环境"></a>操作系统的运行环境</h1><h2 id="处理器运行模式"><a href="#处理器运行模式" class="headerlink" title="处理器运行模式"></a>处理器运行模式</h2><ul>
<li>内核态&#x2F;核心态&#x2F;管态</li>
<li>用户态&#x2F;目态</li>
</ul>
<h2 id="程序的运行原理"><a href="#程序的运行原理" class="headerlink" title="程序的运行原理:"></a>程序的运行原理:</h2><ul>
<li>高级语言编写代码–&gt;机器指令</li>
<li>程序运行的过程就是CPU执行指令的效果</li>
</ul>
<h2 id="两类程序"><a href="#两类程序" class="headerlink" title="两类程序"></a>两类程序</h2><ul>
<li>内核程序</li>
<li>应用程序</li>
</ul>
<h2 id="两类指令"><a href="#两类指令" class="headerlink" title="两类指令"></a>两类指令</h2><ul>
<li><p>特权指令: 是指用户不允许直接使用的指令</p>
<ul>
<li>I&#x2F;O指令</li>
<li>关中断指令</li>
<li>内存清零指令</li>
<li>存取用于内存保护的级存器</li>
<li>送PSW到程序状态字寄存器的指令</li>
</ul>
</li>
<li><p>非特权指令: 是指允许用户直接使用的指令</p>
<ul>
<li>无法直接访问系统中的软硬资源</li>
<li>仅限于用户的地址空间</li>
</ul>
</li>
</ul>
<h2 id="内核-kernel"><a href="#内核-kernel" class="headerlink" title="内核(kernel)"></a>内核(kernel)</h2><ul>
<li>内核是操作系统最重要最核心的部分</li>
<li>有很多内核程序组成操作系统内核</li>
</ul>
<h2 id="如何改变状态"><a href="#如何改变状态" class="headerlink" title="如何改变状态"></a>如何改变状态</h2><ul>
<li>内核态-&gt;用户态: 一条修改PSW的特权指令</li>
<li>用户态-&gt;内核态: 由中断引起，硬件自动完成</li>
</ul>
<h2 id="中断和异常的概念"><a href="#中断和异常的概念" class="headerlink" title="中断和异常的概念"></a>中断和异常的概念</h2><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><ul>
<li><p>定义: 是指来自CPU执行指令外部的时间，通常用于信息输入&#x2F;输出。</p>
<ul>
<li>时钟中断</li>
<li>I&#x2F;O中断请求</li>
</ul>
</li>
<li><p>分类:</p>
<ul>
<li>可屏蔽中断: 通过INTR线发出的中断请求，通过改变屏蔽字可以实现多重中断</li>
<li>不可屏蔽中断: 通过NMI线发出的中断请求，通常是紧急的硬件故障</li>
</ul>
</li>
</ul>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><ul>
<li><p>定义: 是指来自CPU执行指令内部的时间，例如程序的非法操作码、地址越界、运算溢出、虚存系统的缺页及专门的陷入指令等引起的事件</p>
</li>
<li><p>分类:</p>
<ul>
<li>故障: 由指令执行引起的异常 (软件中断)</li>
<li>自陷: 是一种事先安排的“异常”事件，用于在用户态下调用操作系统内核程序 (软件中断)</li>
<li>终止: 出现了使得CPU无法继续执行的硬件故障 (硬件中断)</li>
</ul>
</li>
</ul>
<h3 id="中断机制的基本实现原理"><a href="#中断机制的基本实现原理" class="headerlink" title="中断机制的基本实现原理"></a>中断机制的基本实现原理</h3><ul>
<li>检查中断信号<ul>
<li>内中断: CPU在执行指令时会检查是否会有异常发生</li>
<li>外中断: 每个指令周期末尾，CPU都会检查是否由外中断信号需要处理</li>
</ul>
</li>
<li>找到相应的中断处理程序<ul>
<li>通过“中断向量表”实现</li>
</ul>
</li>
</ul>
<h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><p>凡是与资源有关的操作，都必须通过系统调用方式向操作系统提出服务请求，并有操作系统代为完成</p>
<ul>
<li>设备管理: 完成设备的请求或释放，以及设备的启动等功能</li>
<li>文件管理: 完成文件的读、写、创建、删除等功能</li>
<li>进程控制: 完成进程的创建、撤销、阻塞、唤醒等功能</li>
<li>进程通信: 完成进程之间的消息传递或信号传递</li>
<li>内存管理: 完成内存分配、回收及获取作业占用内存区大小和起始地址等功能</li>
</ul>
<h2 id="系统调用的过程"><a href="#系统调用的过程" class="headerlink" title="系统调用的过程"></a>系统调用的过程</h2><ul>
<li>传参</li>
<li>陷入指令&#x2F;Trap&#x2F;访管</li>
<li>由操作系统内核程序处理系统调用请求</li>
<li>返回应用程序</li>
</ul>
<h1 id="操作系统的运行机制和体系结构"><a href="#操作系统的运行机制和体系结构" class="headerlink" title="操作系统的运行机制和体系结构"></a>操作系统的运行机制和体系结构</h1><h2 id="分层结构"><a href="#分层结构" class="headerlink" title="分层结构"></a>分层结构</h2><p>内核分多层，每层可以单项调用更低一层提供的接口</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/07/02/mL1RC7zY48ht53n.png"
                      alt="分层结构.png"
                ></p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h3><ul>
<li><code>便于系统的调试和验证，自底向上逐层调试验证，简化了系统设计和实现</code></li>
<li>易扩充和易维护，各层之间调用接口清晰固定</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点:"></a>缺点:</h3><ul>
<li>合理定义各层关系比较困难，仅可调用相邻底层，难以合理定义各层的边界</li>
<li><code>效率较差，不可跨层调用，系统调用执行时间长</code></li>
</ul>
<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>将内核划分为多个模块，各模块之间相互协作</p>
<p>内核 &#x3D; 主模块+可加载内核模块</p>
<p><code>主模块: 只负责核心功能，如进程调度、内存管理</code><br>可加载内核模块: 可以动态加载新模块到内核，而无需重新编译整个内核</p>
<pre class="mermaid">flowchart TD
    操作系统 ---|模块| 进程管理
    操作系统 --- 存储器管理
    操作系统 --- 文件管理
    进程管理 ---|子模块| 进程控制
    进程管理 --- 进程调度
    存储器管理 --- 内存分配
    存储器管理 --- 内存保护
    文件管理 --- 磁盘管理
    文件管理 --- 目录管理</pre>

<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点:"></a>优点:</h3><ul>
<li>模块间逻辑清晰易于维护，确定模块间接口后即可多模块同时开发</li>
<li><code>支持动态加载新的内核模块(安装设备驱动、安装新的文件系统模块到内核)，增强OS的适应性</code></li>
<li><code>任何模块都可以直接调用其他模块，无需采用消息传递进行通信，效率高</code></li>
</ul>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点:"></a>缺点:</h3><ul>
<li>模块间的接口定义未必合理、使用</li>
<li>模块间相互以来，更难调试和验证</li>
</ul>
<h2 id="宏内核"><a href="#宏内核" class="headerlink" title="宏内核"></a>宏内核</h2><p>所有的系统功能都放在内核里（大内核结构的OS通常也采用了“模块的”的设计思想）<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/07/02/RFZijhTr3QHbgNc.png"
                      alt="宏内核.png"
                ></p>
<h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点:"></a>优点:</h3><ul>
<li>性能高，内核内部各种功能都可以直接相互调用</li>
</ul>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点:"></a>缺点:</h3><ul>
<li>内核庞大功能复杂，难以维护</li>
<li>大内核中某个功能模块出错，就可能导致整个系统崩溃</li>
</ul>
<h2 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h2><p>只把中断、原语、进程通信等最核心的功能放入内核。进程管理、文件管理、设备管理等功能以用户进程的形式运行在用户态</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/07/02/mb9PdlWkDnBUqX7.png"
                      alt="微内核.png"
                ></p>
<h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点:"></a>优点:</h3><ul>
<li>内核小功能少、易于维护，内核可靠性高</li>
<li>内核外的某个功能模块出错不会导致整个系统的崩溃</li>
</ul>
<h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点:"></a>缺点:</h3><ul>
<li>性能低，需要频繁切换用户态&#x2F;核心态</li>
<li>用户态下的各功能不可以直接相互调用，只能通过内核的“消息传递”来间接通信</li>
</ul>
<h2 id="外核"><a href="#外核" class="headerlink" title="外核"></a>外核</h2><p><code>内核负责进程调度、进程通信等功能。外核负责为用户进程分配未经抽象的硬件资源，且由外核负责保证资源使用安全</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/07/02/adrmtI9E3BoyzTD.png"
                      alt="外核.png"
                ></p>
<h3 id="优点-4"><a href="#优点-4" class="headerlink" title="优点:"></a>优点:</h3><ul>
<li>外核可直接给用户进程分配“不虚拟、不抽象”的硬件资源，使用户进程可以更灵活的使用硬件资源</li>
<li>减少了虚拟硬件资源的“映射层”，提升效率</li>
</ul>
<h3 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点:"></a>缺点:</h3><ul>
<li>降低了系统的一致性</li>
<li>使系统变得更加复杂</li>
</ul>
<h1 id="操作系统引导"><a href="#操作系统引导" class="headerlink" title="操作系统引导"></a>操作系统引导</h1><ol>
<li>激活CPU</li>
<li>硬件自检</li>
<li>加载带有操作系统的硬盘</li>
<li>加载MBR(主引导记录)</li>
<li>扫描硬盘分区表</li>
<li>加载分区引导记录</li>
<li>加载启动管理器</li>
<li>加载操作系统</li>
</ol>
<h1 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h1><p>虚拟机: 使用虚拟化技术，将一台物理机器虚拟化为多台虚拟机起，每个虚拟机起都可以独立运行一个操作系统</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/07/02/IUQ3gmnkH6MdWeD.png"
                      alt="第一类VM.png"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/07/02/Qrv2npeL8uBhCRl.png"
                      alt="第二类VM.png"
                ></p>
<table>
<thead>
<tr>
<th>两类虚拟机管理程序的对比</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>第一类VM</td>
<td>第二类VM</td>
</tr>
<tr>
<td>对物理资源的控制权</td>
<td>直接运行在硬件之上，能直接控制和分配物理资源</td>
<td>运行在<code>HOST OS</code>之上，依赖于<code>HOST OS</code>为其分配物理资源</td>
</tr>
<tr>
<td>资源分配方式</td>
<td>在安装<code>GUEST OS</code>时，VMM要在原本的硬盘上进行分配</td>
<td><code>GUEST OS</code>拥有自己的虚拟硬盘，是<code>HOST OS</code>文件系统中的一个大文件，</td>
</tr>
<tr>
<td>性能</td>
<td>性能更好</td>
<td>性能更差</td>
</tr>
<tr>
<td>可支持的虚拟机数量</td>
<td>更多，不需要和<code>HOST OS</code>竞争资源</td>
<td>更少，<code>HOST OS</code>本身也需要一定的系统资源</td>
</tr>
<tr>
<td>虚拟机的可迁移性</td>
<td>更差</td>
<td>只需要导出镜像文件即可</td>
</tr>
<tr>
<td>运行模式</td>
<td>运行在最高特权级，可以执行最高特权的指令</td>
<td>部分运行在用户态、部分运行在内核态。<code>GUEST OS</code>发出的系统调用会被VMM截获，转换为VMM对<code>HOST OS</code>的系统调用</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>408</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>protobuf的配置和使用</title>
    <url>/2024/08/01/protobuf-configuration/</url>
    <content><![CDATA[<h1 id="protobuf简介"><a href="#protobuf简介" class="headerlink" title="protobuf简介"></a>protobuf简介</h1><p>Protocol Buffers（简称 protobuf）是 Google 开发的一种数据交换格式。它是一种灵活、高效且自动化的结构化数据序列化方法，类似于 XML、JSON 和其他配置文件格式，但更小、更快、更简单。我们的逻辑是有类等抽象数据构成的，而tcp是面向字节流的，我们需要将类结构序列化为字符串来传输。</p>
<p>主要特点：</p>
<ol>
<li>语言无关：protobuf 支持多种编程语言，包括 C++、Java、Python 等，并且可以轻松地在不同语言之间进行通信。</li>
<li>平台无关：可以跨多个平台使用，无论是在 32 位还是 64 位系统上。</li>
<li>效率高：相比于 XML 或 JSON，protobuf 在序列化和反序列化时的性能更好，生成的数据也更紧凑。</li>
</ol>
<h1 id="编译protobuf"><a href="#编译protobuf" class="headerlink" title="编译protobuf"></a>编译protobuf</h1><p>如果是linux系统，可以直接从自己的包管理器下载protobuf</p>
<p>例如<code>archlinux</code></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">yay -S protobuf</span><br></pre></td></tr></table></figure></div>

<p>如果是windows系统，我们需要从<a class="link"   href="https://github.com/protocolbuffers/protobuf/releases" >官网 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>下载源代码进行编译</p>
<p><a class="link"   href="https://blog.csdn.net/weixin_42968757/article/details/120033598" >具体教程 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>当protobuf编译完成后，我们可以通过<code>protobuf --version</code>来检查是否安装成功</p>
<h1 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h1><ul>
<li>定义消息格式：首先需要定义消息的结构，这通常是通过 .proto 文件完成的。这些文件描述了你想要交换的数据的结构。</li>
</ul>
<p>我们先创建一个<code>msg.proto</code>文件，并且写入如下内容</p>
<div class="highlight-container" data-rel="Proto"><figure class="iseeu highlight proto"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">message </span><span class="title class_">Book</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">   <span class="type">int32</span> pages = <span class="number">2</span>;</span><br><span class="line">   <span class="type">float</span> price = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这个文件用来定义我们需要发送的信息</p>
<ul>
<li>编译 .proto 文件：使用 Protocol Buffers 编译器（protoc），根据 .proto 文件生成特定语言的源代码</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">protoc --cpp_out=. ./msg.proto</span><br></pre></td></tr></table></figure></div>

<p>.&#x2F;msg.proto 表示msg.proto所在的位置，因为我们是在msg.proto所在文件夹中执行的protoc命令,所以是当前路径即可。<br>执行后，会看到当前目录生成了msg.pb.h和msg.pb.cc两个文件，这两个文件就是我们要用到的头文件和cpp文件。</p>
<ul>
<li>序列化与反序列化：使用生成的类来创建消息对象，并将这些对象序列化为字节流，或者从字节流中反序列化为对象。</li>
</ul>
<p>这里我们写一个测试函数</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_protobuf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Book book;</span><br><span class="line">    book.<span class="built_in">set_name</span>(<span class="string">&quot;CPP programing&quot;</span>);</span><br><span class="line">    book.<span class="built_in">set_pages</span>(<span class="number">100</span>);</span><br><span class="line">    book.<span class="built_in">set_price</span>(<span class="number">200</span>);</span><br><span class="line">    std::string bookstr;</span><br><span class="line">    book.<span class="built_in">SerializeToString</span>(&amp;bookstr);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;serialize str is &quot;</span> &lt;&lt; bookstr &lt;&lt; std::endl;</span><br><span class="line">    Book book2;</span><br><span class="line">    book2.<span class="built_in">ParseFromString</span>(bookstr);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;book2 name is &quot;</span> &lt;&lt; book2.<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot; price is &quot;</span></span><br><span class="line">        &lt;&lt; book2.<span class="built_in">price</span>() &lt;&lt; <span class="string">&quot; pages is &quot;</span> &lt;&lt; book2.<span class="built_in">pages</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">serialize str is</span><br><span class="line">CPP programingdHC</span><br><span class="line">book2 name is CPP programing price is 200 pages is 100</span><br></pre></td></tr></table></figure></div>

<p>上面的demo中将book对象先序列化为字符串，再将字符串反序列化为book2对象。</p>
<h1 id="在网络中的应用"><a href="#在网络中的应用" class="headerlink" title="在网络中的应用"></a>在网络中的应用</h1><p>先为服务器定义一个用来通信的protobuf</p>
<div class="highlight-container" data-rel="Proto"><figure class="iseeu highlight proto"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">message </span><span class="title class_">MsgData</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int32</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="type">string</span> data = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>id代表消息的编号，data代表消息的内容</p>
<p>接着修改服务器接收和发送数据的逻辑<br>当服务器收到数据并完成切包处理，将信息反序列化为具体要使用的结构，打印相关信息，然后再发送给客户端</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">Data msgdata;</span><br><span class="line">std::string receive_data;</span><br><span class="line">msgdata.<span class="built_in">ParseFromString</span>( std::<span class="built_in">string</span>(</span><br><span class="line">    _recv_msg_node-&gt;_msg, _recv_msg_node-&gt;_total_len ) );</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Recv msg is: &quot;</span> &lt;&lt; msgdata.<span class="built_in">data</span>() &lt;&lt; std::endl;</span><br><span class="line">std::string return_str =</span><br><span class="line">    <span class="string">&quot;server has receive msg, msg data is  &quot;</span> + msgdata.<span class="built_in">data</span>();</span><br><span class="line">Data msgreturn;</span><br><span class="line">msgreturn.<span class="built_in">set_id</span>( msgdata.<span class="built_in">id</span>() );</span><br><span class="line">msgreturn.<span class="built_in">set_data</span>( msgdata.<span class="built_in">data</span>() );</span><br><span class="line">msgreturn.<span class="built_in">SerializeToString</span>( &amp;return_str );</span><br><span class="line"><span class="built_in">Send</span>( return_str );</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>同样，客户端在发送的时候也利用protobu进行消息序列化，然后发送给服务器</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">Data msgdata;</span><br><span class="line">msgdata.<span class="built_in">set_id</span>( <span class="number">1001</span> );</span><br><span class="line">msgdata.<span class="built_in">set_data</span>( <span class="string">&quot;Hello world!&quot;</span> );</span><br><span class="line">std::string request;</span><br><span class="line">msgdata.<span class="built_in">SerializeToString</span>( &amp;request );</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;message id: &quot;</span> &lt;&lt; msgdata.<span class="built_in">id</span>()</span><br><span class="line">          &lt;&lt; <span class="string">&quot; content: &quot;</span> &lt;&lt; msgdata.<span class="built_in">data</span>() &lt;&lt; std::endl;</span><br><span class="line">boost::asio::<span class="built_in">write</span>(</span><br><span class="line">    sock, boost::asio::<span class="built_in">buffer</span>( request, request.<span class="built_in">length</span>() ) );</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h1 id="关于protbuf在CMake中的配置"><a href="#关于protbuf在CMake中的配置" class="headerlink" title="关于protbuf在CMake中的配置"></a>关于protbuf在CMake中的配置</h1><blockquote>
<p>注意一定要在编译参数中加入<code>-Wl,--copy-dt-needed-entries</code>，否则会报<a class="link"   href="https://linuxpip.org/how-to-fix-dso-missing-from-command-line" >DSO missing <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<div class="highlight-container" data-rel="Cmake"><figure class="iseeu highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS</span><br><span class="line">    <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -g -O2  -Wall -Wextra -Weffc++ -Werror=uninitialized  -Werror=return-type -Wconversion -Wsign-compare -Werror=unused-result -Werror=suggest-override -Wzero-as-null-pointer-constant -Wmissing-declarations -Wold-style-cast -Wnon-virtual-dtor -Wl,--copy-dt-needed-entries&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>关于对proto文件的配置，可以参考这个</p>
<div class="highlight-container" data-rel="Cmake"><figure class="iseeu highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取编译器</span></span><br><span class="line"><span class="keyword">find_program</span>(</span><br><span class="line">    PROTOC_CXX</span><br><span class="line">    protoc</span><br><span class="line">    DOC <span class="string">&quot;Protobuf Compiler (protoc)&quot;</span></span><br><span class="line">    REQUIRED</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要编译的 proto 文件</span></span><br><span class="line"><span class="keyword">file</span> (GLOB PROTO_SOURCE_FILES</span><br><span class="line">    <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/*.proto&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(PROTO_PATH    <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(PROTO_CXX_OUT <span class="string">&quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/gen_cxx&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">file</span>(<span class="keyword">MAKE_DIRECTORY</span> <span class="variable">$&#123;PROTO_CXX_OUT&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 protoc 处理 proto 文件</span></span><br><span class="line"><span class="keyword">foreach</span>(input_proto <span class="variable">$&#123;PROTO_SOURCE_FILES&#125;</span>)</span><br><span class="line">    <span class="keyword">get_filename_component</span>(DIR <span class="variable">$&#123;input_proto&#125;</span> DIRECTORY)</span><br><span class="line">    <span class="keyword">get_filename_component</span>(FILE_NAME <span class="variable">$&#123;input_proto&#125;</span> NAME_WE)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span>(OUTPUT_CXX_HEADER   <span class="string">&quot;$&#123;PROTO_CXX_OUT&#125;/$&#123;FILE_NAME&#125;.pb.h&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(OUTPUT_CXX_SOURCE   <span class="string">&quot;$&#123;PROTO_CXX_OUT&#125;/$&#123;FILE_NAME&#125;.pb.cc&quot;</span>)</span><br><span class="line">    <span class="keyword">list</span>(APPEND OUTPUT_SOURCES_CXX</span><br><span class="line">        <span class="variable">$&#123;OUTPUT_CXX_HEADER&#125;</span> <span class="variable">$&#123;OUTPUT_CXX_SOURCE&#125;</span>)</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_custom_command</span>(</span><br><span class="line">    OUTPUT  <span class="variable">$&#123;OUTPUT_SOURCES_CXX&#125;</span></span><br><span class="line">    <span class="keyword">COMMAND</span> <span class="variable">$&#123;PROTOC_CXX&#125;</span> --cpp_out=<span class="variable">$&#123;PROTO_CXX_OUT&#125;</span> --proto_path=<span class="variable">$&#123;PROTO_PATH&#125;</span> <span class="variable">$&#123;PROTO_SOURCE_FILES&#125;</span></span><br><span class="line">    DEPENDS <span class="variable">$&#123;PROTO_SOURCE_FILES&#125;</span></span><br><span class="line">    WORKING_DIRECTORY <span class="variable">$&#123;PROTO_PATH&#125;</span></span><br><span class="line">    COMMENT <span class="string">&quot;Generate Cpp Protobuf Source Files&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_custom_target</span>(</span><br><span class="line">    compile_cxx_protos</span><br><span class="line">    DEPENDS <span class="variable">$&#123;OUTPUT_SOURCES_CXX&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置生成源文件包含目录变量供上层引用</span></span><br><span class="line"><span class="keyword">set</span>(PROTO_GEN_CXX_INCLUDE_DIRS <span class="variable">$&#123;PROTO_CXX_OUT&#125;</span> PARENT_SCOPE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将生成的文件打包为库 proto_gen_cxx</span></span><br><span class="line"><span class="comment"># 程序可以链接到该库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(proto_gen_cxx <span class="variable">$&#123;OUTPUT_SOURCES_CXX&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(proto_gen_cxx protobuf)</span><br><span class="line"><span class="keyword">add_dependencies</span>(proto_gen_cxx compile_cxx_protos)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>网络编程</tag>
        <tag>socket</tag>
        <tag>计算机网络</tag>
        <tag>Linux</tag>
        <tag>protobuf</tag>
      </tags>
  </entry>
  <entry>
    <title>python-grammar-1</title>
    <url>/2024/05/02/python-grammar-1/</url>
    <content><![CDATA[<h1 id="Python-数据类型"><a href="#Python-数据类型" class="headerlink" title="Python 数据类型"></a>Python 数据类型</h1><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>在python中数字有三种类型：整数(int)、浮点数(float)、复数(complex)<br>我们可以使用<code>type()</code>函数来判断一个变量或值属于哪个类，还可以通过<code>instance()</code>函数来检查对象是否属于特定的类</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">checkType</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="built_in">print</span>(a, <span class="built_in">type</span>(a))</span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2.5</span></span><br><span class="line">c = <span class="number">1</span>+<span class="number">2j</span></span><br><span class="line"><span class="built_in">print</span>(c, <span class="string">&#x27;是复数吗？&#x27;</span>, <span class="built_in">isinstance</span>(c, <span class="built_in">complex</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">checkType(a)</span><br><span class="line">checkType(b)</span><br><span class="line">checkType(c)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>input([prompt])</p>
</blockquote>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="built_in">input</span>(<span class="string">&#x27;Enter a number&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于默认是字符串，需要做类型转换</span></span><br><span class="line">a = (<span class="built_in">int</span>)(<span class="built_in">input</span>(<span class="string">&#x27;Enter an integer&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>列表中的项目允许不是同一类型。<br>我们可以使用<code>[]</code>运算符从列表中提取一个项目 或 一系列项目。注意，在Python中，索引从<code>0</code>开始。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">NOTE:</span> 声明</span></span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2.2</span>, <span class="string">&#x27;python&#x27;</span>]</span><br><span class="line">b = [<span class="number">5</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">20</span>, <span class="number">30</span> , <span class="number">50</span> , <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a[2]=&#x27;</span>, a[<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;b[4]=&#x27;</span>, b[<span class="number">4</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>元组和列表相同，但是元组中的元素是不可变的，元组一旦创建就不可修改</p>
<p>它在括号内 () 定义，其中各项之间用逗号分隔</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">NOTE:</span> 声明</span></span><br><span class="line"></span><br><span class="line">tup = (<span class="number">1</span> , <span class="string">&#x27;awdaw&#x27;</span>, <span class="number">12</span>);</span><br><span class="line"><span class="built_in">print</span>(tup)</span><br><span class="line"><span class="comment"># <span class="doctag">BUG:</span> tup[1] = 1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串和元组一样，其中的元素是不可变的</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">NOTE:</span> 声明</span></span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;awdawdwada&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;s[4]&quot;</span>, s[<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">BUG:</span> s[4] = 1</span></span><br></pre></td></tr></table></figure></div>

<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>Set 是唯一项的无序集合。Set 由用大括号 { } 括起来，并由逗号分隔的值的集合。集合中的项目是无序的</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">NOTE:</span> 声明</span></span><br><span class="line">s = &#123;<span class="number">5</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">3</span> ,<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;s =&#x27;</span>,s, <span class="built_in">type</span>(s))</span><br><span class="line"><span class="comment"># <span class="doctag">BUG:</span> s[2] = 2;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>类似哈希表，需要一个key和一个value，key是唯一的，value可以是任何类型。字典中的项目是无序的</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">NOTE:</span> 声明</span></span><br><span class="line">d = &#123;<span class="number">1</span>:<span class="string">&#x27;value&#x27;</span>, <span class="string">&#x27;key&#x27;</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(d, <span class="built_in">type</span>(d))</span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">NOTE:</span> 访问</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;d[&#x27;key&#x27;] = &quot;</span>, d[<span class="string">&#x27;key&#x27;</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="对象与类"><a href="#对象与类" class="headerlink" title="对象与类"></a>对象与类</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parrot</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 类属性</span></span><br><span class="line">    species = <span class="string">&#x27;bird&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Constructor</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name;</span><br><span class="line">        self.age = age;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Method</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">string</span>(<span class="params">self, song</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#125; song is &#123;&#125;&quot;</span>.<span class="built_in">format</span>(self.name, song)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dance</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#125; is now dancing&quot;</span>.<span class="built_in">format</span>(self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">blu = Parrot(<span class="string">&quot;麻雀&quot;</span>, <span class="number">10</span>)</span><br><span class="line">woo = Parrot(<span class="string">&quot;鹦鹉&quot;</span>, <span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;麻雀是 &#123;&#125;&quot;</span>.<span class="built_in">format</span>(blu.__class__.species))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;鹦鹉是 &#123;&#125;&quot;</span>.<span class="built_in">format</span>(woo.__class__.species))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;&#125; is &#123;&#125; old&quot;</span>.<span class="built_in">format</span>(blu.name, blu.age))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;&#125; is &#123;&#125; old&quot;</span>.<span class="built_in">format</span>(woo.name, woo.age))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>( blu.string(<span class="string">&quot;极乐净土&quot;</span>) )</span><br><span class="line"><span class="built_in">print</span>( blu.dance() )</span><br></pre></td></tr></table></figure></div>

<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><blockquote>
<p>可以使用<code>isinstance</code> 和 <code>issubclass</code> 来检查一个对象是该类的实例和是否是一个特定的类或者子类</p>
</blockquote>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Bird is ready&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">whoisThis</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Bird&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">swim</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Swimming faster&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Penguin</span>(<span class="title class_ inherited__">Bird</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># call super() function</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Penguin is ready&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">whoisThis</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Penguin&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Run faster&quot;</span>)</span><br><span class="line"></span><br><span class="line">peggy = Penguin()</span><br><span class="line">peggy.whoisThis()</span><br><span class="line">peggy.run()</span><br><span class="line">peggy.swim()</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="可封装性"><a href="#可封装性" class="headerlink" title="可封装性"></a>可封装性</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.__maxprice = <span class="number">900</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sell</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Price is: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(self.__maxprice))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setMaxPrice</span>(<span class="params">self, price</span>):</span><br><span class="line">        self.__maxprice = price</span><br><span class="line"></span><br><span class="line">c = Computer()</span><br><span class="line">c.sell()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Change price&quot;</span>)</span><br><span class="line">c.setMaxPrice(<span class="number">1000</span>)</span><br><span class="line">c.sell()</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parrot</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fly</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Parrot can fly&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">swim</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Parrot can&#x27;t swim&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Penguin</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fly</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Penguin can&#x27;t fly&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">swim</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Penguin can swim&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># universal method</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">flying_test</span>(<span class="params">bird</span>):</span><br><span class="line">    bird.fly()</span><br><span class="line"></span><br><span class="line">blu = Parrot()</span><br><span class="line">peggy = Penguin()</span><br><span class="line"></span><br><span class="line">flying_test(blu)</span><br><span class="line">flying_test(peggy)</span><br></pre></td></tr></table></figure></div>

<h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><blockquote>
<p>通过在中实现特殊函数(__function_name__)</p>
</blockquote>
<table>
<thead>
<tr>
<th>运算符</th>
<th>表达</th>
<th>在内部</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>p1 + p2</td>
<td>p1.__add__(p2)</td>
</tr>
<tr>
<td>-</td>
<td>p1 - p2</td>
<td>p1.__sub__(p2)</td>
</tr>
<tr>
<td>*</td>
<td>p1 * p2</td>
<td>p1.__mul__(p2)</td>
</tr>
<tr>
<td>求幂 **</td>
<td>p1 ** p2</td>
<td>p1.__pow__(p2)</td>
</tr>
<tr>
<td>相除 &#x2F;</td>
<td>p1 &#x2F; p2</td>
<td>p1.__truediv__(p2)</td>
</tr>
<tr>
<td>整除 &#x2F;&#x2F;</td>
<td>p1 &#x2F;&#x2F; p2</td>
<td>p1.__floordiv__(p2)</td>
</tr>
<tr>
<td>%</td>
<td>p1 % p2</td>
<td>p1.__mode__(p2)</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>p1 &lt;&lt; p2</td>
<td>p1.__lshift__(p2)</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>p1 &gt;&gt; p2</td>
<td>p1.__rshift__(p2)</td>
</tr>
<tr>
<td>and</td>
<td>p1 and p2</td>
<td>p1.__and__(p2)</td>
</tr>
<tr>
<td>or</td>
<td>p1 or p2</td>
<td>p1.__or__(p2)</td>
</tr>
<tr>
<td>^</td>
<td>p1 ^ p2</td>
<td>p1.__xor__(p2)</td>
</tr>
<tr>
<td>~</td>
<td>~p1</td>
<td>p1.__invert__()</td>
</tr>
<tr>
<td>&lt;</td>
<td>p1 &lt; p2</td>
<td>p1.__lt__(p2)</td>
</tr>
<tr>
<td>&gt;</td>
<td>p1 &gt; p2</td>
<td>p1.__gt__(p2)</td>
</tr>
<tr>
<td>&lt;&#x3D;</td>
<td>p1 &lt;&#x3D; p2</td>
<td>p1.__le__(p2)</td>
</tr>
<tr>
<td>&gt;&#x3D;</td>
<td>p1 &gt;&#x3D; p2</td>
<td>p1.__ge__(p2)</td>
</tr>
<tr>
<td>&#x3D;&#x3D;</td>
<td>p1 &#x3D;&#x3D; p2</td>
<td>p1.__eq__(p2)</td>
</tr>
<tr>
<td>!&#x3D;</td>
<td>p1 !&#x3D; p2</td>
<td>p1.__ne__(p2)</td>
</tr>
</tbody></table>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>Python中的Iterator只是一个可以迭代的对象。一个将返回数据的对象，一次返回一个元素。</p>
<p>自定类实现迭代器</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PowTwo</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, <span class="built_in">max</span> = <span class="number">0</span></span>):</span><br><span class="line">        self.<span class="built_in">max</span> = <span class="built_in">max</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        self.n = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.n &lt;= self.<span class="built_in">max</span>:</span><br><span class="line">            result = <span class="number">2</span> ** self.n</span><br><span class="line">            self.n += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = PowTwo(<span class="number">4</span>)</span><br><span class="line">i = <span class="built_in">iter</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(i))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> PowTwo(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2024/07/13/singleton/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个全局对象，这样有利于我们调整系统行为</p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><ul>
<li>一个类能返回一个对象的引用(永远都是同一个)和一个获得该实例的方法(必须是静态方法) <code>getInstance</code></li>
<li>调用这个方法时，如果类持有的引用不为空就返回这个引用。如果类保持的引用为空，就创建该类的实例返回这个实例的引用</li>
<li>将该类的构造函数定义为私有方法，这样其他处的代码就无法通过调用该类的构造函数来实例化该对象，只有通过该类的静态方法来实现唯一实例。</li>
</ul>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ol>
<li>懒汉式</li>
</ol>
<blockquote>
<p>这种lazyloading很明显，不要求线程安全，在多线程不能正常工作</p>
</blockquote>
<table>
<thead>
<tr>
<th>是否lazy初始化</th>
<th>是否多线程安全</th>
<th>实现难度</th>
</tr>
</thead>
<tbody><tr>
<td>是</td>
<td>否</td>
<td>易</td>
</tr>
</tbody></table>
<p>实现：局部静态变量方式</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleLazy</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingleLazy</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SingleLazy</span>(<span class="type">const</span> SingleLazy&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    SingleLazy&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SingleLazy&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> SingleLazy&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> SingleLazy single;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_SingleLazy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 多线程可能出现问题</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;s1 addr is &quot;</span> &lt;&lt; &amp;SingleLazy::<span class="built_in">getInstance</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;s2 addr is &quot;</span> &lt;&lt; &amp;SingleLazy::<span class="built_in">getInstance</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>输出如下</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">s1 addr is 0x557ab517b151</span><br><span class="line">s2 addr is 0x557ab517b151</span><br></pre></td></tr></table></figure></div>

<p>确实生成了唯一实例，但是存在隐患，多线程可能生成多个实例</p>
<ol start="2">
<li>饿汉式</li>
</ol>
<table>
<thead>
<tr>
<th>是否lazy初始化</th>
<th>是否多线程安全</th>
<th>实现难度</th>
</tr>
</thead>
<tbody><tr>
<td>否</td>
<td>是</td>
<td>易</td>
</tr>
</tbody></table>
<ul>
<li>优点：没有加锁，执行效率会提高</li>
<li>缺点：类加载时就初始化，浪费内存</li>
</ul>
<p>实现：静态成员变量指针方式</p>
<blockquote>
<p>定义一个类的静态成员变量，用来控制实现单例</p>
</blockquote>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleHungry</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingleHungry</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SingleHungry</span>(<span class="type">const</span> SingleHungry&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    SingleHungry&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SingleHungry&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> SingleHungry* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(single == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            single = <span class="keyword">new</span> <span class="built_in">SingleHungry</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> SingleHungry *single;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 饿汉式初始化</span></span><br><span class="line">SingleHungry *SingleHungry::single = SingleHungry::<span class="built_in">getInstance</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_func</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;this is thread &quot;</span> &lt;&lt; num &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Instance is &quot;</span> &lt;&lt; SingleHungry::<span class="built_in">getInstance</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_SingleHungry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;s1 addr is &quot;</span> &lt;&lt; SingleHungry::<span class="built_in">getInstance</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;s2 addr is &quot;</span> &lt;&lt; SingleHungry::<span class="built_in">getInstance</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="function">std::thread <span class="title">ti</span><span class="params">(thread_func , i)</span></span>;</span><br><span class="line">        ti.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>输出结果如下</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">s1 addr is 0x56334e3ae2b0</span><br><span class="line">s2 addr is 0x56334e3ae2b0</span><br><span class="line">this is thread 0</span><br><span class="line">Instance is 0x56334e3ae2b0</span><br><span class="line">this is thread 1</span><br><span class="line">Instance is 0x56334e3ae2b0</span><br><span class="line">this is thread 2</span><br><span class="line">Instance is 0x56334e3ae2b0</span><br></pre></td></tr></table></figure></div>
<p>可见无论是单线程还是多线程模式下，通过静态成员变量的指针实现的单例类都是唯一的。  </p>
<p>但是无论是饿汉式还是懒汉式都存在一个问题，那就是什么时候释放内存？多线程情况下，释放内存就很难了，还有二次释放内存的风险。</p>
<p>下面我们定义一个单例类并用懒汉式调用</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SinglePointer</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SinglePointer</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SinglePointer</span>(<span class="type">const</span> SinglePointer&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    SinglePointer&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SinglePointer&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> SinglePointer* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(single != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        Lock.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span>(single != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            Lock.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        single = <span class="keyword">new</span> <span class="built_in">SinglePointer</span>();</span><br><span class="line">        Lock.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> SinglePointer *single;</span><br><span class="line">    <span class="type">static</span> std::mutex Lock;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::mutex SinglePointer::Lock;</span><br><span class="line">SinglePointer *SinglePointer::single = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_func_ptr</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;this thread is &quot;</span> &lt;&lt; num &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Instance is &quot;</span> &lt;&lt; SinglePointer::<span class="built_in">getInstance</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_SinglePointer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;s1 addr is &quot;</span> &lt;&lt; SinglePointer::<span class="built_in">getInstance</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;s2 addr is &quot;</span> &lt;&lt; SinglePointer::<span class="built_in">getInstance</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="function">std::thread <span class="title">ti</span><span class="params">(thread_func_ptr , i)</span></span>;</span><br><span class="line">        ti.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 何时释放new的对象?造成内存泄漏</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>输出结果如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">s1 addr is 0x55cede7582d0</span><br><span class="line">s2 addr is 0x55cede7582d0</span><br><span class="line">this thread is 0</span><br><span class="line">Instance is 0x55cede7582d0</span><br><span class="line">this thread is 1</span><br><span class="line">Instance is 0x55cede7582d0</span><br><span class="line">this thread is 2</span><br><span class="line">Instance is 0x55cede7582d0</span><br></pre></td></tr></table></figure></div>
<p>此时生成的单例对象的内存空间还没回收，这是个问题，另外如果多线程情况下多次delete也会造成崩溃。</p>
<p>所以需要一种自动回收内存的机制帮助我们回收内存，所以可以使用智能指针来做这个操作</p>
<p>实现方式：智能指针方式</p>
<blockquote>
<p>可以利用智能指针自动回收内存的机制设计单例类</p>
</blockquote>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleAuto</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingleAuto</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SingleAuto</span>(<span class="type">const</span> SingleAuto&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    SingleAuto&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SingleAuto&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">SingleAuto</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;single auto delete success\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;SingleAuto&gt; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(single != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        Lock.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span>(single != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            Lock.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        single = std::<span class="built_in">shared_ptr</span>&lt;SingleAuto&gt;(<span class="keyword">new</span> <span class="built_in">SingleAuto</span>());</span><br><span class="line">        Lock.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> std::shared_ptr&lt;SingleAuto&gt; single;</span><br><span class="line">    <span class="type">static</span> std::mutex Lock;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;SingleAuto&gt; SingleAuto:: single = <span class="literal">nullptr</span>;</span><br><span class="line">std::mutex SingleAuto::Lock;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_SingleAuto</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> sp1 = SingleAuto::<span class="built_in">getInstance</span>();</span><br><span class="line">    <span class="keyword">auto</span> sp2 = SingleAuto::<span class="built_in">getInstance</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sp1 is &quot;</span> &lt;&lt; sp1 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sp2 is &quot;</span> &lt;&lt; sp2 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 存在隐患，可以手动删除裸指针，造成崩溃，因为会二次释放内存</span></span><br><span class="line">    <span class="comment">// delete sp1.get();</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>输出如下</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sp1 is 0x56252c7252f0</span><br><span class="line">sp2 is 0x56252c7252f0</span><br></pre></td></tr></table></figure></div>

<p>智能指针方式不存在内存泄漏，但是有一个隐患就是单例类的析构函数是public,如果被人手动调用会存在崩溃问题，比如将上面的test_SingleAuto中的注释打开，程序会崩溃。</p>
<p>实现：辅助类智能指针单例模式</p>
<blockquote>
<p>智能指针在构造的时候可以指定删除器，所以可以传递一个辅助类或者辅助函数帮助智能指针回收内存时调用我们指定的析构函数</p>
</blockquote>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> safe deletorr</span></span><br><span class="line"><span class="comment">// 防止外界deletor</span></span><br><span class="line"><span class="comment">// 声明辅助类</span></span><br><span class="line"><span class="comment">// 该类定义放函数调用SingleAutoSafe析构函数</span></span><br><span class="line"><span class="comment">// 不可以提前声明辅助类，编译器会报 incomplete type</span></span><br><span class="line"><span class="comment">// class SafeDeletor</span></span><br><span class="line"><span class="comment">// 所以要提前定义辅助类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleAutoSafe</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SafeDeletor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(SingleAutoSafe* s)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;this is safe deletor operator()\n&quot;</span>;</span><br><span class="line">        <span class="keyword">delete</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SafeDeletorFunc</span><span class="params">(SingleAutoSafe* s)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;this is safe deletor func\n&quot;</span>;</span><br><span class="line">    <span class="keyword">delete</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleAutoSafe</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingleAutoSafe</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">SingleAutoSafe</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;this is sing auto safe deletor\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SingleAutoSafe</span>(<span class="type">const</span> SingleAutoSafe&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    SingleAutoSafe&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SingleAutoSafe&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">SafeDeletor</span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">SafeDeletorFunc</span><span class="params">(SingleAutoSafe* s)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;SingleAutoSafe&gt; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(single != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        Lock.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span>(single != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            Lock.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span>额外指定删除器</span></span><br><span class="line">        <span class="comment">// single = std::shared_ptr&lt;SingleAutoSafe&gt;(new SingleAutoSafe() , SafeDeletor());</span></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span>额外指定删除函数</span></span><br><span class="line">        single = std::<span class="built_in">shared_ptr</span>&lt;SingleAutoSafe&gt;(<span class="keyword">new</span> <span class="built_in">SingleAutoSafe</span>() , SafeDeletorFunc);</span><br><span class="line">        Lock.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> std::shared_ptr&lt;SingleAutoSafe&gt; single;</span><br><span class="line">    <span class="type">static</span> std::mutex Lock;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;SingleAutoSafe&gt; SingleAutoSafe::single = <span class="literal">nullptr</span>;</span><br><span class="line">std::mutex SingleAutoSafe::Lock;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_SingleAutoSafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> sp1 = SingleAutoSafe::<span class="built_in">getInstance</span>();</span><br><span class="line">    <span class="keyword">auto</span> sp2 = SingleAutoSafe::<span class="built_in">getInstance</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sp1 is &quot;</span> &lt;&lt; sp1 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sp2 is &quot;</span> &lt;&lt; sp2 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 此时无法访问析构函数，非常安全</span></span><br><span class="line">    <span class="comment">// delete sp1.get();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>输出如下</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sp1 is 0x563f192162b0</span><br><span class="line">sp2 is 0x563f192162b0</span><br><span class="line">this is safe deletor func</span><br></pre></td></tr></table></figure></div>
<p>SafeDeletor要写在SingleAutoSafe上边，并且SafeDeletor要声明为SingleAutoSafe类的友元类，这样就可以访问SingleAutoSafe的析构函数了。 我们在构造single时制定了SafeDeletor(),single在回收时，会调用SingleAutoSafe的仿函数，从而完成内存的销毁。 并且SingleAutoSafe的析构函数为私有的无法被外界手动调用了。</p>
<p>通过辅助类调用单例类的析构函数保证了内存释放的安全性和唯一性。这种方式是生产中常用的。如果将test_SingleAutoSafe的注释打开，手动删除在编译阶段就会报错，达到了代码安全的目的。</p>
<h2 id="通过单例模板类"><a href="#通过单例模板类" class="headerlink" title="通过单例模板类"></a>通过单例模板类</h2><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TD</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Single_T</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SafeDeletor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T* s)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;this is safe deletor operator()\n&quot;</span>;</span><br><span class="line">        <span class="keyword">delete</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SafeDeletorFunc</span><span class="params">(T* s)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;this is safe deletor func\n&quot;</span>;</span><br><span class="line">    <span class="keyword">delete</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Single_T</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Single_T</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Single_T</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;this is single template deletor\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Single_T</span>(<span class="type">const</span> Single_T&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Single_T&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Single_T&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">SafeDeletor</span>&lt;T&gt;;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">void</span> <span class="built_in">SafeDeletorFunc</span>&lt;T&gt;(T* s);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;T&gt; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(single != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        Lock.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span>(single != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            Lock.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span>额外指定删除器</span></span><br><span class="line">        <span class="comment">// single = std::shared_ptr&lt;T&gt;(new T, SafeDeletor&lt;T&gt;());</span></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span>额外指定删除函数</span></span><br><span class="line">        single = std::<span class="built_in">shared_ptr</span>&lt;T&gt;(<span class="keyword">new</span> T , SafeDeletorFunc&lt;T&gt;);</span><br><span class="line">        Lock.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> std::shared_ptr&lt;T&gt; single;</span><br><span class="line">    <span class="type">static</span> std::mutex Lock;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> 模板类的static成员要放在hpp文件内初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::shared_ptr&lt;T&gt; Single_T&lt;T&gt;::single = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::mutex Single_T&lt;T&gt;::Lock;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>


<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用std::call_once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleTon</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SingleTon</span><span class="params">()</span> </span>= <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">SingleTon</span>(<span class="type">const</span> SingleTon&amp; ) = <span class="keyword">delete</span>;</span><br><span class="line">    SingleTon&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SingleTon&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ~<span class="built_in">SingleTon</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;This is SingleTon deletor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">static</span> std::shared_ptr&lt;T&gt; single;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;T&gt; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> std::once_flag flag;</span><br><span class="line">        std::<span class="built_in">call_once</span>(flag, [&amp;]()&#123;</span><br><span class="line">            single = std::<span class="built_in">make_shared</span>&lt;T&gt;(<span class="keyword">new</span> T);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::shared_ptr&lt;T&gt; SingleTon&lt;T&gt;::single = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>使用方式：我们只需要定一个单例类，继承这个模板，并将构造和析构都设置为私有，同时设置友元保证自己的析构和构造可以被友元调用即可。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleNet</span> : <span class="keyword">public</span> Single_T&lt;SingleNet&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingleNet</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">SingleNet</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">SingleNet</span>(<span class="type">const</span> SingleNet&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    SingleNet&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SingleNet&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">SafeDeletor</span>&lt;SingleNet&gt;;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Single_T</span>&lt;SingleNet&gt;;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">void</span> <span class="built_in">SafeDeletorFunc</span>&lt;SingleNet&gt;(SingleNet* s);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_Single_T</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> sp1 = SingleNet::<span class="built_in">getInstance</span>();</span><br><span class="line">    <span class="keyword">auto</span> sp2 = SingleNet::<span class="built_in">getInstance</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sp1 is &quot;</span> &lt;&lt; sp1 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sp2 is &quot;</span> &lt;&lt; sp2 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>tcp粘包问题</title>
    <url>/2024/07/26/tcp-packet/</url>
    <content><![CDATA[<h1 id="什么是粘包"><a href="#什么是粘包" class="headerlink" title="什么是粘包"></a>什么是粘包</h1><p>TCP粘包问题是指在使用TCP协议进行网络通信时，客户端和服务器之间发送的数据包可能会被TCP协议栈在底层进行合并或者拆分，导致客户端接收到的数据不再是单独、完整的数据包，而是多个数据包的内容被粘在一起或者多个数据包的内容被拆分到不同的接收缓冲区中。</p>
<h1 id="粘包原因"><a href="#粘包原因" class="headerlink" title="粘包原因"></a>粘包原因</h1><h2 id="1-因为TCP是面向字节流的协议"><a href="#1-因为TCP是面向字节流的协议" class="headerlink" title="1. 因为TCP是面向字节流的协议"></a>1. 因为TCP是面向字节流的协议</h2><p>传输的数据是以流的形式,而流数据是没有明确的开始结尾边界,所以 TCP 也没办法判断哪一段流属于一个消息;TCP协议是流式协议;所谓流式协议,即协议的内容是像流水一样的字节流,内容与内容之间没有明确的分界标志,需要认为手动地去给这些协议划分边界。</p>
<p>例如客户端每次发送N个字节给服务端，N取决于当前客户端的发送缓冲区是否有数据，比如发送缓冲区总大小为10个字节，当前有5个字节数据（例如上次要发送的数据‘loveu’）未发送完，那么此时只有5个字节的空闲空间，客户端调用发送接口发送“hello world!”其实就是只能发送“hello”给服务器，那么服务器一次性得到的数据就是“loveuhello”，而剩余的“world！”只能留给下一次发送，下一次服务器收到的就是“world！”</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/07/30/FLGRpuP6DyoK4vQ.png"
                      alt="tlv1.png"
                ></p>
<h2 id="2-数据发送和接收速率不匹配"><a href="#2-数据发送和接收速率不匹配" class="headerlink" title="2. 数据发送和接收速率不匹配"></a>2. 数据发送和接收速率不匹配</h2><p>如果发送方发送数据的速度比接收方处理数据的速度快，就可能导致多个消息被一次性读取。比如客户端1s内发送了两次“hello world！”，服务器过了2s才接收到数据，那一次性就会读出两个“hello world”</p>
<h2 id="3-tcp底层的安全和效率机制不允许字节数特别少的小包发送频率过高"><a href="#3-tcp底层的安全和效率机制不允许字节数特别少的小包发送频率过高" class="headerlink" title="3. tcp底层的安全和效率机制不允许字节数特别少的小包发送频率过高"></a>3. tcp底层的安全和效率机制不允许字节数特别少的小包发送频率过高</h2><p>tcp会在底层累计数据长度到一定大小才一起发送，比如连续发送1字节的数据要累计到多个字节才发送，可以了解下tcp底层的<a class="link"   href="https://blog.csdn.net/m0_61567378/article/details/130886149" >Nagle算法 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<h1 id="处理粘包"><a href="#处理粘包" class="headerlink" title="处理粘包"></a>处理粘包</h1><p>处理粘包的方式主要采用应用层定义收发包格式的方式，这个过程俗称切包处理，常用的协议被称为<code>tlv</code>协议(消息id+消息长度+消息内容)</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/07/26/3q8MRKOo9YD7z4S.png"
                      alt="tlv1.png"
                ></p>
<p>为了方便理解，这里先简化发送格式，改成“消息长度+消息内容”的方式</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/07/26/blhFoOsUPANJQa2.png"
                      alt="tlvsimple.png"
                ></p>
<h2 id="消息节点"><a href="#消息节点" class="headerlink" title="消息节点"></a>消息节点</h2><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_LENGTH 1024 * 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAD_LENGTH 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Session</span>;</span><br><span class="line">    <span class="built_in">MsgNode</span>( <span class="type">char</span> *msg, <span class="type">short</span> max_len )</span><br><span class="line">        : _cur_len( <span class="number">0</span> ), _total_len( max_len + HEAD_LENGTH ) &#123;</span><br><span class="line">        _msg = <span class="keyword">new</span> <span class="type">char</span>[_total_len + <span class="number">1</span>]();     <span class="comment">// 这里➕1是为了存放&#x27;\0&#x27;</span></span><br><span class="line">        <span class="built_in">memcpy</span>( _msg, &amp;max_len, HEAD_LENGTH ); <span class="comment">// 留出两个字节存储消息头</span></span><br><span class="line">        <span class="built_in">mempcpy</span>( _msg + HEAD_LENGTH, msg, max_len ); <span class="comment">// 存储消息体</span></span><br><span class="line">        _msg[_total_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MsgNode</span>( <span class="type">short</span> max_len ) : _cur_len( <span class="number">0</span> ), _total_len( max_len ) &#123;</span><br><span class="line">        _msg = <span class="keyword">new</span> <span class="type">char</span>[_total_len + <span class="number">1</span>]();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>( _msg, <span class="number">0</span>, _total_len );</span><br><span class="line">        _cur_len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MsgNode</span>() &#123; <span class="keyword">delete</span>[] _msg; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">short</span> _cur_len;   <span class="comment">// 当前已处理的数据长度</span></span><br><span class="line">    <span class="type">short</span> _total_len; <span class="comment">// 数据的总长度</span></span><br><span class="line">    <span class="type">char</span> *_msg;       <span class="comment">// 存储的数据指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h2 id="Session的改进"><a href="#Session的改进" class="headerlink" title="Session的改进"></a>Session的改进</h2><p>为了能够对收到的数据进行切包处理，需要定义一个消息接收节点、一个bool变量表示头部信息是否处理完成，以及将处理好的头部先缓存起来的结构</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;MsgNode&gt; _recv_msg_node;  <span class="comment">//收到消息结构</span></span><br><span class="line"><span class="type">bool</span> _b_head_parse;                       <span class="comment">//是否处理完头部信息</span></span><br><span class="line">std::shared_ptr&lt;MsgNode&gt; _recv_head_node; <span class="comment">//收到头部结构</span></span><br></pre></td></tr></table></figure></div>

<h2 id="完善接收逻辑"><a href="#完善接收逻辑" class="headerlink" title="完善接收逻辑"></a>完善接收逻辑</h2><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::HandleRead</span><span class="params">( <span class="type">const</span> boost::system::error_code &amp;error,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> bytes_transferred, std::shared_ptr&lt;Session&gt; _self_shared )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( !error ) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">PrintRecvData</span>(_data, bytes_transferred);</span><br><span class="line">        std::<span class="function">chrono::seconds <span class="title">duration</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(duration);</span><br><span class="line">        <span class="comment">// 已经移动的字符串</span></span><br><span class="line">        <span class="type">int</span> copy_len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ( bytes_transferred &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="comment">// 判断头部是否处理</span></span><br><span class="line">            <span class="keyword">if</span> ( !_b_head_parse ) &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">NOTE:</span> step 1</span></span><br><span class="line">                <span class="comment">// 如果数据小于头部大小，先将数据放入_recv_head_node</span></span><br><span class="line">                <span class="keyword">if</span> ( bytes_transferred + _recv_head_node-&gt;_cur_len &lt;</span><br><span class="line">                     HEAD_LENGTH ) &#123;</span><br><span class="line">                    <span class="built_in">memcpy</span>( _recv_head_node-&gt;_msg + _recv_head_node-&gt;_cur_len,</span><br><span class="line">                        _data + copy_len, bytes_transferred );</span><br><span class="line">                    _recv_head_node-&gt;_cur_len += bytes_transferred;</span><br><span class="line">                    <span class="built_in">memset</span>( _data, <span class="number">0</span>, MAX_LENGTH );</span><br><span class="line">                    _socket.<span class="built_in">async_read_some</span>(</span><br><span class="line">                        boost::asio::<span class="built_in">buffer</span>( _data, MAX_LENGTH ),</span><br><span class="line">                        std::<span class="built_in">bind</span>( &amp;Session::HandleRead, <span class="keyword">this</span>,</span><br><span class="line">                            std::placeholders::_1, std::placeholders::_2,</span><br><span class="line">                            _self_shared ) );</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// <span class="doctag">NOTE:</span> step 2</span></span><br><span class="line">                <span class="comment">// 收到的数据比头部多，可能是多个逻辑包，要做切包处理</span></span><br><span class="line">                <span class="comment">// 头部剩余未复制的长度</span></span><br><span class="line">                <span class="type">int</span> head_remain = HEAD_LENGTH - _recv_head_node-&gt;_cur_len;</span><br><span class="line">                <span class="built_in">memcpy</span>( _recv_head_node-&gt;_msg + _recv_head_node-&gt;_cur_len,</span><br><span class="line">                    _data + copy_len, head_remain );</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新已处理的data长度和剩余未处理长度</span></span><br><span class="line">                copy_len += head_remain;</span><br><span class="line">                bytes_transferred -= head_remain;</span><br><span class="line">                <span class="comment">// 获取头部数据</span></span><br><span class="line">                <span class="type">short</span> data_len = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">memcpy</span>( &amp;data_len, _recv_head_node-&gt;_msg, HEAD_LENGTH );</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;data_len is: &quot;</span> &lt;&lt; data_len &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 头部非法长度</span></span><br><span class="line">                <span class="keyword">if</span> ( data_len &gt; HEAD_LENGTH ) &#123;</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;Invalid data length is: &quot;</span> &lt;&lt; data_len</span><br><span class="line">                              &lt;&lt; std::endl;</span><br><span class="line">                    _server-&gt;<span class="built_in">ClearSession</span>( _uuid );</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                _recv_msg_node = std::<span class="built_in">make_shared</span>&lt;MsgNode&gt;( data_len );</span><br><span class="line"></span><br><span class="line">                <span class="comment">// <span class="doctag">NOTE:</span> step 3</span></span><br><span class="line">                <span class="comment">// 消息的长度小于头部规定的长度，说明数据未收集全，则先将部分消息放到接收节点里</span></span><br><span class="line">                <span class="keyword">if</span> ( (<span class="type">int</span>)bytes_transferred &lt; data_len ) &#123;</span><br><span class="line">                    <span class="built_in">memcpy</span>( _recv_msg_node-&gt;_msg + _recv_msg_node-&gt;_cur_len,</span><br><span class="line">                        _data + copy_len, bytes_transferred );</span><br><span class="line">                    _recv_msg_node-&gt;_cur_len += bytes_transferred;</span><br><span class="line">                    <span class="built_in">memset</span>( _data, <span class="number">0</span>, MAX_LENGTH );</span><br><span class="line">                    _socket.<span class="built_in">async_read_some</span>(</span><br><span class="line">                        boost::asio::<span class="built_in">buffer</span>( _data, MAX_LENGTH ),</span><br><span class="line">                        std::<span class="built_in">bind</span>( &amp;Session::HandleRead, <span class="keyword">this</span>,</span><br><span class="line">                            std::placeholders::_1, std::placeholders::_2,</span><br><span class="line">                            _self_shared ) );</span><br><span class="line">                    <span class="comment">// 头部处理完成</span></span><br><span class="line">                    _b_head_parse = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">memcpy</span>( _recv_msg_node-&gt;_msg + _recv_msg_node-&gt;_cur_len,</span><br><span class="line">                    _data + copy_len, data_len );</span><br><span class="line"></span><br><span class="line">                _recv_msg_node-&gt;_cur_len += data_len;</span><br><span class="line">                copy_len += data_len;</span><br><span class="line">                bytes_transferred -= data_len;</span><br><span class="line">                _recv_msg_node-&gt;_msg[_recv_msg_node-&gt;_total_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Recv msg is: &quot;</span> &lt;&lt; _recv_msg_node-&gt;_msg</span><br><span class="line">                          &lt;&lt; std::endl;</span><br><span class="line">                <span class="comment">// use Send for testing</span></span><br><span class="line">                <span class="built_in">Send</span>( _recv_msg_node-&gt;_msg, _recv_msg_node-&gt;_total_len );</span><br><span class="line">                <span class="comment">// 继续轮询未处理的数据</span></span><br><span class="line">                _b_head_parse = <span class="literal">false</span>;</span><br><span class="line">                _recv_head_node-&gt;<span class="built_in">clear</span>();</span><br><span class="line">                <span class="keyword">if</span> ( bytes_transferred &lt;= <span class="number">0</span> ) &#123;</span><br><span class="line">                    <span class="built_in">memset</span>( _data, <span class="number">0</span>, MAX_LENGTH );</span><br><span class="line">                    _socket.<span class="built_in">async_read_some</span>(</span><br><span class="line">                        boost::asio::<span class="built_in">buffer</span>( _data, MAX_LENGTH ),</span><br><span class="line">                        std::<span class="built_in">bind</span>( &amp;Session::HandleRead, <span class="keyword">this</span>,</span><br><span class="line">                            std::placeholders::_1, std::placeholders::_2,</span><br><span class="line">                            _self_shared ) );</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// <span class="doctag">NOTE:</span> step 4</span></span><br><span class="line">            <span class="comment">// 已经处理完头部，处理上次未接收完的消息数据</span></span><br><span class="line">            <span class="comment">// 接收的数据仍不足剩余未处理的</span></span><br><span class="line">            <span class="type">int</span> remain_msg =</span><br><span class="line">                _recv_msg_node-&gt;_total_len - _recv_msg_node-&gt;_cur_len;</span><br><span class="line">            <span class="keyword">if</span> ( (<span class="type">int</span>)bytes_transferred &lt; remain_msg ) &#123;</span><br><span class="line">                <span class="built_in">memcpy</span>( _recv_msg_node-&gt;_msg + _recv_msg_node-&gt;_cur_len,</span><br><span class="line">                    _data + copy_len, bytes_transferred );</span><br><span class="line">                _recv_msg_node-&gt;_cur_len += bytes_transferred;</span><br><span class="line">                <span class="built_in">memset</span>( _data, <span class="number">0</span>, MAX_LENGTH );</span><br><span class="line">                _socket.<span class="built_in">async_read_some</span>(</span><br><span class="line">                    boost::asio::<span class="built_in">buffer</span>( _data, MAX_LENGTH ),</span><br><span class="line">                    std::<span class="built_in">bind</span>( &amp;Session::HandleRead, <span class="keyword">this</span>,</span><br><span class="line">                        std::placeholders::_1, std::placeholders::_2,</span><br><span class="line">                        _self_shared ) );</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">memcpy</span>( _recv_msg_node-&gt;_msg + _recv_msg_node-&gt;_cur_len,</span><br><span class="line">                _data + copy_len, remain_msg );</span><br><span class="line">            bytes_transferred -= remain_msg;</span><br><span class="line">            copy_len += remain_msg;</span><br><span class="line">            _recv_msg_node-&gt;_msg[_recv_msg_node-&gt;_total_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Recv msg is: &quot;</span> &lt;&lt; _recv_msg_node-&gt;_msg &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// use Send for testing</span></span><br><span class="line">            <span class="built_in">Send</span>( _recv_msg_node-&gt;_msg, _recv_msg_node-&gt;_total_len );</span><br><span class="line">            <span class="comment">// 继续轮询未处理的数据</span></span><br><span class="line">            _b_head_parse = <span class="literal">false</span>;</span><br><span class="line">            _recv_head_node-&gt;<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">if</span> ( bytes_transferred &lt;= <span class="number">0</span> ) &#123;</span><br><span class="line">                _socket.<span class="built_in">async_read_some</span>(</span><br><span class="line">                    boost::asio::<span class="built_in">buffer</span>( _data, MAX_LENGTH ),</span><br><span class="line">                    std::<span class="built_in">bind</span>( &amp;Session::HandleRead, <span class="keyword">this</span>,</span><br><span class="line">                        std::placeholders::_1, std::placeholders::_2,</span><br><span class="line">                        _self_shared ) );</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;handle read failed, code is: &quot;</span> &lt;&lt; error.<span class="built_in">value</span>()</span><br><span class="line">                  &lt;&lt; <span class="string">&quot; message is: &quot;</span> &lt;&lt; error.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line">        _server-&gt;<span class="built_in">ClearSession</span>( _uuid );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>


<ol>
<li><p><code>copy_len</code>：已经处理的数据长度，因为存在一次接收多个包的情况，所以copy_len的意义是在于记录已经处理的数据的长度</p>
</li>
<li><p>首先判断<code>_b_head_parse</code>是否为<code>false</code>，如果为<code>false</code>，则表示头部未处理，需要先处理头部。先判断接收的数据是否小于<code>HEAD_LENGTH</code>，如果小于则需要拷贝数据到<code>_recv_head_node</code>中，然后再读取剩余的数据。</p>
</li>
<li><p>如果受到的数据比头部数据多，可能是多个数据包，需要做切包处理。根据之前保留在<code>_recv_head_node</code>中的数据长度，计算出剩余未读取的头部长度，然后取出剩余头部长度保存在<code>_recv_head_node</code>中。然后通过<code>memcpy</code>从节点拷贝出数据写入short类型的<code>data_len</code>，并更新<code>copy_len</code>，进而得到消息长度， 然后再读取剩余的消息体。先判断接收到数据未处理部分的长度和总共要接收的数据长度大小，如果小于总共要接收的长度，说明消息体还没接收完，则将未处理的部分写入到<code>_recv_msg_node</code>里，回调读事件。否则说明消息体接收完全</p>
</li>
<li><p>将消息体数据接收到<code>_recv_msg_node</code>中，接收完全后返回给对端。当然存在多个逻辑包粘连，此时要判断<code>bytes_transferred</code>是否&lt;&#x3D;0，如果是则说明只有一个逻辑包，我们处理完了，继续监听读事件，就直接返回即可，否则说明有多个数据包粘连，就继续执行上述操作</p>
</li>
<li><p>因为存在<code>_b_head_parse</code>为<code>true</code>，就是包头接收并处理完的情况，但是包体未接收完，则再次出发读事件，此时就要继续进行上述操作</p>
</li>
</ol>
<p>总体流程如下</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2024/07/26/mr2BgQoTFJe4EYK.png"
                      alt="dealHandRead.png"
                ></p>
<h2 id="粘包测试"><a href="#粘包测试" class="headerlink" title="粘包测试"></a>粘包测试</h2><p>为了测试粘包，需要制造粘包产生的现象，可以让客户端发送的频率高一些，服务器接收的频率低一些，这样造成前后端收发数据不一致导致多个数据包在服务器tcp缓冲区滞留产生粘包现象。</p>
<p>测试粘包之前，在服务器的<code>Session</code>中添加打印二进制函数</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::PrintRecvData</span><span class="params">(<span class="type">char</span> *data, <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    std::string result = <span class="string">&quot;0x&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        std::string hexstr;</span><br><span class="line">        ss &lt;&lt; std::hex &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; <span class="built_in">int</span>(data[i]) &lt;&lt; std::endl;</span><br><span class="line">        ss &gt;&gt; hexstr;</span><br><span class="line">        result += hexstr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Recv raw data is: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>然后将这个函数放到HandleRead里，每次收到数据就调用这个函数打印接收到的最原始的数据，然后睡眠2秒再进行收发操作，用来延迟接收对端数据制造粘包，之后的逻辑不变</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::HandleRead</span><span class="params">( <span class="type">const</span> boost::system::error_code &amp;error,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> bytes_transferred, std::shared_ptr&lt;Session&gt; _self_shared )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( !error ) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">PrintRecvData</span>(_data, bytes_transferred);</span><br><span class="line">        std::<span class="function">chrono::seconds <span class="title">duration</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(duration);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>


<p>客户端代码实现收发分离</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> boost::asio::ip::tcp;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAX_LENGTH  = <span class="number">1024</span> * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> HEAD_LENGTH = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        boost::asio::io_context ioc;</span><br><span class="line">        <span class="function">tcp::endpoint <span class="title">remote_ep</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            boost::asio::ip::address::from_string( <span class="string">&quot;127.0.0.1&quot;</span> ), <span class="number">10086</span> )</span></span>;</span><br><span class="line">        <span class="function">tcp::socket <span class="title">sock</span><span class="params">( ioc )</span></span>;</span><br><span class="line">        boost::system::error_code ec = boost::asio::error::host_not_found;</span><br><span class="line">        sock.<span class="built_in">connect</span>( remote_ep, ec );</span><br><span class="line">        <span class="keyword">if</span> ( ec ) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;connect failed: &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>() &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::thread <span class="title">send_thread</span><span class="params">( [&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">while</span> ( <span class="literal">true</span> ) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                this_thread::sleep_for( std::chrono::milliseconds( <span class="number">1</span> ) );</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">const</span> <span class="type">char</span> *request_msg = <span class="string">&quot;Hello World!&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">size_t</span> request_len         = strlen( request_msg );</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">char</span> send_data[MAX_LENGTH] = &#123; <span class="number">0</span> &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">                memcpy( send_data, &amp;request_len, <span class="number">2</span> );</span></span></span><br><span class="line"><span class="params"><span class="function">                memcpy( send_data + <span class="number">2</span>, request_msg, request_len );</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">                boost::asio::write(</span></span></span><br><span class="line"><span class="params"><span class="function">                    sock, boost::asio::buffer( send_data, request_len + <span class="number">2</span> ) );</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125; )</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::thread <span class="title">recv_thread</span><span class="params">( [&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">while</span> ( <span class="literal">true</span> ) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                this_thread::sleep_for(std::chrono::milliseconds(<span class="number">1</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">                std::cout &lt;&lt; <span class="string">&quot;Begin to receive&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">char</span> reply_head[HEAD_LENGTH];</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">size_t</span> reply_length = boost::asio::read(</span></span></span><br><span class="line"><span class="params"><span class="function">                    sock, boost::asio::buffer( reply_head, HEAD_LENGTH ) );</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">short</span> msglen = <span class="number">0</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">                memcpy( &amp;msglen, reply_head, HEAD_LENGTH );</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">char</span> msg[MAX_LENGTH] = &#123; <span class="number">0</span> &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">size_t</span> msg_length    = boost::asio::read(</span></span></span><br><span class="line"><span class="params"><span class="function">                    sock, boost::asio::buffer( msg, msglen ) );</span></span></span><br><span class="line"><span class="params"><span class="function">                cout &lt;&lt; <span class="string">&quot;Reply is: &quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">                cout.write( msg, msg_length ) &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">                cout &lt;&lt; <span class="string">&quot;Reply length is: &quot;</span> &lt;&lt; msg_length &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125; )</span></span>;</span><br><span class="line"></span><br><span class="line">        send_thread.<span class="built_in">join</span>();</span><br><span class="line">        recv_thread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="built_in">catch</span> ( std::exception &amp;e ) &#123;</span><br><span class="line">        cerr &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>


<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>该服务虽然实现了粘包处理，但是服务器仍存在不足，比如当客户端和服务器处于不同平台时收发数据会出现异常，根本原因是未处理大小端模式的问题。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>网络编程</tag>
        <tag>socket</tag>
        <tag>计算机网络</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统02</title>
    <url>/2024/11/11/operating-system-2/</url>
    <content><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>进程是动态的，是程序的一次执行过程，同一个程序多次执行会对应多个进程</p>
<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2024/11/11/ZFzQMLamHjBE7Ob.png" alt="进程的组成.png"></p>
<p>程序段、数据段、PCB三部分组成了进程的实体（进程映像）<br>引入进程实体的概念后，可以把进程定义为：<br>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位</p>
<blockquote>
<p>注意： <code>PCB是进程存在的唯一标识</code></p>
</blockquote>
<h3 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h3><p>当进程被创建时，操作系统会为该进程分配一个<strong>唯一的、不重复</strong>的”身份证号” PID</p>
<p>操作系统要记录PID,进程所属用户ID，还要记录给进程分配了哪些资源、进程的运行情况<br>这些信息都被保存在一个数据结构<code>PCB</code>,即进程控制块，操作系统需要对各个并发运行的进程进行管理，<code>但凡管理时所需要的信息，都会被放在PCB中</code></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2024/11/11/9ZaJQ1iPj8C2VlA.png" alt="PCB.png"></p>
<h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2024/11/11/cfoRVUtBn3hQq7K.png" alt="进程的特征.png"></p>
<p>程序是静态的，进程是动态的，动态性是进程最基本的特征</p>
<h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><pre class="mermaid">flowchart TD
    A[创建态] --&gt;|系统完成创建进程的一系列工作| B[就绪态] --&gt;|进程被调度| C[运行态] --&gt;|进程运行结束,或者运行过程中遇到不可修复的错误| D[终止态]
    C --&gt;|进程用'系统调用'的方式申请某种系统资源,或者请求等待某个事件发生 | E[阻塞态]
    E --&gt;|申请的资源被分配,或等待某个事件发生| B
    C --&gt;|时间片到,或处理机被抢占| B
    B --&gt;|挂起| F[就绪挂起]
    F --&gt;|激活| B
    E --&gt;|挂起| G[阻塞挂起]
    G --&gt;|激活| E
    A --&gt; F
    G --&gt;|事件出现| F
    C --&gt; F</pre>

<p>运行态–&gt;到阻塞态是一种进程自身作出的主动行为<br>阻塞态–&gt;就绪态是不是进程自身能控制的，是一种被动行为</p>
<blockquote>
<p>注意:</p>
<ul>
<li>不能由阻塞态直接转换为运行态，也不能由就绪态直接转换为阻塞态(<code>因为进入阻塞态是进程主动请求的，必然需要进程在运行时才能发出这种请求</code>)</li>
<li>“挂起”和“阻塞”的区别，两种状态都是暂时不能获得CPU的服务，但挂起态是将进程映像调到外存去了，而阻塞态下进程映像还在内存中</li>
</ul>
</blockquote>
<h3 id="创建态"><a href="#创建态" class="headerlink" title="创建态"></a>创建态</h3><p>进程正在被创建时，它的状态是<code>创建态</code>，在这个阶段操作系统会为进程分配资源、初始化PCB</p>
<h3 id="就绪态"><a href="#就绪态" class="headerlink" title="就绪态"></a>就绪态</h3><p>当进程被创建完成后，便进入<code>就绪态</code>，处于就绪态的进程已经具备运行条件，但由于没有空闲CPU,就暂时不能运行</p>
<h3 id="运行态"><a href="#运行态" class="headerlink" title="运行态"></a>运行态</h3><p>如果一个进程此时在CPU上运行，那么这个进程处于<code>运行态</code></p>
<h3 id="阻塞态"><a href="#阻塞态" class="headerlink" title="阻塞态"></a>阻塞态</h3><p>在进程运行的过程中，可能会请求等待某个时间的发生(如等待某种系统资源分配，或者等待其他进程的响应)，在这个事件发生之前，进程无法继续往下执行，此时操作系统会让这个进程下CPU,并让他进入<code>阻塞态</code><br>当CPU空闲时，又会选择另一个<code>就绪态</code>进程上CPU运行</p>
<h3 id="终止态"><a href="#终止态" class="headerlink" title="终止态"></a>终止态</h3><p>一个进程可以执行exit系统调用，请求操作系统终止该进程，此时该进程会进入<code>终止态</code>，操作系统会让该进程下CPU,并回收内存空间等资源，最后还要回收该进程的PCB</p>
<h2 id="进程的组织方式"><a href="#进程的组织方式" class="headerlink" title="进程的组织方式"></a>进程的组织方式</h2><h3 id="链式方式"><a href="#链式方式" class="headerlink" title="链式方式"></a>链式方式</h3><ul>
<li>按照进程状态将PCB分为多个队列</li>
<li>操作系统持有指向各个队列的指针</li>
</ul>
<h3 id="索引方式"><a href="#索引方式" class="headerlink" title="索引方式"></a>索引方式</h3><ul>
<li>根据进程状态的不同，建立几张索引表</li>
<li>操作系统持有指向各个索引表的指针</li>
</ul>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="原语"><a href="#原语" class="headerlink" title="原语"></a>原语</h3><p>原语是一种特殊的程序，它的执行具有原自行。也就是说这段程序的运行必须一气呵成，不可中断</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>可以用“关中断指令”和“开中断指令”实现原子性</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2024/10/13/eSvaALZ4ObCm8Uq.png" alt="原子性.png"></p>
<h3 id="进程控制相关原语"><a href="#进程控制相关原语" class="headerlink" title="进程控制相关原语"></a>进程控制相关原语</h3><h4 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h4><ol>
<li><p>创建原语</p>
<ul>
<li>申请空白PCB</li>
<li>为新进程分配所需资源</li>
<li>初始化PCB</li>
<li>将PCB插入就绪队列 创建态–&gt;就绪态</li>
</ul>
</li>
<li><p>引起进程创建的事件</p>
<ul>
<li>用户登录<ul>
<li>分时系统中，用户登录成功，系统会为其建立一个新进程</li>
<li>作业调度，多道批处理系统，有新的作业放入内存时，会为其建立一个新的进程</li>
<li>提供服务，用户向操作系统提出某些请求时，会新建一个进程处理该请求</li>
<li>应用请求，由用户进程主动请求创建一个子进程</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h4><ol>
<li><p>撤销原语</p>
<ul>
<li>从PCB集合中找到终止进程的PCB</li>
<li>若进程正在运行，立即剥夺CPU,将CPU分配给其他进程</li>
<li>终止其所有子进程</li>
<li>将该进程拥有的所有资源归还给父进程或操作系统</li>
</ul>
</li>
<li><p>引起进程终止的事件</p>
<ul>
<li>正常结束</li>
<li>异常结束</li>
<li>外界干预</li>
</ul>
</li>
</ol>
<h4 id="进程阻塞"><a href="#进程阻塞" class="headerlink" title="进程阻塞"></a>进程阻塞</h4><ol>
<li><p>进程的阻塞</p>
<ul>
<li>阻塞原语 运行态–&gt;阻塞态<ul>
<li>找到要阻塞的进程对应PCB</li>
<li>保护进程运行现场，将PCB状态信息设置为“阻塞态”，展示停止进程运行</li>
<li>将PCB插入相应事件的等待队列</li>
</ul>
</li>
<li>引起进程阻塞的事件<ul>
<li>需要等待系统分配某种资源</li>
<li>需要等待相互合作的其他进程完成工作</li>
</ul>
</li>
</ul>
</li>
<li><p>进程的唤醒</p>
<ul>
<li>唤醒原语<ul>
<li>在事件等待队列中找到PCB</li>
<li>将PCB从等待队列中移除，设置进程为就绪态</li>
<li>将PCB插入就绪队列，等待被调度</li>
</ul>
</li>
<li>引起进程唤醒的事件<ul>
<li>等待事件的发生</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h4><ol>
<li>切换原语<ul>
<li>将运行环境信息存入PCB</li>
<li>PCB移入相应队列</li>
<li>选择另一个进程执行，并更新其PCB</li>
<li>根据PCB恢复新进程所需的运行环境</li>
</ul>
</li>
<li>引起进程切换的事件<ul>
<li>当前进程时间片到</li>
<li>有更高优先级的进程到达</li>
<li>当前进程主动阻塞</li>
<li>当前进程终止</li>
</ul>
</li>
</ol>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><h3 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h3><ul>
<li>基于数据结构的共享: 比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种<strong>低级通信方式</strong></li>
<li>基于存储区的共享: 操作系统在内存中划出一块共享存储区，数据的形式、存放位置都由通信进程控制，而不是操作系统。这种共享方式速度很快，是一种<strong>高级通信方式</strong></li>
</ul>
<h3 id="消息通信"><a href="#消息通信" class="headerlink" title="消息通信"></a>消息通信</h3><ul>
<li>直接通信方式</li>
</ul>
<p>消息传送进程要指明接受进程的ID</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2024/10/19/qUKygHXkmvCuV9E.png" alt="直接通信.png"></p>
<ul>
<li>间接通信方式</li>
</ul>
<p>通过“信箱”间接的通信。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2024/10/19/BthUpkoEsmRxQDc.png" alt="间接通信.png"></p>
<h3 id="管道通信（循环队列）"><a href="#管道通信（循环队列）" class="headerlink" title="管道通信（循环队列）"></a>管道通信（循环队列）</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2024/10/19/2jDbBaEivdwr1Fy.png" alt="管道通信.png"></p>
<p>管道通信和共享存储在于管道通信的读写都是先进先出的</p>
<ol>
<li><p>管道只能采用<strong>半双工通信</strong>，某一之间段内只能采用半双工通信，某一时间段内只能实现单向的传输。如果要实现<strong>双向同时通信</strong>，则<strong>需要设置两个管道</strong></p>
</li>
<li><p>各进程要互斥访问管道（由操作系统实现）</p>
</li>
<li><p>当<strong>管道写满</strong>时，<strong>写进程</strong>将<strong>阻塞</strong>，知道读进程将管道中的数据取走，即可唤醒写进程</p>
</li>
<li><p>当<strong>管道读空</strong>时，<strong>读进程</strong>将<strong>阻塞</strong>，知道写进程往管道写入数据，即可唤醒读进程</p>
</li>
<li><p>管道中的数据一旦被读出，就彻底消失。因此，当多个进程读同一个管道时，可能会错乱。对此，通常有两种解决方案</p>
<ol>
<li><strong>一个管道允许多个写进程，一个读进程</strong></li>
<li>允许有<strong>多个写进程，多个读进程</strong>，但系统会让各个读进程轮流从管道中读数据(linux)</li>
</ol>
</li>
</ol>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h3><p>线程是一个基本的CPU执行单元，也是程序执行流的最小单位</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul>
<li>线程是处理机调度的基本单位</li>
<li>多CPU计算机中，各个县城可占用不同的CPU</li>
<li>每个线程都有一个线程ID、线程控制块(TCB)</li>
<li>线程也有就绪、阻塞、运行三种基本状态</li>
<li>线程几乎不拥有系统资源</li>
<li>同一进程的不同线程间共享进程的资源</li>
<li>由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预</li>
<li>同一进程中的线程切换，不会引起进程切换</li>
<li>不同进程中的线程切换，会引起进程切换</li>
<li>切换同进程内的线程，系统开销很小</li>
<li>切换进程，系统开销比较大</li>
</ul>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><h4 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2024/10/19/PHROKcFw2eoZ6Mz.png" alt="用户级线程.png"></p>
<h4 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a>内核级线程</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2024/10/19/TNZQCUxvphPtOSk.png" alt="内核级线程.png"></p>
<h3 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h3><h4 id="一对一模型"><a href="#一对一模型" class="headerlink" title="一对一模型"></a>一对一模型</h4><p>每个用户级线程都对应一个内核级线程</p>
<ul>
<li><p>优点</p>
<ul>
<li><strong>提高了并发性</strong>：当一个线程进行阻塞系统调用时，其他线程可以继续执行。</li>
<li><strong>更好的并行性</strong>：在多处理器架构中，多线程可在多核处理机上并行执行。</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li><strong>资源消耗较高</strong>：由于每个用户级线程都需要一个内核级线程来对应，这可能会增加系统的开销和复杂度。</li>
</ul>
</li>
</ul>
<h4 id="多对一模型"><a href="#多对一模型" class="headerlink" title="多对一模型"></a>多对一模型</h4><p>在多线程的多对一模型中，多个用户级线程被映射到一个内核级线程上,且一个进程只被分配一个内核级线程上</p>
<ul>
<li><p>优点</p>
<ul>
<li><strong>资源管理效率高</strong>：由于线程管理主要由用户空间的线程库处理，不需要切换到核心态，这使得该模型相对高效。</li>
<li><strong>减少开销</strong>：与一对一模型相比，多对一模型减少了内核级别的上下文切换次数，从而降低了系统开销。</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li><strong>资源竞争严重</strong>：当一个用户级线程进行阻塞系统调用时，所有其他用户级线程都会被阻塞。</li>
</ul>
</li>
</ul>
<h4 id="多对多模型"><a href="#多对多模型" class="headerlink" title="多对多模型"></a>多对多模型</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2024/10/19/8oBOAwD32GZ9qN6.png" alt="多对多模型.png"></p>
<h3 id="线程状态与转换"><a href="#线程状态与转换" class="headerlink" title="线程状态与转换"></a>线程状态与转换</h3><pre class="mermaid">flowchart TD
A[就绪] --&gt;|被调度程序选中| B[运行]
B --&gt;|时间用完| A
B --&gt;|等待某事件| C[阻塞]
C --&gt;|等待的事件发生| A</pre>

<h3 id="线程的组织与控制"><a href="#线程的组织与控制" class="headerlink" title="线程的组织与控制"></a>线程的组织与控制</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2024/10/19/t1ZHYzvU3Ob9Sh6.png" alt="线程的组织与控制.png"></p>
<h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>调度器通过选择就绪队列中的一个进程并将其分配给CPU来实现这一目标。这使得多个进程能够在有限的硬件资源下并发执行，从而提高系统的整体性能和响应速度</p>
<ul>
<li><p><strong>分类与层次</strong>：调度可以根据不同的标准进行分类，通常分为三个层次：</p>
<ul>
<li><strong>高级调度（作业调度）</strong>：决定哪些作业或任务被加载到系统中。</li>
<li><strong>中级调度（内存调度）</strong>：管理进程在主存中的驻留和交换。</li>
<li><strong>低级调度（进程调度或时间片轮转）</strong>：决定当前CPU时间片由哪个进程使用</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>调度类别</th>
<th>要做什么</th>
<th>发生地</th>
<th>发生频率</th>
<th>对进程状态的影响</th>
</tr>
</thead>
<tbody><tr>
<td>高级调度(作业调度)</td>
<td>按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程</td>
<td>外存-&gt;内存(面向作业)</td>
<td>最低</td>
<td>无-&gt;创建态-&gt;就绪态</td>
</tr>
<tr>
<td>中级调度(内存调度)</td>
<td>按照某种规则，从挂起队列中选择合适的进程将其数据回调内存</td>
<td>外存-&gt;内存(面向进程)</td>
<td>中等</td>
<td>挂起态-&gt;就绪态(阻塞挂起-&gt;阻塞态)</td>
</tr>
<tr>
<td>低级调度(进程调度)</td>
<td>按照某种规则，从就绪队列中选择一个进程为其分配处理机</td>
<td>内存-&gt;CPU</td>
<td>最高</td>
<td>就绪态-&gt;运行态</td>
</tr>
</tbody></table>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><p>进程调度（低级调度）就是按照某种算法从就绪队列中选择一个进程为其分配进程</p>
<h3 id="时机"><a href="#时机" class="headerlink" title="时机"></a>时机</h3><p>需要进行进程调度与切换的情况</p>
<ul>
<li><p>当前运行的进程<code>主动放弃</code>处理机</p>
<ul>
<li>进程正常终止</li>
<li>运行过程中发生异常</li>
<li>进程主动请求阻塞</li>
</ul>
</li>
<li><p>当前运行的进程<code>被动放</code>弃处理机</p>
<ul>
<li>分给进程的时间片用完</li>
<li>有更紧急的事需要处理(I/O中断)</li>
<li>有更高优先级的进程进入就绪队列</li>
</ul>
</li>
<li><p>不能进行进程调度与切换情况</p>
<ul>
<li>在处理中断的过程中</li>
<li>进程在操作系统内核临界区中,但是进程在普通临界区中是可以进行调度、切换的</li>
<li>在原子操作过程中。原子操作不可中断，要一气呵成</li>
</ul>
</li>
</ul>
<h2 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h2><p>非剥夺调度方式(非抢占式)</p>
<ul>
<li>一旦某个进程获得了CPU的控制权，它就会一直运行，直到该进程主动放弃CPU（例如，因为等待I/O操作完成或因为进程结束）。在此期间，即使有更高优先级的进程到达，也不会中断当前进程的执行。</li>
</ul>
<p>剥夺调度式(抢占方式)</p>
<ul>
<li>指操作系统可以在任何时刻中断当前正在运行的进程，并将CPU分配给另一个进程。这种中断通常发生在时间片用完、更高优先级的进程到达或某些特定事件发生时。</li>
</ul>
<h2 id="切换与过程"><a href="#切换与过程" class="headerlink" title="切换与过程"></a>切换与过程</h2><blockquote>
<p>注意<br>频繁的进程调度、切换会让整个操作系统效率降低，使系统大部分时间都花在进程切换上，属于进程执行的时间减少了</p>
</blockquote>
<h3 id="切换"><a href="#切换" class="headerlink" title="切换"></a>切换</h3><p>“狭义的进程调度”与“进程切换的区别”</p>
<ul>
<li>狭义的进程调度指的是从就绪队列中选中一个要运行的进程</li>
<li>进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程</li>
</ul>
<p>“广义的进程调度”包含了选择一个进程和进程切换两个步骤</p>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>进程的切换主要完成:</p>
<ul>
<li>对原来运行进程各种数据的保存</li>
<li>对新的进程各种数据的恢复</li>
</ul>
<h2 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a>调度算法的评价指标</h2><h3 id="CPU利用率"><a href="#CPU利用率" class="headerlink" title="CPU利用率"></a>CPU利用率</h3><p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -2.059ex;" xmlns="http://www.w3.org/2000/svg" width="19.85ex" height="5.285ex" role="img" focusable="false" viewBox="0 -1426 8773.6 2336"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">利</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">用</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">率</text></g></g><g data-mml-node="mo" transform="translate(3277.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(4333.6,0)"><g data-mml-node="mrow" transform="translate(220,676)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">忙</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">绿</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g></g><g data-mml-node="mrow" transform="translate(720,-710)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">总</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g></g><rect width="4200" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container></p>
<h3 id="系统吞吐量"><a href="#系统吞吐量" class="headerlink" title="系统吞吐量"></a>系统吞吐量</h3><p>单位时间内完成的作业数量</p>
<p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -2.059ex;" xmlns="http://www.w3.org/2000/svg" width="37.949ex" height="5.285ex" role="img" focusable="false" viewBox="0 -1426 16773.6 2336"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">系</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">统</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">吞</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">吐</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">量</text></g></g><g data-mml-node="mo" transform="translate(5277.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(6333.6,0)"><g data-mml-node="mrow" transform="translate(220,676)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">总</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">共</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">完</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">成</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">了</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">多</text></g><g data-mml-node="mi" transform="translate(6000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">少</text></g><g data-mml-node="mi" transform="translate(7000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">道</text></g><g data-mml-node="mi" transform="translate(8000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">作</text></g><g data-mml-node="mi" transform="translate(9000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">业</text></g></g><g data-mml-node="mrow" transform="translate(1220,-710)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">总</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">共</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">花</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">了</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">多</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">少</text></g><g data-mml-node="mi" transform="translate(6000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(7000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g></g><rect width="10200" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container></p>
<h3 id="周转时间"><a href="#周转时间" class="headerlink" title="周转时间"></a>周转时间</h3><p>从作业被提交给系统开始，到作业完成为止的这段时间间隔</p>
<p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="48.267ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 21334 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(389,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">作</text></g><g data-mml-node="mi" transform="translate(1389,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">业</text></g><g data-mml-node="mo" transform="translate(2389,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(2778,0)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">周</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">转</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g></g><g data-mml-node="mo" transform="translate(7055.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(8111.6,0)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">作</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">业</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">完</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">成</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g></g><g data-mml-node="mo" transform="translate(14333.8,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(15334,0)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">作</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">业</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">提</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">交</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g></g></g></g></svg></mjx-container></p>
<p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -2.059ex;" xmlns="http://www.w3.org/2000/svg" width="37.949ex" height="5.285ex" role="img" focusable="false" viewBox="0 -1426 16773.6 2336"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">平</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">均</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">周</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">转</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g></g><g data-mml-node="mo" transform="translate(6277.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(7333.6,0)"><g data-mml-node="mrow" transform="translate(220,676)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">各</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">作</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">业</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">周</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">转</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(6000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g><g data-mml-node="mi" transform="translate(7000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">之</text></g><g data-mml-node="mi" transform="translate(8000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">和</text></g></g><g data-mml-node="mrow" transform="translate(3220,-710)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">作</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">业</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">数</text></g></g><rect width="9200" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container></p>
<p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -2.059ex;" xmlns="http://www.w3.org/2000/svg" width="69.614ex" height="5.285ex" role="img" focusable="false" viewBox="0 -1426 30769.6 2336"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">带</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">权</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">周</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">转</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g><g data-mml-node="mo" transform="translate(6277.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(7333.6,0)"><g data-mml-node="mrow" transform="translate(1220,676)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">作</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">业</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">周</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">转</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g></g><g data-mml-node="mrow" transform="translate(220,-710)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">作</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">业</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">实</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">际</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">运</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">行</text></g><g data-mml-node="mi" transform="translate(6000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(7000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g></g><rect width="8200" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(16051.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(17107.1,0)"><g data-mml-node="mrow" transform="translate(220,676)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">作</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">业</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">完</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">成</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g><g data-mml-node="mo" transform="translate(6222.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(7222.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">作</text></g><g data-mml-node="mi" transform="translate(8222.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">业</text></g><g data-mml-node="mi" transform="translate(9222.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">提</text></g><g data-mml-node="mi" transform="translate(10222.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">交</text></g><g data-mml-node="mi" transform="translate(11222.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(12222.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g></g><g data-mml-node="mrow" transform="translate(2831.2,-710)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">作</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">业</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">实</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">际</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">运</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">行</text></g><g data-mml-node="mi" transform="translate(6000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(7000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g></g><rect width="13422.4" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container></p>
<blockquote>
<p>注意<br>带权周转时间必然&gt;=1</p>
</blockquote>
<p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -2.059ex;" xmlns="http://www.w3.org/2000/svg" width="46.999ex" height="5.285ex" role="img" focusable="false" viewBox="0 -1426 20773.6 2336"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">平</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">均</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">带</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">权</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">周</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">转</text></g><g data-mml-node="mi" transform="translate(6000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(7000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g><g data-mml-node="mo" transform="translate(8277.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(9333.6,0)"><g data-mml-node="mrow" transform="translate(220,676)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">各</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">作</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">业</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">带</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">权</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">周</text></g><g data-mml-node="mi" transform="translate(6000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">转</text></g><g data-mml-node="mi" transform="translate(7000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(8000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g><g data-mml-node="mi" transform="translate(9000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">之</text></g><g data-mml-node="mi" transform="translate(10000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">和</text></g></g><g data-mml-node="mrow" transform="translate(4220,-710)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">作</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">业</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">数</text></g></g><rect width="11200" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container></p>
<h3 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h3><p>从用户提交请求到首次产生响应的时间</p>
<h2 id="进程同步和互斥"><a href="#进程同步和互斥" class="headerlink" title="进程同步和互斥"></a>进程同步和互斥</h2><h4 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h4><p>同步也叫直接制约关系，是指为完成某种任务而建立的两个或多个进程，这些进程是因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作</p>
<h4 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h4><p>我们把<code>一个时间段内只允许一个进程</code>使用的资源叫做<code>临界资源</code><br>进程互斥是指当一个进程访问某个临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源</p>
<p>对进程的互斥访问:</p>
<ul>
<li>进入区：负责检查是否可进入临界区，若可进入，则设置”正在访问临界资源标志”</li>
<li>临界区：访问临界资源的那段代码</li>
<li>退出区：负责解除“正在访问临界资源的标志”（解锁）</li>
<li>剩余区：其他处理</li>
</ul>
<blockquote>
<p>注意</p>
<ul>
<li>临界区是进程中访问临界资源的代码段</li>
<li>进入区和退出区是负责实现互斥的代码段</li>
<li>临界区可称为”临界段”</li>
</ul>
</blockquote>
<p>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则:</p>
<ol>
<li>空闲让进: 临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区</li>
<li>忙则等待: 当已有进程进入临界区时，其他试图进入临界区的进程必须等待</li>
<li>有限等待: 对请求访问的进程，应保证能在有限时间内进入临界区</li>
<li>让权等待: 当进程不能进入临界区，应立即释放处理机，防止进程忙等待</li>
</ol>
<h4 id="进程互斥的软件实现方法"><a href="#进程互斥的软件实现方法" class="headerlink" title="进程互斥的软件实现方法"></a>进程互斥的软件实现方法</h4><h5 id="单步标志法"><a href="#单步标志法" class="headerlink" title="单步标志法"></a>单步标志法</h5><p>单标志法的算法思想是：两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予。具体实现过程如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> turn = <span class="number">0</span>; <span class="comment">//表示当前允许进入临界区的进程号</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P1</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">while</span>(turn != <span class="number">0</span>) { <span class="comment">// 进入区</span></span><br><span class="line">        <span class="comment">// critical section 临界区</span></span><br><span class="line">        turn = <span class="number">1</span>; <span class="comment">// 退出区</span></span><br><span class="line">        <span class="comment">// remainder seciont  剩余区</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P2</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">while</span>(turn != <span class="number">1</span>) {</span><br><span class="line">        <span class="comment">// critical section</span></span><br><span class="line">        turn = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// remainder seciont</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>对于turn表示当前允许进入临界区的进程号，而只有当前允许进入临界区的进程在访问了临界区之后，才会修改turn的值。也就是说，对于临界区的访问，一定是按p0→p1→p0→p1…这样轮流访问。</p>
<p>这种必须轮流访问带来的问题是，如果此时允许进入临界区的进程是P0，而P0一直不访问临界区，那么虽然此时临界区空闲，但是并不允许P1访问。因此对于单标志法，其违背了空闲让进的原则。</p>
<h5 id="双标志先检查法"><a href="#双标志先检查法" class="headerlink" title="双标志先检查法"></a>双标志先检查法</h5><p>双标志先检查法的算法思想是：设置一个布尔型数组flag[]，数组中各个元素用来标记各进程想进入临界区的意愿，比如flag[0] = true意味着0号进程p0现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志flag[i]设为true，之后开始访问临界区。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>] = {<span class="literal">false</span>, <span class="literal">false</span>};</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P1</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">while</span>(flag[<span class="number">1</span>] );  <span class="comment">// 1</span></span><br><span class="line">    flag[<span class="number">0</span>] = <span class="literal">true</span>; <span class="comment">// 2</span></span><br><span class="line">    <span class="comment">//critical section // 3</span></span><br><span class="line">    flag[<span class="number">0</span>] = <span class="literal">false</span>; <span class="comment">// 4</span></span><br><span class="line">    <span class="comment">//remainder section</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P2</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">while</span>(flag[<span class="number">0</span>]); <span class="comment">// 5</span></span><br><span class="line">    flag[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 6</span></span><br><span class="line">    <span class="comment">//critical section // 7</span></span><br><span class="line">    flag[<span class="number">1</span>] = <span class="literal">false</span>; <span class="comment">// 8</span></span><br><span class="line">    <span class="comment">//remainder section</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>需要注意的是，如果按照152637的顺序执行，p0和p1将会同时访问临界区。因此对于双标志先检查法，其违背了忙则等待的原则。</p>
<p>之所以造成这种问题，就是因为进入区的检查和上锁不是原子操作，在检查完的下一步还没上锁很有可能发生其他事件。</p>
<h5 id="双标志后检查法"><a href="#双标志后检查法" class="headerlink" title="双标志后检查法"></a>双标志后检查法</h5><p>双标志后检查法的思想是：既然先检查后上锁不行，那我就先上锁，然后在检查。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>] = {<span class="literal">false</span>, <span class="literal">false</span>};</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P0</span><span class="params">()</span> {</span><br><span class="line">    flag[<span class="number">0</span>] = <span class="literal">true</span>; <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">while</span>(flag[<span class="number">1</span>]); <span class="comment">// 2</span></span><br><span class="line">    <span class="comment">//critical section // 3</span></span><br><span class="line">    flag[<span class="number">0</span>] = <span class="literal">false</span>; <span class="comment">// 4</span></span><br><span class="line">    <span class="comment">//remainder section</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P1</span><span class="params">()</span> {</span><br><span class="line">    flag[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 5</span></span><br><span class="line">    <span class="keyword">while</span>(flag[<span class="number">0</span>]); <span class="comment">// 6</span></span><br><span class="line">    <span class="comment">//critical section // 7</span></span><br><span class="line">    flag[<span class="number">1</span>] = <span class="literal">false</span>; <span class="comment">// 8</span></span><br><span class="line">    <span class="comment">//remainder section</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>需要注意的是，如果按照1526的顺序执行，p0和p1将都无法进入临界区。</p>
<p>因此双标志后检查法虽然解决了忙则等待的问题，但是又违背了空闲让进和有限等待原则，因为如果各进程都长期无法访问临界资源会产生饥饿现象。</p>
<h5 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h5><p>在双标志后检查法中，两个进程都争着想进入临界区，但是谁也不让谁，既然这样，那只需要有人礼让即可解决问题。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>] = {<span class="literal">false</span>, <span class="literal">false</span>};</span><br><span class="line"><span class="type">int</span> turn = <span class="number">0</span>; <span class="comment">// 表示优先让哪个进程进入临界区</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P0</span><span class="params">()</span> {</span><br><span class="line">    flag[<span class="number">0</span>] = <span class="literal">true</span>; <span class="comment">// 1</span></span><br><span class="line">    turn = <span class="number">1</span>; <span class="comment">// 2  可以让对方先进入临界区</span></span><br><span class="line">    <span class="keyword">while</span>(flag[<span class="number">1</span>] &amp;&amp; turn == <span class="number">1</span>); <span class="comment">// 3</span></span><br><span class="line">    <span class="comment">//critical section // 4</span></span><br><span class="line">    flag[<span class="number">0</span>] = <span class="literal">false</span>; <span class="comment">// 5</span></span><br><span class="line">    <span class="comment">//remainder section</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P1</span><span class="params">()</span> {</span><br><span class="line">    flag[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 6</span></span><br><span class="line">    turn = <span class="number">0</span>; <span class="comment">// 7</span></span><br><span class="line">    <span class="keyword">while</span>(flag[<span class="number">0</span>] &amp;&amp; turn == <span class="number">0</span>); <span class="comment">// 8</span></span><br><span class="line">    <span class="comment">//critical section // 9</span></span><br><span class="line">    flag[<span class="number">1</span>] = <span class="literal">false</span>; <span class="comment">// 10</span></span><br><span class="line">    <span class="comment">//remainder section</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>如果按照123678的顺序，则相当于串行执行，这种方式肯定可以执行。</p>
<p>如果按照162378的顺序，那么进程0表明自己想进入临界区，进程1表明自己想进入临界区，回到2步骤，0进程表示愿意先让给1进程执行，然后在检查1也有意愿进入临界区和自己已经让位的情况下，自己处于等待状态。这时候回到7步骤，1号进程也表示自己愿意先让给0进程执行，然后在检查0也有意愿进入临界区和自己已经让位的情况下，自己也处于等待状态。此时回到步骤3，0号进程发现turn被修改为0了，说明自己可以不用等待让位了，先行一步作为后回到步骤8，进程P1也顺利做完了。</p>
<p>尽管Peterson算法用软件方法解决了进程互斥问题，遵循了空闲让进、忙则等待、有限等待三个原则，但是依然未遵循让权等待原则。但是相较于前面三种算法，其本身已然是最好</p>
<h4 id="进程互斥的硬件实现方法"><a href="#进程互斥的硬件实现方法" class="headerlink" title="进程互斥的硬件实现方法"></a>进程互斥的硬件实现方法</h4><h5 id="中断屏蔽方法"><a href="#中断屏蔽方法" class="headerlink" title="中断屏蔽方法"></a>中断屏蔽方法</h5><h6 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h6><p>中断屏蔽是指在某个进程或中断处理程序进入临界区之前，暂时禁止系统接收新的中断请求。这样做的目的是确保当前进程在执行临界区代码时不会被其他中断处理程序打断，从而避免并发访问导致的数据不一致问题。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2024/11/02/Yj3DG4NtRFrImzf.png" alt="中断屏蔽方法.png"></p>
<h5 id="TestAndSet指令"><a href="#TestAndSet指令" class="headerlink" title="TestAndSet指令"></a>TestAndSet指令</h5><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2024/11/02/I3zMS9iCoHJnc6v.png" alt="TestAndSet.png"></p>
<p>优点：</p>
<ul>
<li>实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞，适用于多处理机环境</li>
</ul>
<p>缺点:</p>
<ul>
<li>忙等待：未获取锁的线程会不断循环等待，占用 CPU 资源，影响系统性能。</li>
<li>不适合长时间临界区：对于长时间的临界区访问，忙等待会导致 CPU 资源浪费。</li>
<li>多处理机环境：在多处理机系统中，TAS 指令只能确保当前处理器上的同步，无法阻止其他处理器上的线程访问共享资源。</li>
</ul>
<h5 id="swap指令"><a href="#swap指令" class="headerlink" title="swap指令"></a>swap指令</h5><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2024/11/02/ZuNwMVpD6YsLioq.png" alt="swap指令.png"></p>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>一个进程在进入临界区时应获得锁，在推出临界区时释放锁。函数<code>acquire</code>获得锁，函数<code>release</code>释放锁。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">acquire() {</span><br><span class="line">    <span class="keyword">while</span> (!available);</span><br><span class="line">    available = <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line">release() {</span><br><span class="line">    available = <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>注意<br>acquire() 和 release() 函数都是原子操作，因此互斥锁通常采用硬件机制实现</p>
</blockquote>
<p>特性：</p>
<ul>
<li><p>优点：</p>
<ul>
<li>等待期间不用切换进程上下文，多处理器系统中，若上锁的时间短，则等待代价很低</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>需忙等，进程时间片用完才下处理机，违反“让权等待”</li>
<li>忙等待： 当有一个进程在临界区中，任何其他进程在进入临界区时必须连续循环调用<code>acquire()</code>。当多个进程共享统一CPU时，就浪费了CPU周期。</li>
</ul>
</li>
<li><p>常用于多处理器系统，一个核忙等，其他核照常工作，并快速释放临界区</p>
</li>
<li><p>不太适用于但处理机系统，忙等的过程中不可能解锁</p>
</li>
</ul>
<h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><p>信号量是一个整数值，通常用于表示可用资源的数量。它可以分为两种类型：</p>
<ul>
<li>整型信号量最初Dijkstra把整型信号量定义为一个用于表示资源数目的整型量S，它与一般的整型量不同，除初始化外，仅能通过两个标准原子操作（Atomic Operation）wait(S)和signal(S)操作可以描述为：</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> S = <span class="number">1</span>; <span class="comment">// 表示当前系统中可用的资源数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> S)</span>: <span class="comment">// wait原语，相当于进入区</span></span><br><span class="line">    <span class="title function_">while</span><span class="params">(S&lt;=<span class="number">0</span>)</span>; <span class="comment">// 如果资源数不够就循环等待</span></span><br><span class="line">    S = S - <span class="number">1</span>; <span class="comment">// 如果资源数够，就占用一个资源</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal</span> <span class="params">(<span class="type">int</span> S)</span>: <span class="comment">// signal原语，相当于退出区</span></span><br><span class="line">    S = S + <span class="number">1</span>; <span class="comment">// 使用完资源后，在退出区释放资源</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<ul>
<li>记录型信号量在整型信号量机制中的wait操作，只要是信号量S&lt;=0,就会不断测试。因此，该机制并未遵循“让权等待”准则，而是使进程处于“忙等”状态。记录型信号量机制则是一种不存在“忙等”现象的进程同步机制。但在采取了“让权等待”的策略后，又会出现多个进程等待访问同一个临界资源的情况。为此，在信号量机制中，除了需要一个用于代表资源数目的整型变量value外，还应该增加一个进程链表指针L，用于链接上述的所有等待进程。记录型信号量是由于它采用了记录型的数据结构而得名的。它所包含的上述两个数据项可以描述为：type semaphore=recordvalue:integerL:list of process;end相应的，wait(S)和signal(S)的操作可描述为</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="type">int</span> value; <span class="comment">// 剩余资源数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">L</span>;</span> <span class="comment">// 等待队列</span></span><br><span class="line">} semaphore;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">wait</span><span class="params">(semaphore S)</span> {</span><br><span class="line">    S.value --;</span><br><span class="line">    <span class="keyword">if</span>(S.value &lt; <span class="number">0</span>) {</span><br><span class="line">        block(S.L); <span class="comment">// 如果资源数量不够，就用block将进程从运行态进入阻塞态，并把挂到信号量S的等待队列中</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal</span><span class="params">(semaphore S)</span> {</span><br><span class="line">    S.value ++;</span><br><span class="line">    <span class="keyword">if</span>(S.value &lt;= <span class="number">0</span>) {</span><br><span class="line">        wakeup(S.L); <span class="comment">// 释放资源后，若还有别的进程在等待这种资源，则使用wakeup唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h4 id="操作机制"><a href="#操作机制" class="headerlink" title="操作机制"></a>操作机制</h4><p>信号量机制主要通过两个操作来实现：</p>
<ul>
<li><p>P操作（wait）：<br>当进程想要进入临界区时，它会执行P操作，将信号量的值减1。<br>如果减1后信号量的值大于或等于0，进程可以继续执行；如果小于0，进程会被阻塞，进入等待队列。</p>
</li>
<li><p>V操作（signal）：<br>当进程离开临界区时，它会执行V操作，将信号量的值加1。<br>如果有其他进程在等待该信号量，则其中一个等待的进程将被唤醒。</p>
</li>
</ul>
<h4 id="实现进程互斥"><a href="#实现进程互斥" class="headerlink" title="实现进程互斥"></a>实现进程互斥</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2024/11/04/EbnIucekK2zmo6U.png" alt="信号量实现进程互斥.png"></p>
<ol>
<li><p><strong>定义信号量</strong>：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>; <span class="comment">// 初始化互斥信号量</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>进入临界区前的操作（P操作）</strong>：<br>在进程要访问临界区之前，必须执行P（wait）操作以请求对资源的访问。这一操作会将信号量的值减1：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">P(mutex); <span class="comment">// 请求进入临界区</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>临界区代码</strong>：<br>进程在临界区内执行需要互斥访问的代码。此时，其他进程无法进入该区域。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 临界区代码段</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>离开临界区后的操作（V操作）</strong>：<br>当进程完成对共享资源的访问后，必须执行V（signal）操作来释放资源，将信号量的值加1，从而允许其他等待的进程进入临界区：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">V(mutex); <span class="comment">// 释放临界区</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<h5 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h5><p>以下是一个简单的示例，展示了如何使用信号量实现进程互斥：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>; <span class="comment">// 初始化信号量为1</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">process1</span><span class="params">()</span> {</span><br><span class="line">    P(mutex); <span class="comment">// 请求进入临界区</span></span><br><span class="line">    <span class="comment">// 临界区代码段...</span></span><br><span class="line">    V(mutex); <span class="comment">// 离开临界区</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">process2</span><span class="params">()</span> {</span><br><span class="line">    P(mutex); <span class="comment">// 请求进入临界区</span></span><br><span class="line">    <span class="comment">// 临界区代码段...</span></span><br><span class="line">    V(mutex); <span class="comment">// 离开临界区</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h5 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h5><ul>
<li><strong>互斥性</strong>：通过将信号量初值设置为1，确保同一时间只能有一个进程进入临界区。</li>
<li><strong>阻塞与唤醒</strong>：如果一个进程在执行P操作时发现信号量值为0，则该进程会被阻塞，直到其他进程执行V操作并唤醒它。</li>
<li><strong>原子性</strong>：P和V操作通常被实现为原子操作，以防止中断，从而避免竞争条件。</li>
</ul>
<h4 id="实现进程同步"><a href="#实现进程同步" class="headerlink" title="实现进程同步"></a>实现进程同步</h4><ol>
<li><p><strong>分析同步需求</strong>：<br>确定哪些操作需要同步，即需要保证某些操作按顺序执行。例如，若进程P1的某个操作必须在进程P2的操作之前完成，则需要实现同步。</p>
</li>
<li><p><strong>设置同步信号量</strong>：<br>创建一个信号量，初始值设置为0。这个信号量用于控制两个或多个操作之间的顺序。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">semaphore sync = <span class="number">0</span>; <span class="comment">// 初始化同步信号量为0</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>在“前操作”后执行V操作</strong>：<br>在需要确保先执行的操作完成后，调用V操作以释放信号量。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前操作代码</span></span><br><span class="line">V(sync); <span class="comment">// 释放信号量</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>在“后操作”前执行P操作</strong>：<br>在需要确保后执行的代码之前，调用P操作以请求信号量。如果信号量值为0，则当前进程会被阻塞，直到其他进程释放该信号量。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">P(sync); <span class="comment">// 请求信号量</span></span><br><span class="line"><span class="comment">// 后操作代码</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<h5 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h5><p>以下是一个简单示例，展示如何使用信号量实现两个进程之间的同步：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">semaphore sync = <span class="number">0</span>; <span class="comment">// 初始化同步信号量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">process1</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// 执行前操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    V(sync); <span class="comment">// 完成前操作，释放信号量</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">process2</span><span class="params">()</span> {</span><br><span class="line">    P(sync); <span class="comment">// 请求信号量，等待process1完成前操作</span></span><br><span class="line">    <span class="comment">// 执行后操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h5 id="关键点-1"><a href="#关键点-1" class="headerlink" title="关键点"></a>关键点</h5><ul>
<li><strong>阻塞与唤醒</strong>：通过设置初始值为0，可以确保在执行后续操作之前，相关进程必须先完成其前置条件。</li>
<li><strong>避免竞争条件</strong>：使用信号量可以有效避免由于并发执行导致的数据不一致问题。</li>
</ul>
<p>通过以上步骤和机制，信号量能够有效地实现进程之间的同步，使得多个并发进程能够按照预定顺序有序地推进。</p>
<h4 id="信号量机制实现前驱关系"><a href="#信号量机制实现前驱关系" class="headerlink" title="信号量机制实现前驱关系"></a>信号量机制实现前驱关系</h4><p>信号量机制可以有效地处理进程之间的前驱关系，确保某些操作在其他操作之前完成。以下是信号量如何实现前驱关系的基本原理和步骤。</p>
<h5 id="前驱关系的定义"><a href="#前驱关系的定义" class="headerlink" title="前驱关系的定义"></a>前驱关系的定义</h5><p>前驱关系指的是在多个进程或操作中，某个操作的执行必须依赖于另一个操作的完成。例如，如果操作S1必须在操作S2之前完成，则可以表示为S1 -&gt; S2。</p>
<h5 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h5><ol>
<li><p><strong>设置信号量</strong>：<br>为每个需要同步的操作设置一个信号量，初始值为0。这表示该操作在执行之前必须等待其前驱操作完成。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">semaphore a1 = <span class="number">0</span>; <span class="comment">// 用于S1 -&gt; S2</span></span><br><span class="line">semaphore a2 = <span class="number">0</span>; <span class="comment">// 用于S1 -&gt; S3</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>执行前驱操作并释放信号量</strong>：<br>在前驱操作（如S1）完成后，调用V操作释放相应的信号量，以通知其他进程可以继续执行。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">S1</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// 执行S1的代码</span></span><br><span class="line">    V(a1); <span class="comment">// 通知S2可以执行</span></span><br><span class="line">    V(a2); <span class="comment">// 通知S3可以执行</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>在后续操作中请求信号量</strong>：<br>在每个后续操作（如S2和S3）开始之前，调用P操作请求相应的信号量。如果信号量值为0，进程将被阻塞，直到前驱操作完成并释放信号量。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">S2</span><span class="params">()</span> {</span><br><span class="line">    P(a1); <span class="comment">// 等待S1完成</span></span><br><span class="line">    <span class="comment">// 执行S2的代码</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">S3</span><span class="params">()</span> {</span><br><span class="line">    P(a2); <span class="comment">// 等待S1完成</span></span><br><span class="line">    <span class="comment">// 执行S3的代码</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>继续后续操作</strong>：<br>后续操作（如S4、S5、S6等）也可以使用类似的方法进行同步，确保它们在适当的时候执行。</p>
</li>
</ol>
<h5 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h5><p>以下是一个完整示例，展示了如何使用信号量实现多个进程之间的前驱关系：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">semaphore a1 = <span class="number">0</span>; <span class="comment">// S1 -&gt; S2</span></span><br><span class="line">semaphore a2 = <span class="number">0</span>; <span class="comment">// S1 -&gt; S3</span></span><br><span class="line">semaphore b1 = <span class="number">0</span>; <span class="comment">// S2 -&gt; S4</span></span><br><span class="line">semaphore b2 = <span class="number">0</span>; <span class="comment">// S2 -&gt; S5</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">S1</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// 执行S1的代码</span></span><br><span class="line">    V(a1); <span class="comment">// 通知S2可以执行</span></span><br><span class="line">    V(a2); <span class="comment">// 通知S3可以执行</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">S2</span><span class="params">()</span> {</span><br><span class="line">    P(a1); <span class="comment">// 等待S1完成</span></span><br><span class="line">    <span class="comment">// 执行S2的代码</span></span><br><span class="line">    V(b1); <span class="comment">// 通知S4可以执行</span></span><br><span class="line">    V(b2); <span class="comment">// 通知S5可以执行</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">S3</span><span class="params">()</span> {</span><br><span class="line">    P(a2); <span class="comment">// 等待S1完成</span></span><br><span class="line">    <span class="comment">// 执行S3的代码</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">S4</span><span class="params">()</span> {</span><br><span class="line">    P(b1); <span class="comment">// 等待S2完成</span></span><br><span class="line">    <span class="comment">// 执行S4的代码</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">S5</span><span class="params">()</span> {</span><br><span class="line">    P(b2); <span class="comment">// 等待S2完成</span></span><br><span class="line">    <span class="comment">// 执行S5的代码</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h3><p>生产者消费者问题是一个经典的进程同步问题，描述了两个进程（生产者和消费者）如何在共享缓冲区中安全地交互。以下是对该问题的详细介绍，包括其背景、问题描述、解决方案及实现方式。</p>
<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>在生产者消费者模型中，生产者负责生成数据并将其放入共享缓冲区，而消费者则从缓冲区中取出数据进行消费。关键在于要确保：</p>
<ul>
<li><strong>缓冲区不满</strong>：当缓冲区已满时，生产者必须等待，直到消费者消费了数据。</li>
<li><strong>缓冲区不空</strong>：当缓冲区为空时，消费者必须等待，直到生产者生成了数据。</li>
</ul>
<p>这种模型确保了生产者和消费者之间的协调，避免了数据丢失或错误读取的情况。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="使用信号量"><a href="#使用信号量" class="headerlink" title="使用信号量"></a>使用信号量</h5><p>信号量是一种用于进程间同步的机制，可以有效地解决生产者消费者问题。通常需要使用两个信号量：</p>
<ul>
<li><strong>freeSpace</strong>：表示缓冲区中可用的空位数量。</li>
<li><strong>usedSpace</strong>：表示缓冲区中已用的产品数量。</li>
</ul>
<h5 id="伪代码示例"><a href="#伪代码示例" class="headerlink" title="伪代码示例"></a>伪代码示例</h5><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">semaphore freeSpace = N; <span class="comment">// N为缓冲区大小</span></span><br><span class="line">semaphore usedSpace = <span class="number">0</span>; <span class="comment">// 初始时没有产品</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">producer</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        produceItem(); <span class="comment">// 生产一个产品</span></span><br><span class="line">        P(freeSpace); <span class="comment">// 请求一个空位</span></span><br><span class="line">        putItemIntoBuffer(); <span class="comment">// 将产品放入缓冲区</span></span><br><span class="line">        V(usedSpace); <span class="comment">// 增加已用产品计数</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">consumer</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        P(usedSpace); <span class="comment">// 请求一个已用产品</span></span><br><span class="line">        getItemFromBuffer(); <span class="comment">// 从缓冲区获取产品</span></span><br><span class="line">        V(freeSpace); <span class="comment">// 增加空位计数</span></span><br><span class="line">        consumeItem(); <span class="comment">// 消费该产品</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h5 id="使用互斥锁和条件变量"><a href="#使用互斥锁和条件变量" class="headerlink" title="使用互斥锁和条件变量"></a>使用互斥锁和条件变量</h5><p>在多生产者和多消费者的情况下，可以使用互斥锁和条件变量来实现更复杂的同步机制。互斥锁用于保护对共享资源的访问，而条件变量则用于在特定条件下阻塞和唤醒线程。</p>
<h5 id="伪代码示例-1"><a href="#伪代码示例-1" class="headerlink" title="伪代码示例"></a>伪代码示例</h5><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">mutex lock;</span><br><span class="line">condition_variable notFull, notEmpty;</span><br><span class="line"><span class="type">int</span> buffer[N]; <span class="comment">// 缓冲区</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 当前产品数量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">producer</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        produceItem();</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">while</span> (count == N) {</span><br><span class="line">            notFull.wait(lock); <span class="comment">// 等待直到有空位</span></span><br><span class="line">        }</span><br><span class="line">        buffer[count++] = item; <span class="comment">// 放入产品</span></span><br><span class="line">        notEmpty.notify_one(); <span class="comment">// 通知消费者有新产品</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">consumer</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) {</span><br><span class="line">            notEmpty.wait(lock); <span class="comment">// 等待直到有产品可消费</span></span><br><span class="line">        }</span><br><span class="line">        item = buffer[--count]; <span class="comment">// 获取产品</span></span><br><span class="line">        notFull.notify_one(); <span class="comment">// 通知生产者有空位</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">        consumeItem(item);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>这是一个cpp实例</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProducerConsumer</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ProducerConsumer</span>(<span class="type">int</span> maxSize) : <span class="built_in">maxSize_</span>(maxSize), <span class="built_in">running_</span>(<span class="literal">true</span>) {}</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">startProducers</span><span class="params">(<span class="type">int</span> numProducers)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numProducers; ++i) {</span><br><span class="line">            producers_.<span class="built_in">emplace_back</span>(&amp;ProducerConsumer::producer, <span class="keyword">this</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">startConsumers</span><span class="params">(<span class="type">int</span> numConsumers)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numConsumers; ++i) {</span><br><span class="line">            consumers_.<span class="built_in">emplace_back</span>(&amp;ProducerConsumer::consumer, <span class="keyword">this</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span> </span>{</span><br><span class="line">        running_ = <span class="literal">false</span>;</span><br><span class="line">        cv_.<span class="built_in">notify_all</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;producer : producers_) {</span><br><span class="line">            producer.<span class="built_in">join</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;consumer : consumers_) {</span><br><span class="line">            consumer.<span class="built_in">join</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (running_) {</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">            cv_.<span class="built_in">wait</span>(lk, [&amp;] { <span class="keyword">return</span> buffer_.<span class="built_in">size</span>() &lt; maxSize_ || !running_; });</span><br><span class="line">            <span class="keyword">if</span> (!running_) <span class="keyword">break</span>;</span><br><span class="line">            buffer_.<span class="built_in">push</span>(res_[(index++) % res_.<span class="built_in">size</span>()]);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"Producer pushed: "</span> &lt;&lt; res_[(index - <span class="number">1</span>) % res_.<span class="built_in">size</span>()] &lt;&lt; std::endl;</span><br><span class="line">            cv_.<span class="built_in">notify_all</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (running_) {</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">            cv_.<span class="built_in">wait</span>(lk, [&amp;] { <span class="keyword">return</span> !buffer_.<span class="built_in">empty</span>() || !running_; });</span><br><span class="line">            <span class="keyword">if</span> (!running_ &amp;&amp; buffer_.<span class="built_in">empty</span>()) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (!buffer_.<span class="built_in">empty</span>()) {</span><br><span class="line">                <span class="keyword">auto</span> front = buffer_.<span class="built_in">front</span>();</span><br><span class="line">                buffer_.<span class="built_in">pop</span>();</span><br><span class="line">                std::cout &lt;&lt; <span class="string">"Consumer got: "</span> &lt;&lt; front &lt;&lt; std::endl;</span><br><span class="line">            }</span><br><span class="line">            cv_.<span class="built_in">notify_all</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> std::array&lt;std::string, 5&gt; res_{<span class="string">"awd"</span>, <span class="string">"1"</span>, <span class="string">"awdjkgdfh"</span>, <span class="string">"encounter"</span>, <span class="string">"dwadawd"</span>};</span><br><span class="line">    std::queue&lt;std::string&gt; buffer_;</span><br><span class="line">    std::condition_variable cv_;</span><br><span class="line">    std::mutex mtx_;</span><br><span class="line">    <span class="type">int</span> maxSize_;</span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; running_;</span><br><span class="line">    std::vector&lt;std::thread&gt; producers_;</span><br><span class="line">    std::vector&lt;std::thread&gt; consumers_;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">ProducerConsumer <span class="title">pc</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    pc.<span class="built_in">startProducers</span>(<span class="number">3</span>);</span><br><span class="line">    pc.<span class="built_in">startConsumers</span>(<span class="number">3</span>);</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">    pc.<span class="built_in">stop</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>生产者消费者问题展示了多线程编程中的同步与互斥的重要性。通过使用信号量、互斥锁和条件变量等机制，可以有效地管理进程之间的协作，确保数据的一致性与完整性。该模型不仅适用于单一生产者和消费者，也可以扩展到多个生产者和消费者的场景中，为并发编程提供了重要的理论基础和实践指导。</p>
<h3 id="读者写者问题"><a href="#读者写者问题" class="headerlink" title="读者写者问题"></a>读者写者问题</h3><p>读者写者问题是操作系统中的经典同步问题，涉及多个进程对共享资源的访问控制。其主要目标是确保在读者和写者之间实现有效的互斥，以避免数据不一致性。</p>
<h4 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h4><p>在读者写者问题中，有两类进程：</p>
<ul>
<li><strong>读者进程</strong>：只读取共享数据，不修改它。</li>
<li><strong>写者进程</strong>：可以读取和修改共享数据。</li>
</ul>
<h4 id="主要要求"><a href="#主要要求" class="headerlink" title="主要要求"></a>主要要求</h4><ol>
<li><strong>允许多个读者同时进行读操作</strong>：多个读者可以并行访问共享资源而不会发生冲突。</li>
<li><strong>只允许一个写者进行写操作</strong>：在任何写操作进行时，必须确保没有其他读者或写者同时访问该资源。</li>
<li><strong>互斥访问</strong>：在写者执行写操作之前，必须等待所有当前的读者和写者完成他们的操作。</li>
</ol>
<h4 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h4><h5 id="1-读者优先"><a href="#1-读者优先" class="headerlink" title="1. 读者优先"></a>1. 读者优先</h5><p>在这种策略下，系统优先允许读者访问共享资源。若有持续不断的读者请求，可能会导致写者饿死，即无法获得执行机会。这种策略简单易实现，但在高并发情况下可能导致写入延迟。</p>
<h5 id="2-写者优先"><a href="#2-写者优先" class="headerlink" title="2. 写者优先"></a>2. 写者优先</h5><p>此策略确保写者能够尽快执行其操作。在这种情况下，如果有待处理的写请求，则后续的读请求将被阻塞。这种策略可以减少写者的饥饿现象，但可能导致读者的延迟。</p>
<h4 id="解决方案示例"><a href="#解决方案示例" class="headerlink" title="解决方案示例"></a>解决方案示例</h4><p>一种常见的解决方案是使用信号量来控制对共享资源的访问。信号量提供了两种基本操作：</p>
<ul>
<li><strong>P（proberen）</strong>：请求资源，若资源不可用则阻塞。</li>
<li><strong>V（verhogen）</strong>：释放资源，唤醒等待的进程。</li>
</ul>
<p>以下是一个简化的伪代码示例：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化信号量</span></span><br><span class="line">Semaphore readCountMutex = <span class="number">1</span>; <span class="comment">// 控制读计数器</span></span><br><span class="line">Semaphore resourceMutex = <span class="number">1</span>;   <span class="comment">// 控制对共享资源的访问</span></span><br><span class="line">Semaphore writeMUtex = <span class="number">1</span>;   <span class="comment">// 用于实现"写优先"</span></span><br><span class="line"><span class="type">int</span> readCount = <span class="number">0</span>;             <span class="comment">// 当前读取进程数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读者进程</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">reader</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) {</span><br><span class="line">        P(writeMutex);</span><br><span class="line">        P(readCountMutex);          <span class="comment">// 获取读计数器锁</span></span><br><span class="line">        <span class="keyword">if</span> (readCount == <span class="number">1</span>) {</span><br><span class="line">            P(resourceMutex);       <span class="comment">// 第一个读者获取资源锁</span></span><br><span class="line">        }</span><br><span class="line">        readCount++;</span><br><span class="line">        V(readCountMutex);          <span class="comment">// 释放读计数器锁</span></span><br><span class="line">        V(writeMutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行读取操作</span></span><br><span class="line"></span><br><span class="line">        P(readCountMutex);          <span class="comment">// 获取读计数器锁</span></span><br><span class="line">        readCount--;</span><br><span class="line">        <span class="keyword">if</span> (readCount == <span class="number">0</span>) {</span><br><span class="line">            V(resourceMutex);       <span class="comment">// 最后一个读者释放资源锁</span></span><br><span class="line">        }</span><br><span class="line">        V(readCountMutex);          <span class="comment">// 释放读计数器锁</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写者进程</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">writer</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)  {</span><br><span class="line">        P(writeMutex);</span><br><span class="line">        P(resourceMutex);           <span class="comment">// 获取资源锁</span></span><br><span class="line">        <span class="comment">// 执行写入操作</span></span><br><span class="line">        V(resourceMutex);           <span class="comment">// 释放资源锁</span></span><br><span class="line">        V(writeMutex);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>如果对上面的伪代码没有概念的话，下面是一个cpp的实例</p>
<ul>
<li>读优先</li>
</ul>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WriterAndReader</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::mutex write_mutex;</span><br><span class="line">    std::mutex read_mutex;</span><br><span class="line">    std::condition_variable cv_read;</span><br><span class="line">    std::condition_variable cv_write;</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; read_count{<span class="number">0</span>}; <span class="comment">// 原子操作</span></span><br><span class="line">    std::string data;</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; index{<span class="number">0</span>};      <span class="comment">// 原子操作</span></span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; stop{<span class="literal">false</span>};</span><br><span class="line">    std::array&lt;std::string, 4&gt; res {<span class="string">"hello"</span>, <span class="string">"world"</span>, <span class="string">"hello"</span>, <span class="string">"cpp"</span>};</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (!stop) {</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">read_lock</span><span class="params">(read_mutex)</span></span>;</span><br><span class="line">            cv_read.<span class="built_in">wait</span>(read_lock, [<span class="keyword">this</span>]() { <span class="keyword">return</span> !data.<span class="built_in">empty</span>() || stop; });</span><br><span class="line">            <span class="keyword">if</span> (stop) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            read_count++;</span><br><span class="line">            read_lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">            std::cout &lt;&lt; <span class="string">"data is: "</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">            read_lock.<span class="built_in">lock</span>();</span><br><span class="line">            read_count--;</span><br><span class="line">            <span class="keyword">if</span> (read_count == <span class="number">0</span>) {</span><br><span class="line">                cv_write.<span class="built_in">notify_one</span>();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (!stop) {</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">write_lock</span><span class="params">(write_mutex)</span></span>;</span><br><span class="line">            cv_write.<span class="built_in">wait</span>(write_lock, [<span class="keyword">this</span>]() { <span class="keyword">return</span> read_count == <span class="number">0</span> || stop; });</span><br><span class="line">            <span class="keyword">if</span> (stop) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 原子操作确保 index 安全</span></span><br><span class="line">            <span class="type">int</span> current_index = index++;</span><br><span class="line">            data = res[current_index % <span class="number">4</span>];</span><br><span class="line">            cv_read.<span class="built_in">notify_all</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop_threads</span><span class="params">()</span> </span>{</span><br><span class="line">        stop = <span class="literal">true</span>;</span><br><span class="line">        cv_read.<span class="built_in">notify_all</span>();  <span class="comment">// 唤醒读者</span></span><br><span class="line">        cv_write.<span class="built_in">notify_all</span>(); <span class="comment">// 唤醒写者</span></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<ul>
<li>写优先</li>
</ul>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">readerwriter</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">readerwriter</span>() : <span class="built_in">readcount</span>(<span class="number">0</span>), <span class="built_in">iswriting</span>(<span class="literal">false</span>) {}</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reader</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            {</span><br><span class="line">                <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">                readcountcond_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() { <span class="keyword">return</span> !iswriting; }); <span class="comment">// 等待写者完成</span></span><br><span class="line">                readcount++;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行读取操作</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">"reader is reading... (readcount: "</span> &lt;&lt; readcount &lt;&lt; <span class="string">")"</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">            {</span><br><span class="line">                <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">                readcount--;</span><br><span class="line">                <span class="keyword">if</span> (readcount == <span class="number">0</span>) {</span><br><span class="line">                    writecond_.<span class="built_in">notify_one</span>(); <span class="comment">// 通知写者可以写入</span></span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 模拟读取操作时间</span></span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">writer</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            {</span><br><span class="line">                <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">                iswriting = <span class="literal">true</span>;</span><br><span class="line">                writecond_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() { <span class="keyword">return</span> readcount == <span class="number">0</span>; }); <span class="comment">// 等待所有读者完成</span></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行写入操作</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">"writer is writing..."</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">            {</span><br><span class="line">                <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">                iswriting = <span class="literal">false</span>;</span><br><span class="line">                readcountcond_.<span class="built_in">notify_all</span>(); <span class="comment">// 通知所有读者可以读取</span></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 模拟写入操作时间</span></span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1000</span>));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::mutex mtx_;</span><br><span class="line">    std::condition_variable readcountcond_;</span><br><span class="line">    std::condition_variable writecond_;</span><br><span class="line">    <span class="type">int</span> readcount;</span><br><span class="line">    <span class="type">bool</span> iswriting;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    readerwriter rw;</span><br><span class="line">    std::vector&lt;std::thread&gt; readers;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) {</span><br><span class="line">        readers.<span class="built_in">emplace_back</span>(&amp;readerwriter::reader, &amp;rw);</span><br><span class="line">    }</span><br><span class="line">    <span class="function">std::thread <span class="title">writerthread</span><span class="params">(&amp;readerwriter::writer, &amp;rw)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;reader : readers) {</span><br><span class="line">        reader.<span class="built_in">join</span>();</span><br><span class="line">    }</span><br><span class="line">    writerthread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="哲学家问题"><a href="#哲学家问题" class="headerlink" title="哲学家问题"></a>哲学家问题</h3><h4 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h4><p>在这个模型中：</p>
<ul>
<li><strong>哲学家</strong>：每位哲学家可以进行两种活动：思考和吃饭。</li>
<li><strong>餐具</strong>：每位哲学家面前有两根筷子（或餐叉），分别位于其左侧和右侧。要吃饭，哲学家必须同时拿起左边和右边的筷子。</li>
</ul>
<h4 id="主要挑战"><a href="#主要挑战" class="headerlink" title="主要挑战"></a>主要挑战</h4><ul>
<li><strong>死锁</strong>：如果每位哲学家同时拿起左边的筷子，然后等待右边的筷子，就会导致所有哲学家都在等待，形成死锁。</li>
<li><strong>资源竞争</strong>：哲学家之间对筷子的竞争可能导致资源耗尽。</li>
</ul>
<h4 id="死锁分析"><a href="#死锁分析" class="headerlink" title="死锁分析"></a>死锁分析</h4><p>死锁的产生通常满足以下四个条件：</p>
<ol>
<li><strong>互斥</strong>：至少有一个资源必须处于非共享模式，即一次只能由一个进程使用。</li>
<li><strong>保持并等待</strong>：一个进程至少持有一个资源，并等待获取其他资源。</li>
<li><strong>不剥夺</strong>：已经分配给进程的资源在该进程释放之前，不能被其他进程强制剥夺。</li>
<li><strong>循环等待</strong>：存在一种进程的循环等待关系。</li>
</ol>
<p>在哲学家就餐问题中，如果每位哲学家都先拿起左侧的筷子，就会出现循环等待，从而导致死锁。</p>
<h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="1-增加限制"><a href="#1-增加限制" class="headerlink" title="1. 增加限制"></a>1. 增加限制</h5><p>比如最多允许四个哲学家同时进餐。这样可以保证至少一个哲学家是可以拿到左右两只筷子。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = {<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>};</span><br><span class="line">semaphore mutex = <span class="number">1</span>; <span class="comment">// 互斥取筷子</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Run</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) {</span><br><span class="line">        P(mutex);</span><br><span class="line">        P(chopstick[i]); <span class="comment">// take left</span></span><br><span class="line">        P(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]); <span class="comment">// take right</span></span><br><span class="line">        V(mutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Eatting ....</span></span><br><span class="line"></span><br><span class="line">        V(chopstick[i]); <span class="comment">// drop left</span></span><br><span class="line">        V(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]); <span class="comment">// drop right</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Thinking ...</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h5 id="2-改变获取顺序"><a href="#2-改变获取顺序" class="headerlink" title="2. 改变获取顺序"></a>2. 改变获取顺序</h5><p>要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。</p>
<h5 id="3-资源分级"><a href="#3-资源分级" class="headerlink" title="3. 资源分级"></a>3. 资源分级</h5><p>仅当一个哲学家左右两只筷子都可用时才允许他抓起筷子。</p>
<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>管程（Monitor）是操作系统和并发编程中的一种同步机制，用于管理对共享资源的访问。它通过封装共享变量和操作这些变量的过程，提供了一种高效且易于使用的方式来解决并发问题。</p>
<h4 id="管程的定义"><a href="#管程的定义" class="headerlink" title="管程的定义"></a>管程的定义</h4><p>管程是一种高级同步原语，它将共享数据结构（如变量）和对这些数据结构的操作封装在一个模块中。管程确保在任一时刻只有一个进程可以访问这些共享资源，从而实现互斥访问。</p>
<h4 id="主要特征"><a href="#主要特征" class="headerlink" title="主要特征"></a>主要特征</h4><ol>
<li>局部管程的数据只能被局部于管程的过程所访问</li>
<li>一个进程只有通过调用管程内的过程才能进入管程访问</li>
<li>每次仅允许一个进程在管程内执行某个内部过程</li>
</ol>
<h4 id="管程的组成"><a href="#管程的组成" class="headerlink" title="管程的组成"></a>管程的组成</h4><ul>
<li><strong>共享变量</strong>：管程内定义的共享数据。</li>
<li><strong>过程</strong>：对共享数据进行操作的一组函数或方法。</li>
<li><strong>条件变量</strong>：用于实现进程间同步的机制，允许进程在某些条件下被阻塞或唤醒。</li>
<li><strong>初始化语句</strong>：用于设置共享变量初始值的代码。</li>
</ul>
<h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><p>条件变量是管程中重要的组成部分，用于实现更复杂的同步机制。它们提供了两个基本操作：</p>
<ul>
<li>**wait(c)**：调用该操作的进程被阻塞，并释放管程，直到其他进程执行signal(c)唤醒它。</li>
<li>**signal(c)**：唤醒在条件变量c上等待的一个进程。如果没有进程在等待，则该信号被丢弃。</li>
</ul>
<h4 id="管程与信号量的比较"><a href="#管程与信号量的比较" class="headerlink" title="管程与信号量的比较"></a>管程与信号量的比较</h4><p>虽然管程和信号量都能解决并发问题，但它们之间有显著区别：</p>
<ul>
<li><strong>封装性</strong>：管程将所有相关的同步操作集中在一起，而信号量则可能导致同步代码分散在多个地方。</li>
<li><strong>易用性</strong>：由于互斥和同步机制由编译器处理，使用管程通常比使用信号量更简单、更安全。</li>
<li><strong>错误率</strong>：由于管程内部管理复杂性，程序员不需要手动处理互斥，降低了出错的概率。</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h4><p>死锁可以被定义为：一组进程中的每个进程都在等待一个事件，而这个事件只能由该组中的其他进程触发。当这种情况发生时，所有相关进程都将无限期地等待下去，无法继续执行。简单来说，就是每个进程都在等待其他进程释放它所需的资源，而这些资源又被其他进程占用，从而形成了一个循环等待的状态<br>死锁、死循环和饥饿是并发编程中常见的三种现象，它们虽然都与进程的执行状态有关，但各自的定义、原因和影响有所不同。</p>
<h4 id="进程死锁、饥饿、死循环的区别"><a href="#进程死锁、饥饿、死循环的区别" class="headerlink" title="进程死锁、饥饿、死循环的区别"></a>进程死锁、饥饿、死循环的区别</h4><h5 id="1-死锁"><a href="#1-死锁" class="headerlink" title="1. 死锁"></a>1. 死锁</h5><p><strong>定义</strong>：死锁是指两个或多个进程因相互等待对方持有的资源而导致的僵局状态。在这种情况下，所有相关进程都无法继续执行。</p>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>循环等待</strong>：每个进程都在等待其他进程释放它所需的资源。</li>
<li><strong>阻塞状态</strong>：所有参与死锁的进程都处于阻塞状态，无法向前推进。</li>
</ul>
<p><strong>示例</strong>：进程A持有资源1并请求资源2，而进程B持有资源2并请求资源1，导致两者相互等待。</p>
<h5 id="2-死循环"><a href="#2-死循环" class="headerlink" title="2. 死循环"></a>2. 死循环</h5><p><strong>定义</strong>：死循环是指某个进程在执行过程中陷入一个无限循环，无法正常结束或跳出该循环。通常是因为程序逻辑错误或故意设计的逻辑。</p>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>逻辑错误</strong>：可能由于代码中的错误导致条件永远不满足。</li>
<li><strong>不一定阻塞</strong>：死循环的进程可能仍在运行，但无法完成其预定任务。</li>
</ul>
<p><strong>示例</strong>：一个程序在检查某个条件时，条件始终为假，导致其不断重复执行同一段代码。</p>
<h5 id="3-饥饿"><a href="#3-饥饿" class="headerlink" title="3. 饥饿"></a>3. 饥饿</h5><p><strong>定义</strong>：饥饿是指某个进程由于长期得不到所需资源而无法向前推进。饥饿通常是由于调度策略不当或资源分配不均造成的。</p>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>单一影响</strong>：可能只有一个进程经历饥饿，而其他进程正常运行。</li>
<li><strong>可处于不同状态</strong>：饥饿的进程可以处于阻塞状态（如等待I/O设备）或就绪状态（长期得不到CPU时间）。</li>
</ul>
<p><strong>示例</strong>：在短作业优先（SJF）调度算法中，如果有大量短作业不断到达，长作业可能会一直得不到处理，从而导致饥饿。</p>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><table>
<thead>
<tr>
<th>特征</th>
<th>死锁</th>
<th>死循环</th>
<th>饥饿</th>
</tr>
</thead>
<tbody><tr>
<td>定义</td>
<td>互相等待对方资源，无法执行</td>
<td>陷入无限循环，无法结束</td>
<td>长期得不到所需资源</td>
</tr>
<tr>
<td>状态</td>
<td>所有相关进程均阻塞</td>
<td>进程仍在运行但无效</td>
<td>可能处于阻塞或就绪状态</td>
</tr>
<tr>
<td>影响范围</td>
<td>多个进程</td>
<td>单个进程</td>
<td>单一或多个进程</td>
</tr>
<tr>
<td>解决方法</td>
<td>检测与恢复、预防措施</td>
<td>修正代码逻辑</td>
<td>改善调度策略</td>
</tr>
</tbody></table>
<h4 id="死锁产生必要的条件"><a href="#死锁产生必要的条件" class="headerlink" title="死锁产生必要的条件"></a>死锁产生必要的条件</h4><ol>
<li>互斥条件：资源不能被多个进程同时使用，即某个资源只能被一个进程占有。</li>
<li>占有且等待：一个进程持有至少一个资源，并正在请求其他资源。</li>
<li>不可剥夺条件：已经分配给某个进程的资源在该进程完成之前不能被强制剥夺。</li>
<li>循环等待条件：存在一个进程集合，其中每个进程都在等待下一个进程所持有的资源，从而形成一个环路</li>
</ol>
<h4 id="什么时候会发生死锁"><a href="#什么时候会发生死锁" class="headerlink" title="什么时候会发生死锁"></a>什么时候会发生死锁</h4><ol>
<li><p><strong>资源竞争</strong>：当多个进程需要共享有限的资源（如打印机、数据库连接等），并且这些资源只能被一个进程占用时，竞争可能导致死锁。例如，如果两个进程各自持有一个资源并请求对方的资源，就会形成死锁。</p>
</li>
<li><p><strong>请求与保持条件</strong>：如果一个进程已经持有某些资源，并且在请求其他资源时被阻塞，这种情况下就可能导致死锁。例如，进程A持有资源R1并请求资源R2，而进程B持有资源R2并请求资源R1，这样双方都在等待对方释放所需的资源，从而导致死锁。</p>
</li>
<li><p><strong>不可剥夺条件</strong>：当一个进程持有某个资源时，其他进程无法强制剥夺该资源，必须等到持有者主动释放。这种条件使得即使系统中存在可用资源，依然可能因为某些进程未释放其占有的资源而导致死锁。</p>
</li>
<li><p><strong>循环等待条件</strong>：如果存在一组进程，其中每个进程都在等待下一个进程所持有的资源，就形成了一个循环等待的状态。这是死锁发生的关键条件之一。例如，若P1等待P2持有的资源，而P2又在等待P1持有的资源，就会形成循环等待。</p>
</li>
<li><p><strong>不当的进程推进顺序</strong>：如果进程请求和释放资源的顺序不当，也可能导致死锁。例如，两个线程分别申请两个互斥锁，但获取顺序不一致，可能导致两个线程互相等待对方释放锁，从而产生死锁。</p>
</li>
</ol>
<h4 id="死锁的处理策略"><a href="#死锁的处理策略" class="headerlink" title="死锁的处理策略"></a>死锁的处理策略</h4><h5 id="1-预防死锁"><a href="#1-预防死锁" class="headerlink" title="1. 预防死锁"></a>1. 预防死锁</h5><p>预防死锁是通过破坏死锁产生的四个必要条件中的一个或多个来避免死锁的发生。具体方法包括：</p>
<ul>
<li><p><strong>破坏互斥条件</strong>：在某些情况下，可以尝试让资源不被独占，例如使用共享资源的方式，但这在实际应用中通常不可行。</p>
</li>
<li><p><strong>破坏请求与保持条件</strong>：不允许进程在持有某些资源的情况下请求其他资源。可以要求进程在请求新资源时释放已持有的资源。</p>
</li>
<li><p><strong>破坏不可剥夺条件</strong>：允许操作系统强制剥夺某些资源，以便将其分配给其他进程。</p>
</li>
<li><p><strong>破坏循环等待条件</strong>：为系统中的所有资源分配一个全局顺序，进程必须按照这个顺序请求资源，从而避免形成循环等待。</p>
</li>
</ul>
<h5 id="2-避免死锁"><a href="#2-避免死锁" class="headerlink" title="2. 避免死锁"></a>2. 避免死锁</h5><p>避免死锁是在资源动态分配过程中，通过算法确保系统不会进入不安全状态。常用的方法包括：</p>
<ul>
<li><p><strong>安全性算法</strong>：例如银行家算法，在分配资源前检查是否会导致系统进入不安全状态。如果会，则拒绝该请求。</p>
</li>
<li><p><strong>动态监控</strong>：实时监测系统状态，确保在任何时刻都不会形成循环等待。</p>
</li>
</ul>
<h5 id="3-检测与恢复"><a href="#3-检测与恢复" class="headerlink" title="3. 检测与恢复"></a>3. 检测与恢复</h5><p>检测与恢复策略允许死锁发生，但会定期检查系统中是否存在死锁。一旦检测到死锁，采取相应措施来解除死锁。常见的恢复方法包括：</p>
<ul>
<li><p><strong>进程撤销</strong>：选择一个或多个进程进行撤销，释放其占有的资源，从而打破死锁状态。</p>
</li>
<li><p><strong>回滚</strong>：将某些进程回滚到之前的状态，以释放资源并重新尝试执行。</p>
</li>
<li><p><strong>抢占</strong>：强制从某个持有者那里夺取资源并分配给其他需要该资源的进程。</p>
</li>
</ul>
<h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h5><table>
<thead>
<tr>
<th>处理策略</th>
<th>方法描述</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>预防</td>
<td>破坏四个必要条件中的至少一个</td>
<td>确保不会发生死锁</td>
<td>可能导致资源利用率低，效率下降</td>
</tr>
<tr>
<td>避免</td>
<td>动态监控和安全性算法，确保不进入不安全状态</td>
<td>灵活性高，能适应变化</td>
<td>实现复杂，需要预测未来资源需求</td>
</tr>
<tr>
<td>检测与恢复</td>
<td>定期检测死锁并采取措施解除</td>
<td>不影响正常运行，可以有效处理已发生的死锁</td>
<td>可能导致部分进程被撤销或回滚，造成损失</td>
</tr>
<tr>
<td>忽略</td>
<td>不采取任何措施，选择忽略死锁</td>
<td>实现简单，适合高性能需求</td>
<td>无法解决实际发生的死锁问题</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>408</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
</search>
