{"meta":{"title":"Raven's blog","subtitle":"","description":"","author":"Raven005","url":"http://example.com","root":"/"},"pages":[{"title":"tags","date":"2024-07-01T16:30:17.000Z","updated":"2024-11-08T02:21:34.989Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2024-07-01T16:30:05.000Z","updated":"2024-11-08T02:21:34.892Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"操作系统02","slug":"operating-system-2","date":"2024-11-11T14:40:06.000Z","updated":"2025-03-13T08:32:08.141Z","comments":true,"path":"2024/11/11/operating-system-2/","permalink":"http://example.com/2024/11/11/operating-system-2/","excerpt":"","text":"进程概念进程是动态的，是程序的一次执行过程，同一个程序多次执行会对应多个进程 组成 程序段、数据段、PCB三部分组成了进程的实体（进程映像）引入进程实体的概念后，可以把进程定义为：进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位 注意： PCB是进程存在的唯一标识 PCB当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的”身份证号” PID 操作系统要记录PID,进程所属用户ID，还要记录给进程分配了哪些资源、进程的运行情况这些信息都被保存在一个数据结构PCB,即进程控制块，操作系统需要对各个并发运行的进程进行管理，但凡管理时所需要的信息，都会被放在PCB中 特征 程序是静态的，进程是动态的，动态性是进程最基本的特征 进程的状态flowchart TD A[创建态] --&gt;|系统完成创建进程的一系列工作| B[就绪态] --&gt;|进程被调度| C[运行态] --&gt;|进程运行结束,或者运行过程中遇到不可修复的错误| D[终止态] C --&gt;|进程用'系统调用'的方式申请某种系统资源,或者请求等待某个事件发生 | E[阻塞态] E --&gt;|申请的资源被分配,或等待某个事件发生| B C --&gt;|时间片到,或处理机被抢占| B B --&gt;|挂起| F[就绪挂起] F --&gt;|激活| B E --&gt;|挂起| G[阻塞挂起] G --&gt;|激活| E A --&gt; F G --&gt;|事件出现| F C --&gt; F 运行态–&gt;到阻塞态是一种进程自身作出的主动行为阻塞态–&gt;就绪态是不是进程自身能控制的，是一种被动行为 注意: 不能由阻塞态直接转换为运行态，也不能由就绪态直接转换为阻塞态(因为进入阻塞态是进程主动请求的，必然需要进程在运行时才能发出这种请求) “挂起”和“阻塞”的区别，两种状态都是暂时不能获得CPU的服务，但挂起态是将进程映像调到外存去了，而阻塞态下进程映像还在内存中 创建态进程正在被创建时，它的状态是创建态，在这个阶段操作系统会为进程分配资源、初始化PCB 就绪态当进程被创建完成后，便进入就绪态，处于就绪态的进程已经具备运行条件，但由于没有空闲CPU,就暂时不能运行 运行态如果一个进程此时在CPU上运行，那么这个进程处于运行态 阻塞态在进程运行的过程中，可能会请求等待某个时间的发生(如等待某种系统资源分配，或者等待其他进程的响应)，在这个事件发生之前，进程无法继续往下执行，此时操作系统会让这个进程下CPU,并让他进入阻塞态当CPU空闲时，又会选择另一个就绪态进程上CPU运行 终止态一个进程可以执行exit系统调用，请求操作系统终止该进程，此时该进程会进入终止态，操作系统会让该进程下CPU,并回收内存空间等资源，最后还要回收该进程的PCB 进程的组织方式链式方式 按照进程状态将PCB分为多个队列 操作系统持有指向各个队列的指针 索引方式 根据进程状态的不同，建立几张索引表 操作系统持有指向各个索引表的指针 进程控制原语原语是一种特殊的程序，它的执行具有原自行。也就是说这段程序的运行必须一气呵成，不可中断 原子性可以用“关中断指令”和“开中断指令”实现原子性 进程控制相关原语进程创建 创建原语 申请空白PCB 为新进程分配所需资源 初始化PCB 将PCB插入就绪队列 创建态–&gt;就绪态 引起进程创建的事件 用户登录 分时系统中，用户登录成功，系统会为其建立一个新进程 作业调度，多道批处理系统，有新的作业放入内存时，会为其建立一个新的进程 提供服务，用户向操作系统提出某些请求时，会新建一个进程处理该请求 应用请求，由用户进程主动请求创建一个子进程 进程终止 撤销原语 从PCB集合中找到终止进程的PCB 若进程正在运行，立即剥夺CPU,将CPU分配给其他进程 终止其所有子进程 将该进程拥有的所有资源归还给父进程或操作系统 引起进程终止的事件 正常结束 异常结束 外界干预 进程阻塞 进程的阻塞 阻塞原语 运行态–&gt;阻塞态 找到要阻塞的进程对应PCB 保护进程运行现场，将PCB状态信息设置为“阻塞态”，展示停止进程运行 将PCB插入相应事件的等待队列 引起进程阻塞的事件 需要等待系统分配某种资源 需要等待相互合作的其他进程完成工作 进程的唤醒 唤醒原语 在事件等待队列中找到PCB 将PCB从等待队列中移除，设置进程为就绪态 将PCB插入就绪队列，等待被调度 引起进程唤醒的事件 等待事件的发生 进程切换 切换原语 将运行环境信息存入PCB PCB移入相应队列 选择另一个进程执行，并更新其PCB 根据PCB恢复新进程所需的运行环境 引起进程切换的事件 当前进程时间片到 有更高优先级的进程到达 当前进程主动阻塞 当前进程终止 进程通信共享存储 基于数据结构的共享: 比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方式 基于存储区的共享: 操作系统在内存中划出一块共享存储区，数据的形式、存放位置都由通信进程控制，而不是操作系统。这种共享方式速度很快，是一种高级通信方式 消息通信 直接通信方式 消息传送进程要指明接受进程的ID 间接通信方式 通过“信箱”间接的通信。 管道通信（循环队列） 管道通信和共享存储在于管道通信的读写都是先进先出的 管道只能采用半双工通信，某一之间段内只能采用半双工通信，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道 各进程要互斥访问管道（由操作系统实现） 当管道写满时，写进程将阻塞，知道读进程将管道中的数据取走，即可唤醒写进程 当管道读空时，读进程将阻塞，知道写进程往管道写入数据，即可唤醒读进程 管道中的数据一旦被读出，就彻底消失。因此，当多个进程读同一个管道时，可能会错乱。对此，通常有两种解决方案 一个管道允许多个写进程，一个读进程 允许有多个写进程，多个读进程，但系统会让各个读进程轮流从管道中读数据(linux) 线程线程概念线程是一个基本的CPU执行单元，也是程序执行流的最小单位 属性 线程是处理机调度的基本单位 多CPU计算机中，各个县城可占用不同的CPU 每个线程都有一个线程ID、线程控制块(TCB) 线程也有就绪、阻塞、运行三种基本状态 线程几乎不拥有系统资源 同一进程的不同线程间共享进程的资源 由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预 同一进程中的线程切换，不会引起进程切换 不同进程中的线程切换，会引起进程切换 切换同进程内的线程，系统开销很小 切换进程，系统开销比较大 实现方式用户级线程 内核级线程 多线程模型一对一模型每个用户级线程都对应一个内核级线程 优点 提高了并发性：当一个线程进行阻塞系统调用时，其他线程可以继续执行。 更好的并行性：在多处理器架构中，多线程可在多核处理机上并行执行。 缺点 资源消耗较高：由于每个用户级线程都需要一个内核级线程来对应，这可能会增加系统的开销和复杂度。 多对一模型在多线程的多对一模型中，多个用户级线程被映射到一个内核级线程上,且一个进程只被分配一个内核级线程上 优点 资源管理效率高：由于线程管理主要由用户空间的线程库处理，不需要切换到核心态，这使得该模型相对高效。 减少开销：与一对一模型相比，多对一模型减少了内核级别的上下文切换次数，从而降低了系统开销。 缺点 资源竞争严重：当一个用户级线程进行阻塞系统调用时，所有其他用户级线程都会被阻塞。 多对多模型 线程状态与转换flowchart TD A[就绪] --&gt;|被调度程序选中| B[运行] B --&gt;|时间用完| A B --&gt;|等待某事件| C[阻塞] C --&gt;|等待的事件发生| A 线程的组织与控制 处理机调度基本概念调度器通过选择就绪队列中的一个进程并将其分配给CPU来实现这一目标。这使得多个进程能够在有限的硬件资源下并发执行，从而提高系统的整体性能和响应速度 分类与层次：调度可以根据不同的标准进行分类，通常分为三个层次： 高级调度（作业调度）：决定哪些作业或任务被加载到系统中。 中级调度（内存调度）：管理进程在主存中的驻留和交换。 低级调度（进程调度或时间片轮转）：决定当前CPU时间片由哪个进程使用 调度类别 要做什么 发生地 发生频率 对进程状态的影响 高级调度(作业调度) 按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程 外存-&gt;内存(面向作业) 最低 无-&gt;创建态-&gt;就绪态 中级调度(内存调度) 按照某种规则，从挂起队列中选择合适的进程将其数据回调内存 外存-&gt;内存(面向进程) 中等 挂起态-&gt;就绪态(阻塞挂起-&gt;阻塞态) 低级调度(进程调度) 按照某种规则，从就绪队列中选择一个进程为其分配处理机 内存-&gt;CPU 最高 就绪态-&gt;运行态 进程调度进程调度（低级调度）就是按照某种算法从就绪队列中选择一个进程为其分配进程 时机需要进行进程调度与切换的情况 当前运行的进程主动放弃处理机 进程正常终止 运行过程中发生异常 进程主动请求阻塞 当前运行的进程被动放弃处理机 分给进程的时间片用完 有更紧急的事需要处理(I/O中断) 有更高优先级的进程进入就绪队列 不能进行进程调度与切换情况 在处理中断的过程中 进程在操作系统内核临界区中,但是进程在普通临界区中是可以进行调度、切换的 在原子操作过程中。原子操作不可中断，要一气呵成 方式非剥夺调度方式(非抢占式) 一旦某个进程获得了CPU的控制权，它就会一直运行，直到该进程主动放弃CPU（例如，因为等待I/O操作完成或因为进程结束）。在此期间，即使有更高优先级的进程到达，也不会中断当前进程的执行。 剥夺调度式(抢占方式) 指操作系统可以在任何时刻中断当前正在运行的进程，并将CPU分配给另一个进程。这种中断通常发生在时间片用完、更高优先级的进程到达或某些特定事件发生时。 切换与过程 注意频繁的进程调度、切换会让整个操作系统效率降低，使系统大部分时间都花在进程切换上，属于进程执行的时间减少了 切换“狭义的进程调度”与“进程切换的区别” 狭义的进程调度指的是从就绪队列中选中一个要运行的进程 进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程 “广义的进程调度”包含了选择一个进程和进程切换两个步骤 过程进程的切换主要完成: 对原来运行进程各种数据的保存 对新的进程各种数据的恢复 调度算法的评价指标CPU利用率利用率忙绿时间总时间 系统吞吐量单位时间内完成的作业数量 系统吞吐量总共完成了多少道作业总共花了多少时间 周转时间从作业被提交给系统开始，到作业完成为止的这段时间间隔 作业周转时间作业完成时间作业提交时间 平均周转时间各作业周转时间之和作业数 带权周转时间作业周转时间作业实际运行时间作业完成时间作业提交时间作业实际运行时间 注意带权周转时间必然&gt;=1 平均带权周转时间各作业带权周转时间之和作业数 响应时间从用户提交请求到首次产生响应的时间 进程同步和互斥进程同步同步也叫直接制约关系，是指为完成某种任务而建立的两个或多个进程，这些进程是因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作 进程互斥我们把一个时间段内只允许一个进程使用的资源叫做临界资源进程互斥是指当一个进程访问某个临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源 对进程的互斥访问: 进入区：负责检查是否可进入临界区，若可进入，则设置”正在访问临界资源标志” 临界区：访问临界资源的那段代码 退出区：负责解除“正在访问临界资源的标志”（解锁） 剩余区：其他处理 注意 临界区是进程中访问临界资源的代码段 进入区和退出区是负责实现互斥的代码段 临界区可称为”临界段” 为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则: 空闲让进: 临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区 忙则等待: 当已有进程进入临界区时，其他试图进入临界区的进程必须等待 有限等待: 对请求访问的进程，应保证能在有限时间内进入临界区 让权等待: 当进程不能进入临界区，应立即释放处理机，防止进程忙等待 进程互斥的软件实现方法单步标志法单标志法的算法思想是：两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予。具体实现过程如下： 12345678910111213141516171819int turn = 0; //表示当前允许进入临界区的进程号void P1() { while(turn != 0) { // 进入区 // critical section 临界区 turn = 1; // 退出区 // remainder seciont 剩余区 }}void P2() { while(turn != 1) { // critical section turn = 0; // remainder seciont }} 对于turn表示当前允许进入临界区的进程号，而只有当前允许进入临界区的进程在访问了临界区之后，才会修改turn的值。也就是说，对于临界区的访问，一定是按p0→p1→p0→p1…这样轮流访问。 这种必须轮流访问带来的问题是，如果此时允许进入临界区的进程是P0，而P0一直不访问临界区，那么虽然此时临界区空闲，但是并不允许P1访问。因此对于单标志法，其违背了空闲让进的原则。 双标志先检查法双标志先检查法的算法思想是：设置一个布尔型数组flag[]，数组中各个元素用来标记各进程想进入临界区的意愿，比如flag[0] = true意味着0号进程p0现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志flag[i]设为true，之后开始访问临界区。 1234567891011121314151617bool flag[2] = {false, false};void P1() { while(flag[1] ); // 1 flag[0] = true; // 2 //critical section // 3 flag[0] = false; // 4 //remainder section}void P2() { while(flag[0]); // 5 flag[1] = true; // 6 //critical section // 7 flag[1] = false; // 8 //remainder section} 需要注意的是，如果按照152637的顺序执行，p0和p1将会同时访问临界区。因此对于双标志先检查法，其违背了忙则等待的原则。 之所以造成这种问题，就是因为进入区的检查和上锁不是原子操作，在检查完的下一步还没上锁很有可能发生其他事件。 双标志后检查法双标志后检查法的思想是：既然先检查后上锁不行，那我就先上锁，然后在检查。 123456789101112131415161718bool flag[2] = {false, false};void P0() { flag[0] = true; // 1 while(flag[1]); // 2 //critical section // 3 flag[0] = false; // 4 //remainder section}void P1() { flag[1] = true; // 5 while(flag[0]); // 6 //critical section // 7 flag[1] = false; // 8 //remainder section} 需要注意的是，如果按照1526的顺序执行，p0和p1将都无法进入临界区。 因此双标志后检查法虽然解决了忙则等待的问题，但是又违背了空闲让进和有限等待原则，因为如果各进程都长期无法访问临界资源会产生饥饿现象。 Peterson算法在双标志后检查法中，两个进程都争着想进入临界区，但是谁也不让谁，既然这样，那只需要有人礼让即可解决问题。 1234567891011121314151617181920bool flag[2] = {false, false};int turn = 0; // 表示优先让哪个进程进入临界区void P0() { flag[0] = true; // 1 turn = 1; // 2 可以让对方先进入临界区 while(flag[1] &amp;&amp; turn == 1); // 3 //critical section // 4 flag[0] = false; // 5 //remainder section}void P1() { flag[1] = true; // 6 turn = 0; // 7 while(flag[0] &amp;&amp; turn == 0); // 8 //critical section // 9 flag[1] = false; // 10 //remainder section} 如果按照123678的顺序，则相当于串行执行，这种方式肯定可以执行。 如果按照162378的顺序，那么进程0表明自己想进入临界区，进程1表明自己想进入临界区，回到2步骤，0进程表示愿意先让给1进程执行，然后在检查1也有意愿进入临界区和自己已经让位的情况下，自己处于等待状态。这时候回到7步骤，1号进程也表示自己愿意先让给0进程执行，然后在检查0也有意愿进入临界区和自己已经让位的情况下，自己也处于等待状态。此时回到步骤3，0号进程发现turn被修改为0了，说明自己可以不用等待让位了，先行一步作为后回到步骤8，进程P1也顺利做完了。 尽管Peterson算法用软件方法解决了进程互斥问题，遵循了空闲让进、忙则等待、有限等待三个原则，但是依然未遵循让权等待原则。但是相较于前面三种算法，其本身已然是最好 进程互斥的硬件实现方法中断屏蔽方法原理中断屏蔽是指在某个进程或中断处理程序进入临界区之前，暂时禁止系统接收新的中断请求。这样做的目的是确保当前进程在执行临界区代码时不会被其他中断处理程序打断，从而避免并发访问导致的数据不一致问题。 TestAndSet指令 优点： 实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞，适用于多处理机环境 缺点: 忙等待：未获取锁的线程会不断循环等待，占用 CPU 资源，影响系统性能。 不适合长时间临界区：对于长时间的临界区访问，忙等待会导致 CPU 资源浪费。 多处理机环境：在多处理机系统中，TAS 指令只能确保当前处理器上的同步，无法阻止其他处理器上的线程访问共享资源。 swap指令 互斥锁一个进程在进入临界区时应获得锁，在推出临界区时释放锁。函数acquire获得锁，函数release释放锁。 1234567acquire() { while (!available); available = false;}release() { available = true;} 注意acquire() 和 release() 函数都是原子操作，因此互斥锁通常采用硬件机制实现 特性： 优点： 等待期间不用切换进程上下文，多处理器系统中，若上锁的时间短，则等待代价很低 缺点： 需忙等，进程时间片用完才下处理机，违反“让权等待” 忙等待： 当有一个进程在临界区中，任何其他进程在进入临界区时必须连续循环调用acquire()。当多个进程共享统一CPU时，就浪费了CPU周期。 常用于多处理器系统，一个核忙等，其他核照常工作，并快速释放临界区 不太适用于但处理机系统，忙等的过程中不可能解锁 信号量机制基本概念信号量是一个整数值，通常用于表示可用资源的数量。它可以分为两种类型： 整型信号量最初Dijkstra把整型信号量定义为一个用于表示资源数目的整型量S，它与一般的整型量不同，除初始化外，仅能通过两个标准原子操作（Atomic Operation）wait(S)和signal(S)操作可以描述为： 123456789int S = 1; // 表示当前系统中可用的资源数void wait(int S): // wait原语，相当于进入区 while(S&lt;=0); // 如果资源数不够就循环等待 S = S - 1; // 如果资源数够，就占用一个资源void signal (int S): // signal原语，相当于退出区 S = S + 1; // 使用完资源后，在退出区释放资源 记录型信号量在整型信号量机制中的wait操作，只要是信号量S&lt;=0,就会不断测试。因此，该机制并未遵循“让权等待”准则，而是使进程处于“忙等”状态。记录型信号量机制则是一种不存在“忙等”现象的进程同步机制。但在采取了“让权等待”的策略后，又会出现多个进程等待访问同一个临界资源的情况。为此，在信号量机制中，除了需要一个用于代表资源数目的整型变量value外，还应该增加一个进程链表指针L，用于链接上述的所有等待进程。记录型信号量是由于它采用了记录型的数据结构而得名的。它所包含的上述两个数据项可以描述为：type semaphore=recordvalue:integerL:list of process;end相应的，wait(S)和signal(S)的操作可描述为 1234567891011121314151617181920typedef struct { int value; // 剩余资源数 struct process *L; // 等待队列} semaphore;void wait(semaphore S) { S.value --; if(S.value &lt; 0) { block(S.L); // 如果资源数量不够，就用block将进程从运行态进入阻塞态，并把挂到信号量S的等待队列中 }}void signal(semaphore S) { S.value ++; if(S.value &lt;= 0) { wakeup(S.L); // 释放资源后，若还有别的进程在等待这种资源，则使用wakeup唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态 }} 操作机制信号量机制主要通过两个操作来实现： P操作（wait）：当进程想要进入临界区时，它会执行P操作，将信号量的值减1。如果减1后信号量的值大于或等于0，进程可以继续执行；如果小于0，进程会被阻塞，进入等待队列。 V操作（signal）：当进程离开临界区时，它会执行V操作，将信号量的值加1。如果有其他进程在等待该信号量，则其中一个等待的进程将被唤醒。 实现进程互斥 定义信号量： 1semaphore mutex = 1; // 初始化互斥信号量 进入临界区前的操作（P操作）：在进程要访问临界区之前，必须执行P（wait）操作以请求对资源的访问。这一操作会将信号量的值减1： 1P(mutex); // 请求进入临界区 临界区代码：进程在临界区内执行需要互斥访问的代码。此时，其他进程无法进入该区域。 1// 临界区代码段 离开临界区后的操作（V操作）：当进程完成对共享资源的访问后，必须执行V（signal）操作来释放资源，将信号量的值加1，从而允许其他等待的进程进入临界区： 1V(mutex); // 释放临界区 示例代码以下是一个简单的示例，展示了如何使用信号量实现进程互斥： 12345678910111213semaphore mutex = 1; // 初始化信号量为1void process1() { P(mutex); // 请求进入临界区 // 临界区代码段... V(mutex); // 离开临界区}void process2() { P(mutex); // 请求进入临界区 // 临界区代码段... V(mutex); // 离开临界区} 关键点 互斥性：通过将信号量初值设置为1，确保同一时间只能有一个进程进入临界区。 阻塞与唤醒：如果一个进程在执行P操作时发现信号量值为0，则该进程会被阻塞，直到其他进程执行V操作并唤醒它。 原子性：P和V操作通常被实现为原子操作，以防止中断，从而避免竞争条件。 实现进程同步 分析同步需求：确定哪些操作需要同步，即需要保证某些操作按顺序执行。例如，若进程P1的某个操作必须在进程P2的操作之前完成，则需要实现同步。 设置同步信号量：创建一个信号量，初始值设置为0。这个信号量用于控制两个或多个操作之间的顺序。 1semaphore sync = 0; // 初始化同步信号量为0 在“前操作”后执行V操作：在需要确保先执行的操作完成后，调用V操作以释放信号量。 12// 前操作代码V(sync); // 释放信号量 在“后操作”前执行P操作：在需要确保后执行的代码之前，调用P操作以请求信号量。如果信号量值为0，则当前进程会被阻塞，直到其他进程释放该信号量。 12P(sync); // 请求信号量// 后操作代码 示例代码以下是一个简单示例，展示如何使用信号量实现两个进程之间的同步： 12345678910111213semaphore sync = 0; // 初始化同步信号量void process1() { // 执行前操作 // ... V(sync); // 完成前操作，释放信号量}void process2() { P(sync); // 请求信号量，等待process1完成前操作 // 执行后操作 // ...} 关键点 阻塞与唤醒：通过设置初始值为0，可以确保在执行后续操作之前，相关进程必须先完成其前置条件。 避免竞争条件：使用信号量可以有效避免由于并发执行导致的数据不一致问题。 通过以上步骤和机制，信号量能够有效地实现进程之间的同步，使得多个并发进程能够按照预定顺序有序地推进。 信号量机制实现前驱关系信号量机制可以有效地处理进程之间的前驱关系，确保某些操作在其他操作之前完成。以下是信号量如何实现前驱关系的基本原理和步骤。 前驱关系的定义前驱关系指的是在多个进程或操作中，某个操作的执行必须依赖于另一个操作的完成。例如，如果操作S1必须在操作S2之前完成，则可以表示为S1 -&gt; S2。 实现步骤 设置信号量：为每个需要同步的操作设置一个信号量，初始值为0。这表示该操作在执行之前必须等待其前驱操作完成。 12semaphore a1 = 0; // 用于S1 -&gt; S2semaphore a2 = 0; // 用于S1 -&gt; S3 执行前驱操作并释放信号量：在前驱操作（如S1）完成后，调用V操作释放相应的信号量，以通知其他进程可以继续执行。 12345void S1() { // 执行S1的代码 V(a1); // 通知S2可以执行 V(a2); // 通知S3可以执行} 在后续操作中请求信号量：在每个后续操作（如S2和S3）开始之前，调用P操作请求相应的信号量。如果信号量值为0，进程将被阻塞，直到前驱操作完成并释放信号量。 123456789void S2() { P(a1); // 等待S1完成 // 执行S2的代码}void S3() { P(a2); // 等待S1完成 // 执行S3的代码} 继续后续操作：后续操作（如S4、S5、S6等）也可以使用类似的方法进行同步，确保它们在适当的时候执行。 示例代码以下是一个完整示例，展示了如何使用信号量实现多个进程之间的前驱关系： 1234567891011121314151617181920212223242526272829303132semaphore a1 = 0; // S1 -&gt; S2semaphore a2 = 0; // S1 -&gt; S3semaphore b1 = 0; // S2 -&gt; S4semaphore b2 = 0; // S2 -&gt; S5void S1() { // 执行S1的代码 V(a1); // 通知S2可以执行 V(a2); // 通知S3可以执行}void S2() { P(a1); // 等待S1完成 // 执行S2的代码 V(b1); // 通知S4可以执行 V(b2); // 通知S5可以执行}void S3() { P(a2); // 等待S1完成 // 执行S3的代码}void S4() { P(b1); // 等待S2完成 // 执行S4的代码}void S5() { P(b2); // 等待S2完成 // 执行S5的代码} 生产者消费者问题生产者消费者问题是一个经典的进程同步问题，描述了两个进程（生产者和消费者）如何在共享缓冲区中安全地交互。以下是对该问题的详细介绍，包括其背景、问题描述、解决方案及实现方式。 问题描述在生产者消费者模型中，生产者负责生成数据并将其放入共享缓冲区，而消费者则从缓冲区中取出数据进行消费。关键在于要确保： 缓冲区不满：当缓冲区已满时，生产者必须等待，直到消费者消费了数据。 缓冲区不空：当缓冲区为空时，消费者必须等待，直到生产者生成了数据。 这种模型确保了生产者和消费者之间的协调，避免了数据丢失或错误读取的情况。 解决方案使用信号量信号量是一种用于进程间同步的机制，可以有效地解决生产者消费者问题。通常需要使用两个信号量： freeSpace：表示缓冲区中可用的空位数量。 usedSpace：表示缓冲区中已用的产品数量。 伪代码示例1234567891011121314151617181920semaphore freeSpace = N; // N为缓冲区大小semaphore usedSpace = 0; // 初始时没有产品void producer() { while (true) { produceItem(); // 生产一个产品 P(freeSpace); // 请求一个空位 putItemIntoBuffer(); // 将产品放入缓冲区 V(usedSpace); // 增加已用产品计数 }}void consumer() { while (true) { P(usedSpace); // 请求一个已用产品 getItemFromBuffer(); // 从缓冲区获取产品 V(freeSpace); // 增加空位计数 consumeItem(); // 消费该产品 }} 使用互斥锁和条件变量在多生产者和多消费者的情况下，可以使用互斥锁和条件变量来实现更复杂的同步机制。互斥锁用于保护对共享资源的访问，而条件变量则用于在特定条件下阻塞和唤醒线程。 伪代码示例123456789101112131415161718192021222324252627282930mutex lock;condition_variable notFull, notEmpty;int buffer[N]; // 缓冲区int count = 0; // 当前产品数量void producer() { while (true) { produceItem(); lock.lock(); while (count == N) { notFull.wait(lock); // 等待直到有空位 } buffer[count++] = item; // 放入产品 notEmpty.notify_one(); // 通知消费者有新产品 lock.unlock(); }}void consumer() { while (true) { lock.lock(); while (count == 0) { notEmpty.wait(lock); // 等待直到有产品可消费 } item = buffer[--count]; // 获取产品 notFull.notify_one(); // 通知生产者有空位 lock.unlock(); consumeItem(item); }} 这是一个cpp实例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;array&gt;#include &lt;condition_variable&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;atomic&gt;#include &lt;chrono&gt;class ProducerConsumer {public: ProducerConsumer(int maxSize) : maxSize_(maxSize), running_(true) {} void startProducers(int numProducers) { for (int i = 0; i &lt; numProducers; ++i) { producers_.emplace_back(&amp;ProducerConsumer::producer, this); } } void startConsumers(int numConsumers) { for (int i = 0; i &lt; numConsumers; ++i) { consumers_.emplace_back(&amp;ProducerConsumer::consumer, this); } } void stop() { running_ = false; cv_.notify_all(); for (auto &amp;producer : producers_) { producer.join(); } for (auto &amp;consumer : consumers_) { consumer.join(); } }private: void producer() { int index = 0; while (running_) { std::unique_lock&lt;std::mutex&gt; lk(mtx_); cv_.wait(lk, [&amp;] { return buffer_.size() &lt; maxSize_ || !running_; }); if (!running_) break; buffer_.push(res_[(index++) % res_.size()]); std::cout &lt;&lt; \"Producer pushed: \" &lt;&lt; res_[(index - 1) % res_.size()] &lt;&lt; std::endl; cv_.notify_all(); } } void consumer() { while (running_) { std::unique_lock&lt;std::mutex&gt; lk(mtx_); cv_.wait(lk, [&amp;] { return !buffer_.empty() || !running_; }); if (!running_ &amp;&amp; buffer_.empty()) break; if (!buffer_.empty()) { auto front = buffer_.front(); buffer_.pop(); std::cout &lt;&lt; \"Consumer got: \" &lt;&lt; front &lt;&lt; std::endl; } cv_.notify_all(); } } const std::array&lt;std::string, 5&gt; res_{\"awd\", \"1\", \"awdjkgdfh\", \"encounter\", \"dwadawd\"}; std::queue&lt;std::string&gt; buffer_; std::condition_variable cv_; std::mutex mtx_; int maxSize_; std::atomic&lt;bool&gt; running_; std::vector&lt;std::thread&gt; producers_; std::vector&lt;std::thread&gt; consumers_;};int main() { ProducerConsumer pc(10); pc.startProducers(3); pc.startConsumers(3); std::this_thread::sleep_for(std::chrono::seconds(5)); pc.stop(); return 0;} 总结生产者消费者问题展示了多线程编程中的同步与互斥的重要性。通过使用信号量、互斥锁和条件变量等机制，可以有效地管理进程之间的协作，确保数据的一致性与完整性。该模型不仅适用于单一生产者和消费者，也可以扩展到多个生产者和消费者的场景中，为并发编程提供了重要的理论基础和实践指导。 读者写者问题读者写者问题是操作系统中的经典同步问题，涉及多个进程对共享资源的访问控制。其主要目标是确保在读者和写者之间实现有效的互斥，以避免数据不一致性。 问题描述在读者写者问题中，有两类进程： 读者进程：只读取共享数据，不修改它。 写者进程：可以读取和修改共享数据。 主要要求 允许多个读者同时进行读操作：多个读者可以并行访问共享资源而不会发生冲突。 只允许一个写者进行写操作：在任何写操作进行时，必须确保没有其他读者或写者同时访问该资源。 互斥访问：在写者执行写操作之前，必须等待所有当前的读者和写者完成他们的操作。 实现方案1. 读者优先在这种策略下，系统优先允许读者访问共享资源。若有持续不断的读者请求，可能会导致写者饿死，即无法获得执行机会。这种策略简单易实现，但在高并发情况下可能导致写入延迟。 2. 写者优先此策略确保写者能够尽快执行其操作。在这种情况下，如果有待处理的写请求，则后续的读请求将被阻塞。这种策略可以减少写者的饥饿现象，但可能导致读者的延迟。 解决方案示例一种常见的解决方案是使用信号量来控制对共享资源的访问。信号量提供了两种基本操作： P（proberen）：请求资源，若资源不可用则阻塞。 V（verhogen）：释放资源，唤醒等待的进程。 以下是一个简化的伪代码示例： 123456789101112131415161718192021222324252627282930313233343536373839// 初始化信号量Semaphore readCountMutex = 1; // 控制读计数器Semaphore resourceMutex = 1; // 控制对共享资源的访问Semaphore writeMUtex = 1; // 用于实现\"写优先\"int readCount = 0; // 当前读取进程数量// 读者进程void reader() { while(true) { P(writeMutex); P(readCountMutex); // 获取读计数器锁 if (readCount == 1) { P(resourceMutex); // 第一个读者获取资源锁 } readCount++; V(readCountMutex); // 释放读计数器锁 V(writeMutex); // 执行读取操作 P(readCountMutex); // 获取读计数器锁 readCount--; if (readCount == 0) { V(resourceMutex); // 最后一个读者释放资源锁 } V(readCountMutex); // 释放读计数器锁 }}// 写者进程void writer() { while(true) { P(writeMutex); P(resourceMutex); // 获取资源锁 // 执行写入操作 V(resourceMutex); // 释放资源锁 V(writeMutex); }} 如果对上面的伪代码没有概念的话，下面是一个cpp的实例 读优先 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#pragma once#include &lt;iostream&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;#include &lt;thread&gt;#include &lt;atomic&gt;#include &lt;array&gt;class WriterAndReader {private: std::mutex write_mutex; std::mutex read_mutex; std::condition_variable cv_read; std::condition_variable cv_write; std::atomic&lt;int&gt; read_count{0}; // 原子操作 std::string data; std::atomic&lt;int&gt; index{0}; // 原子操作 std::atomic&lt;bool&gt; stop{false}; std::array&lt;std::string, 4&gt; res {\"hello\", \"world\", \"hello\", \"cpp\"};public: void read() { while (!stop) { std::unique_lock&lt;std::mutex&gt; read_lock(read_mutex); cv_read.wait(read_lock, [this]() { return !data.empty() || stop; }); if (stop) break; read_count++; read_lock.unlock(); std::cout &lt;&lt; \"data is: \" &lt;&lt; data &lt;&lt; std::endl; read_lock.lock(); read_count--; if (read_count == 0) { cv_write.notify_one(); } } } void write() { while (!stop) { std::unique_lock&lt;std::mutex&gt; write_lock(write_mutex); cv_write.wait(write_lock, [this]() { return read_count == 0 || stop; }); if (stop) break; // 原子操作确保 index 安全 int current_index = index++; data = res[current_index % 4]; cv_read.notify_all(); } } void stop_threads() { stop = true; cv_read.notify_all(); // 唤醒读者 cv_write.notify_all(); // 唤醒写者 }}; 写优先 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;iostream&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;chrono&gt;class readerwriter {public: readerwriter() : readcount(0), iswriting(false) {} void reader() { while (true) { { std::unique_lock&lt;std::mutex&gt; lock(mtx_); readcountcond_.wait(lock, [this]() { return !iswriting; }); // 等待写者完成 readcount++; } // 执行读取操作 std::cout &lt;&lt; \"reader is reading... (readcount: \" &lt;&lt; readcount &lt;&lt; \")\" &lt;&lt; std::endl; { std::unique_lock&lt;std::mutex&gt; lock(mtx_); readcount--; if (readcount == 0) { writecond_.notify_one(); // 通知写者可以写入 } } // 模拟读取操作时间 std::this_thread::sleep_for(std::chrono::milliseconds(500)); } } void writer() { while (true) { { std::unique_lock&lt;std::mutex&gt; lock(mtx_); iswriting = true; writecond_.wait(lock, [this]() { return readcount == 0; }); // 等待所有读者完成 } // 执行写入操作 std::cout &lt;&lt; \"writer is writing...\" &lt;&lt; std::endl; { std::unique_lock&lt;std::mutex&gt; lock(mtx_); iswriting = false; readcountcond_.notify_all(); // 通知所有读者可以读取 } // 模拟写入操作时间 std::this_thread::sleep_for(std::chrono::milliseconds(1000)); } }private: std::mutex mtx_; std::condition_variable readcountcond_; std::condition_variable writecond_; int readcount; bool iswriting;};int main() { readerwriter rw; std::vector&lt;std::thread&gt; readers; for (int i = 0; i &lt; 3; ++i) { readers.emplace_back(&amp;readerwriter::reader, &amp;rw); } std::thread writerthread(&amp;readerwriter::writer, &amp;rw); for (auto &amp;reader : readers) { reader.join(); } writerthread.join(); return 0;} 1 哲学家问题问题描述在这个模型中： 哲学家：每位哲学家可以进行两种活动：思考和吃饭。 餐具：每位哲学家面前有两根筷子（或餐叉），分别位于其左侧和右侧。要吃饭，哲学家必须同时拿起左边和右边的筷子。 主要挑战 死锁：如果每位哲学家同时拿起左边的筷子，然后等待右边的筷子，就会导致所有哲学家都在等待，形成死锁。 资源竞争：哲学家之间对筷子的竞争可能导致资源耗尽。 死锁分析死锁的产生通常满足以下四个条件： 互斥：至少有一个资源必须处于非共享模式，即一次只能由一个进程使用。 保持并等待：一个进程至少持有一个资源，并等待获取其他资源。 不剥夺：已经分配给进程的资源在该进程释放之前，不能被其他进程强制剥夺。 循环等待：存在一种进程的循环等待关系。 在哲学家就餐问题中，如果每位哲学家都先拿起左侧的筷子，就会出现循环等待，从而导致死锁。 解决方案1. 增加限制比如最多允许四个哲学家同时进餐。这样可以保证至少一个哲学家是可以拿到左右两只筷子。 123456789101112131415161718semaphore chopstick[5] = {1, 1, 1, 1, 1};semaphore mutex = 1; // 互斥取筷子void Run() { while(true) { P(mutex); P(chopstick[i]); // take left P(chopstick[(i + 1) % 5]); // take right V(mutex); // Eatting .... V(chopstick[i]); // drop left V(chopstick[(i + 1) % 5]); // drop right // Thinking ... }} 2. 改变获取顺序要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。 3. 资源分级仅当一个哲学家左右两只筷子都可用时才允许他抓起筷子。 管程管程（Monitor）是操作系统和并发编程中的一种同步机制，用于管理对共享资源的访问。它通过封装共享变量和操作这些变量的过程，提供了一种高效且易于使用的方式来解决并发问题。 管程的定义管程是一种高级同步原语，它将共享数据结构（如变量）和对这些数据结构的操作封装在一个模块中。管程确保在任一时刻只有一个进程可以访问这些共享资源，从而实现互斥访问。 主要特征 局部管程的数据只能被局部于管程的过程所访问 一个进程只有通过调用管程内的过程才能进入管程访问 每次仅允许一个进程在管程内执行某个内部过程 管程的组成 共享变量：管程内定义的共享数据。 过程：对共享数据进行操作的一组函数或方法。 条件变量：用于实现进程间同步的机制，允许进程在某些条件下被阻塞或唤醒。 初始化语句：用于设置共享变量初始值的代码。 条件变量条件变量是管程中重要的组成部分，用于实现更复杂的同步机制。它们提供了两个基本操作： **wait(c)**：调用该操作的进程被阻塞，并释放管程，直到其他进程执行signal(c)唤醒它。 **signal(c)**：唤醒在条件变量c上等待的一个进程。如果没有进程在等待，则该信号被丢弃。 管程与信号量的比较虽然管程和信号量都能解决并发问题，但它们之间有显著区别： 封装性：管程将所有相关的同步操作集中在一起，而信号量则可能导致同步代码分散在多个地方。 易用性：由于互斥和同步机制由编译器处理，使用管程通常比使用信号量更简单、更安全。 错误率：由于管程内部管理复杂性，程序员不需要手动处理互斥，降低了出错的概率。 死锁什么是死锁死锁可以被定义为：一组进程中的每个进程都在等待一个事件，而这个事件只能由该组中的其他进程触发。当这种情况发生时，所有相关进程都将无限期地等待下去，无法继续执行。简单来说，就是每个进程都在等待其他进程释放它所需的资源，而这些资源又被其他进程占用，从而形成了一个循环等待的状态死锁、死循环和饥饿是并发编程中常见的三种现象，它们虽然都与进程的执行状态有关，但各自的定义、原因和影响有所不同。 进程死锁、饥饿、死循环的区别1. 死锁定义：死锁是指两个或多个进程因相互等待对方持有的资源而导致的僵局状态。在这种情况下，所有相关进程都无法继续执行。 特点： 循环等待：每个进程都在等待其他进程释放它所需的资源。 阻塞状态：所有参与死锁的进程都处于阻塞状态，无法向前推进。 示例：进程A持有资源1并请求资源2，而进程B持有资源2并请求资源1，导致两者相互等待。 2. 死循环定义：死循环是指某个进程在执行过程中陷入一个无限循环，无法正常结束或跳出该循环。通常是因为程序逻辑错误或故意设计的逻辑。 特点： 逻辑错误：可能由于代码中的错误导致条件永远不满足。 不一定阻塞：死循环的进程可能仍在运行，但无法完成其预定任务。 示例：一个程序在检查某个条件时，条件始终为假，导致其不断重复执行同一段代码。 3. 饥饿定义：饥饿是指某个进程由于长期得不到所需资源而无法向前推进。饥饿通常是由于调度策略不当或资源分配不均造成的。 特点： 单一影响：可能只有一个进程经历饥饿，而其他进程正常运行。 可处于不同状态：饥饿的进程可以处于阻塞状态（如等待I/O设备）或就绪状态（长期得不到CPU时间）。 示例：在短作业优先（SJF）调度算法中，如果有大量短作业不断到达，长作业可能会一直得不到处理，从而导致饥饿。 总结 特征 死锁 死循环 饥饿 定义 互相等待对方资源，无法执行 陷入无限循环，无法结束 长期得不到所需资源 状态 所有相关进程均阻塞 进程仍在运行但无效 可能处于阻塞或就绪状态 影响范围 多个进程 单个进程 单一或多个进程 解决方法 检测与恢复、预防措施 修正代码逻辑 改善调度策略 死锁产生必要的条件 互斥条件：资源不能被多个进程同时使用，即某个资源只能被一个进程占有。 占有且等待：一个进程持有至少一个资源，并正在请求其他资源。 不可剥夺条件：已经分配给某个进程的资源在该进程完成之前不能被强制剥夺。 循环等待条件：存在一个进程集合，其中每个进程都在等待下一个进程所持有的资源，从而形成一个环路 什么时候会发生死锁 资源竞争：当多个进程需要共享有限的资源（如打印机、数据库连接等），并且这些资源只能被一个进程占用时，竞争可能导致死锁。例如，如果两个进程各自持有一个资源并请求对方的资源，就会形成死锁。 请求与保持条件：如果一个进程已经持有某些资源，并且在请求其他资源时被阻塞，这种情况下就可能导致死锁。例如，进程A持有资源R1并请求资源R2，而进程B持有资源R2并请求资源R1，这样双方都在等待对方释放所需的资源，从而导致死锁。 不可剥夺条件：当一个进程持有某个资源时，其他进程无法强制剥夺该资源，必须等到持有者主动释放。这种条件使得即使系统中存在可用资源，依然可能因为某些进程未释放其占有的资源而导致死锁。 循环等待条件：如果存在一组进程，其中每个进程都在等待下一个进程所持有的资源，就形成了一个循环等待的状态。这是死锁发生的关键条件之一。例如，若P1等待P2持有的资源，而P2又在等待P1持有的资源，就会形成循环等待。 不当的进程推进顺序：如果进程请求和释放资源的顺序不当，也可能导致死锁。例如，两个线程分别申请两个互斥锁，但获取顺序不一致，可能导致两个线程互相等待对方释放锁，从而产生死锁。 死锁的处理策略1. 预防死锁预防死锁是通过破坏死锁产生的四个必要条件中的一个或多个来避免死锁的发生。具体方法包括： 破坏互斥条件：在某些情况下，可以尝试让资源不被独占，例如使用共享资源的方式，但这在实际应用中通常不可行。 破坏请求与保持条件：不允许进程在持有某些资源的情况下请求其他资源。可以要求进程在请求新资源时释放已持有的资源。 破坏不可剥夺条件：允许操作系统强制剥夺某些资源，以便将其分配给其他进程。 破坏循环等待条件：为系统中的所有资源分配一个全局顺序，进程必须按照这个顺序请求资源，从而避免形成循环等待。 2. 避免死锁避免死锁是在资源动态分配过程中，通过算法确保系统不会进入不安全状态。常用的方法包括： 安全性算法：例如银行家算法，在分配资源前检查是否会导致系统进入不安全状态。如果会，则拒绝该请求。 动态监控：实时监测系统状态，确保在任何时刻都不会形成循环等待。 3. 检测与恢复检测与恢复策略允许死锁发生，但会定期检查系统中是否存在死锁。一旦检测到死锁，采取相应措施来解除死锁。常见的恢复方法包括： 进程撤销：选择一个或多个进程进行撤销，释放其占有的资源，从而打破死锁状态。 回滚：将某些进程回滚到之前的状态，以释放资源并重新尝试执行。 抢占：强制从某个持有者那里夺取资源并分配给其他需要该资源的进程。 总结 处理策略 方法描述 优点 缺点 预防 破坏四个必要条件中的至少一个 确保不会发生死锁 可能导致资源利用率低，效率下降 避免 动态监控和安全性算法，确保不进入不安全状态 灵活性高，能适应变化 实现复杂，需要预测未来资源需求 检测与恢复 定期检测死锁并采取措施解除 不影响正常运行，可以有效处理已发生的死锁 可能导致部分进程被撤销或回滚，造成损失 忽略 不采取任何措施，选择忽略死锁 实现简单，适合高性能需求 无法解决实际发生的死锁问题","categories":[{"name":"考研","slug":"考研","permalink":"http://example.com/categories/%E8%80%83%E7%A0%94/"}],"tags":[{"name":"408","slug":"408","permalink":"http://example.com/tags/408/"},{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"docker常用命令","slug":"dockerUsage","date":"2024-10-04T01:54:36.000Z","updated":"2024-11-08T02:21:34.891Z","comments":true,"path":"2024/10/04/dockerUsage/","permalink":"http://example.com/2024/10/04/dockerUsage/","excerpt":"","text":"Docker 是一个开源的容器化平台，允许开发者将应用程序及其依赖项打包到一个轻量级、可移植的容器中。以下是一些常用的 Docker 命令： 1. 镜像相关命令 docker pull &lt;image&gt;: 从 Docker Hub 或其他镜像仓库拉取镜像。 1docker pull ubuntu docker images: 列出本地所有的镜像。 1docker images docker rmi &lt;image&gt;: 删除指定的镜像。 1docker rmi ubuntu docker build -t &lt;tag&gt; .: 使用 Dockerfile 构建镜像，并指定标签。 1docker build -t myapp:1.0 . 2. 容器相关命令 docker run &lt;image&gt;: 运行一个容器。 1docker run -it ubuntu docker ps: 列出正在运行的容器。 1docker ps docker ps -a: 列出所有容器，包括已停止的。 1docker ps -a docker start &lt;container&gt;: 启动一个已停止的容器。 1docker start mycontainer docker stop &lt;container&gt;: 停止一个正在运行的容器。 1docker stop mycontainer docker rm &lt;container&gt;: 删除一个容器。 1docker rm mycontainer docker exec -it &lt;container&gt; &lt;command&gt;: 在运行的容器中执行命令。 1docker exec -it mycontainer bash 3. 网络相关命令 docker network ls: 列出所有网络。 1docker network ls docker network create &lt;network&gt;: 创建一个新的网络。 1docker network create mynetwork docker network connect &lt;network&gt; &lt;container&gt;: 将容器连接到网络。 1docker network connect mynetwork mycontainer 4. 卷相关命令 docker volume ls: 列出所有卷。 1docker volume ls docker volume create &lt;volume&gt;: 创建一个新的卷。 1docker volume create myvolume docker volume rm &lt;volume&gt;: 删除一个卷。 1docker volume rm myvolume 5. 其他常用命令 docker logs &lt;container&gt;: 查看容器的日志。 1docker logs mycontainer docker inspect &lt;container&gt;: 查看容器的详细信息。 1docker inspect mycontainer docker system prune: 清理未使用的数据（包括停止的容器、未使用的网络、未使用的镜像等）。 1docker system prune 6. Docker Compose 命令 docker-compose up: 启动 Docker Compose 定义的服务。 1docker-compose up docker-compose down: 停止并删除 Docker Compose 定义的服务。 1docker-compose down docker-compose ps: 列出 Docker Compose 定义的服务。 1docker-compose ps","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://example.com/tags/docker/"}]},{"title":"SQL事务","slug":"SQLEvent","date":"2024-09-22T09:28:24.000Z","updated":"2024-11-08T02:21:34.889Z","comments":true,"path":"2024/09/22/SQLEvent/","permalink":"http://example.com/2024/09/22/SQLEvent/","excerpt":"","text":"在SQL中，事务（Transaction）是一组数据库操作的逻辑单元，这些操作要么全部成功执行，要么全部不执行。事务的主要目的是确保数据库的一致性和完整性，尤其是在并发访问和系统故障的情况下。 事务的基本概念 事务的特性（ACID）: 原子性（Atomicity）: 事务中的所有操作要么全部成功执行，要么全部不执行。如果事务中的任何一个操作失败，整个事务都会回滚到初始状态。 一致性（Consistency）: 事务执行前后，数据库必须保持一致性状态。事务不能违反数据库的完整性约束。 隔离性（Isolation）: 并发执行的多个事务之间是相互隔离的，一个事务的执行不能被其他事务干扰。 持久性（Durability）: 一旦事务成功提交，其结果将永久保存在数据库中，即使系统发生故障也不会丢失。 事务的控制语句: BEGIN TRANSACTION: 开始一个事务。 COMMIT: 提交事务，将所有操作永久保存到数据库中。 ROLLBACK: 回滚事务，撤销所有未提交的操作。 SAVEPOINT: 在事务中设置保存点，可以在回滚时只回滚到保存点。 12345678910BEGIN; #开始事务......ROLLBACK; #回滚事务SAVEPOINT 回滚点; #添加回滚点ROLLBACK TO 回滚点; # 回到指定回滚点...COMMIT; #提交事务-- 一旦提交，就无法进行回滚 事务的实例假设我们有一个银行账户表 accounts，我们希望实现一个转账操作，从一个账户转钱到另一个账户。为了确保转账操作的原子性和一致性，我们需要使用事务。 表结构1234CREATE TABLE accounts ( account_id INT PRIMARY KEY, balance DECIMAL(10, 2)); 插入初始数据12INSERT INTO accounts (account_id, balance) VALUES (1, 1000.00);INSERT INTO accounts (account_id, balance) VALUES (2, 500.00); 转账操作1234567891011121314BEGIN TRANSACTION;-- 从账户1转出500元UPDATE accounts SET balance = balance - 500.00 WHERE account_id = 1;-- 向账户2转入500元UPDATE accounts SET balance = balance + 500.00 WHERE account_id = 2;-- 检查账户1的余额是否足够IF (SELECT balance FROM accounts WHERE account_id = 1) &lt; 0 THEN ROLLBACK; -- 如果余额不足，回滚事务ELSE COMMIT; -- 否则，提交事务END IF; 在这个例子中，我们使用事务来确保转账操作的原子性。如果账户1的余额不足，事务将回滚，撤销所有的操作；否则，事务将提交，转账操作成功完成。 事务的隔离级别SQL标准定义了四种事务隔离级别，用于控制并发事务之间的相互影响： 读未提交（Read Uncommitted）: 允许一个事务读取另一个事务未提交的数据。可能会导致脏读、不可重复读和幻读。 读已提交（Read Committed）: 允许一个事务读取另一个事务已提交的数据。可以避免脏读，但可能会导致不可重复读和幻读。 可重复读（Repeatable Read）: 确保一个事务在执行期间多次读取同一数据时，结果是一致的。可以避免脏读和不可重复读，但可能会导致幻读。 串行化（Serializable）: 最高的隔离级别，确保事务串行执行，完全避免脏读、不可重复读和幻读。 设置隔离级别1SET TRANSACTION ISOLATION LEVEL READ COMMITTED; 事务的使用场景 银行转账: 确保从一个账户转钱到另一个账户的操作是原子的，要么全部成功，要么全部失败。 订单处理: 确保订单的创建、库存的更新和支付的处理是原子的，避免出现订单创建成功但库存未更新的情况。 数据一致性: 确保多个相关操作的一致性，例如在插入新记录时，同时更新相关统计信息。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"SQL触发器","slug":"SQLTrigger","date":"2024-09-22T09:01:34.000Z","updated":"2024-11-08T02:21:34.890Z","comments":true,"path":"2024/09/22/SQLTrigger/","permalink":"http://example.com/2024/09/22/SQLTrigger/","excerpt":"","text":"在SQL中，触发器（Trigger）是一种特殊的存储过程，它在特定的数据库操作（如插入、更新或删除）发生时自动执行。触发器通常用于维护数据完整性、执行审计跟踪、记录日志等任务。触发器可以在表级别定义，并且可以与 INSERT、UPDATE 和 DELETE 操作相关联。 触发器所依附的表为基本表，当触发器表上发生select/update/delete操作时，会自动生成两个临时的表(new/old，只能由触发器使用) 比如: 在insert操作时，会生成new表，记录插入的数据，old表则为空。 在delete操作时，会生成new表，记录删除的数据，old表记录被删除的数据。 在update操作时，会生成new表，记录更新的数据，old表记录更新前的数据。 创建触发器 12CREATE TRIGGER &lt;trigger_name&gt; [BEFORE|AFTER] [INSERT|UPDATE|DELETE] ON &lt;table_name&gt;/&lt;view_name&gt;FOR EACH ROW [INSERT|UPDATE|DELETE ] FROM &lt;table_name&gt; WHERE &lt;condition&gt;; FOR EACH ROW 表示针对每一行都会生效，无论哪行进行指定操作都会执行触发器 查看触发器 1SHOW TRIGGERS; 删除触发器 1DROP TRIGGER &lt;trigger_name&gt;; 触发器的基本概念 触发器的类型: BEFORE 触发器: 在触发操作（如插入、更新或删除）之前执行。 AFTER 触发器: 在触发操作之后执行。 INSTEAD OF 触发器: 用于视图，替代触发操作执行。 触发器的创建: 使用 CREATE TRIGGER 语句创建触发器。 触发器可以与 INSERT、UPDATE 和 DELETE 操作相关联。 触发器的优点: 自动执行: 触发器在特定事件发生时自动执行，无需手动调用。 维护数据完整性: 触发器可以用于强制执行复杂的业务规则和约束。 审计跟踪: 触发器可以用于记录对数据的修改，便于审计和追踪。 触发器的缺点: 性能开销: 触发器的执行会增加数据库操作的开销，尤其是在频繁操作的情况下。 复杂性: 触发器的逻辑可能变得复杂，难以维护和调试。 触发器的实例实例1：插入操作触发器假设我们有一个 employees 表，我们希望在每次插入新员工时，自动记录插入操作的时间。 1234567891011121314151617181920212223CREATE TABLE employees ( id INT PRIMARY KEY, name VARCHAR(100), hire_date DATETIME);CREATE TABLE audit_log ( log_id INT AUTO_INCREMENT PRIMARY KEY, action VARCHAR(10), log_date DATETIME);DELIMITER //CREATE TRIGGER trg_employees_insertAFTER INSERT ON employeesFOR EACH ROWBEGIN INSERT INTO audit_log (action, log_date) VALUES (&#x27;INSERT&#x27;, NOW());END //DELIMITER ; 在这个例子中，trg_employees_insert 触发器在每次向 employees 表插入新记录时自动执行，并将插入操作记录到 audit_log 表中。 实例2：更新操作触发器假设我们希望在每次更新 employees 表中的 hire_date 字段时，自动记录更新前后的值。 1234567891011DELIMITER //CREATE TRIGGER trg_employees_updateBEFORE UPDATE ON employeesFOR EACH ROWBEGIN INSERT INTO audit_log (action, log_date) VALUES (&#x27;UPDATE&#x27;, NOW());END //DELIMITER ; 在这个例子中，trg_employees_update 触发器在每次更新 employees 表中的记录时自动执行，并将更新操作记录到 audit_log 表中。 实例3：删除操作触发器假设我们希望在每次删除 employees 表中的记录时，自动记录删除操作。 1234567891011DELIMITER //CREATE TRIGGER trg_employees_deleteAFTER DELETE ON employeesFOR EACH ROWBEGIN INSERT INTO audit_log (action, log_date) VALUES (&#x27;DELETE&#x27;, NOW());END //DELIMITER ; 在这个例子中，trg_employees_delete 触发器在每次删除 employees 表中的记录时自动执行，并将删除操作记录到 audit_log 表中。 触发器的使用场景 数据完整性: 触发器可以用于强制执行复杂的业务规则和约束，例如在插入或更新数据时检查数据的合法性。 审计跟踪: 触发器可以用于记录对数据的修改，便于审计和追踪。 自动更新: 触发器可以用于自动更新相关表中的数据，例如在插入新订单时自动更新库存表。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"SQL索引","slug":"SQLIndex","date":"2024-09-22T08:33:15.000Z","updated":"2024-11-08T02:21:34.890Z","comments":true,"path":"2024/09/22/SQLIndex/","permalink":"http://example.com/2024/09/22/SQLIndex/","excerpt":"","text":"在SQL中，索引是一种数据结构，用于加速数据库表中数据的检索速度。索引类似于书籍的目录，可以帮助数据库系统快速定位到存储在表中的特定数据行，而不必扫描整个表。索引对于提高查询性能非常重要，尤其是在处理大型数据集时。 索引的基本概念 索引的类型: B-Tree 索引: 这是最常见的索引类型，适用于范围查询和排序操作。B-Tree（平衡树）索引能够保持数据的有序性，并且支持高效的插入、删除和查找操作。 哈希索引: 适用于等值查询，但不支持范围查询。哈希索引通过哈希函数将索引键映射到存储位置，查询速度非常快，但不适合排序操作。 全文索引: 用于全文搜索，支持对文本数据进行高效的搜索。 空间索引: 用于地理空间数据，支持空间查询操作。 索引的创建: 使用 CREATE INDEX 语句创建索引。例如：1CREATE INDEX idx_name ON table_name (column_name); 可以为一个或多个列创建索引。例如：1CREATE INDEX idx_name ON table_name (column1, column2); 索引的优点: 提高查询速度: 索引可以显著减少查询所需的时间，尤其是在大型表中。 加速排序和分组操作: 索引可以加速 ORDER BY 和 GROUP BY 操作。 唯一性约束: 索引可以用于强制列的唯一性，例如 UNIQUE 索引。 索引的缺点: 增加存储空间: 索引需要额外的存储空间。 降低写操作的速度: 插入、更新和删除操作需要更新索引，因此会降低这些操作的速度。 维护成本: 索引需要定期维护，以确保其有效性。 索引的使用场景 主键索引: 每个表通常都有一个主键索引，用于唯一标识表中的每一行。主键索引通常是唯一的，并且是自增的。 例如：1234CREATE TABLE employees ( id INT PRIMARY KEY, name VARCHAR(100)); 唯一索引: 用于确保列中的值是唯一的。 例如：1CREATE UNIQUE INDEX idx_email ON employees (email); 复合索引: 在多个列上创建的索引，适用于多列查询。 例如：1CREATE INDEX idx_name_department ON employees (name, department); 全文索引: 用于全文搜索，适用于文本数据。 例如：1CREATE FULLTEXT INDEX idx_content ON articles (content); 索引的维护 重建索引: 当索引变得碎片化时，可以通过重建索引来提高性能。 例如：1ALTER INDEX idx_name ON table_name REBUILD; 删除索引: 如果不再需要某个索引，可以将其删除以节省存储空间。 例如：1DROP INDEX idx_name ON table_name;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"SQL视图","slug":"SQLView","date":"2024-09-17T02:57:07.000Z","updated":"2024-11-08T02:21:34.890Z","comments":true,"path":"2024/09/17/SQLView/","permalink":"http://example.com/2024/09/17/SQLView/","excerpt":"","text":"视图SQL 中的视图（View）是一个虚拟表，它基于一个或多个表的查询结果。视图本身不存储数据，而是存储查询的定义。当你查询视图时，数据库引擎会执行视图定义的查询，并返回结果。视图可以简化复杂的查询，提供数据的安全性，并隐藏底层表的复杂性。 1. 创建视图（CREATE VIEW）你可以使用 CREATE VIEW 语句来创建视图。视图的定义可以包含 SELECT 语句中的所有元素，如 WHERE、GROUP BY、JOIN 等。 语法：1234CREATE VIEW view_name ASSELECT columnsFROM tablesWHERE conditions; 示例：假设我们有一个 employees 表和一个 departments 表，我们希望创建一个视图，显示每个员工的姓名、部门名称和工资： 1234CREATE VIEW employee_department_view ASSELECT employees.employee_name, departments.department_name, employees.salaryFROM employeesJOIN departments ON employees.department_id = departments.department_id; 2. 查询视图（SELECT）查询视图与查询表的方式相同。你可以像查询表一样查询视图。 示例：1SELECT * FROM employee_department_view; 3. 更新视图（UPDATE VIEW）在某些情况下，你可以通过视图更新底层表的数据。视图必须是可更新的，即视图的定义必须满足一定的条件（如没有 GROUP BY、HAVING、DISTINCT 等）。 示例：123UPDATE employee_department_viewSET salary = 6000WHERE employee_name = &#x27;Alice&#x27;; 4. 删除视图（DROP VIEW）你可以使用 DROP VIEW 语句删除视图。 语法：1DROP VIEW view_name; 示例：1DROP VIEW employee_department_view; 5. 修改视图（ALTER VIEW）在某些数据库系统中，你可以使用 ALTER VIEW 语句修改视图的定义。 语法：1234ALTER VIEW view_name ASSELECT columnsFROM tablesWHERE conditions; 示例：12345ALTER VIEW employee_department_view ASSELECT employees.employee_name, departments.department_name, employees.salaryFROM employeesJOIN departments ON employees.department_id = departments.department_idWHERE employees.salary &gt; 5000; 6. 视图的优点 简化查询:视图可以将复杂的查询封装起来，简化用户的查询操作。 数据安全:视图可以限制用户只能访问特定的数据，从而提高数据的安全性。 数据独立性:视图可以隐藏底层表的复杂性，使用户无需了解底层表的结构。 逻辑数据分组:视图可以将多个表的数据逻辑上组合在一起，方便用户进行数据分析。 7. 视图的缺点 性能问题:视图的查询性能可能不如直接查询底层表，尤其是在视图定义复杂的情况下。 更新限制:视图的更新操作受到限制，不是所有的视图都可以进行更新操作。 存储开销:虽然视图本身不存储数据，但视图的定义会占用存储空间。 注意1CreatE VIEW view_name AS 子查询语句 [WITH CHECK OPTION] WITH CHECK OPTION是指当创建后，如果更新视图中的数据，是否要满足子查询中的条件表达式，不满足将无法插入，创建后，我们就可以使用SELECT来直接查询视图上的数据，因此还能在视图上的基础导出其他视图 若视图是由两个以上的基本表导出的，则此视图不允许更新 若视图的字段来自地段表达式或常数，则不允许对此视图执行INSERT或UPDATE操作，但允许执行DELETE操作 若视图的字段来自集函数，则此视图不允许更新 若视图定义中含有GROUP BY或HAVING，则不允许更新 若视图定义中含有DISTINCT短语，则不允许更新 若视图定义中含有嵌套查询，并且内层查询的FROM子句中涉及的表也是导出该图的基本表，则此视图不允许更新。例如将成绩在平均成绩以上的元组定义成一个视图GOOD_SC: 12CREATE VIEW GOOD_SC AS SELECT Sno, Cno, Grade FROM SCWHERE Grade &gt; (SElECt AVG(Grade) FROM SC); 导出视图GOOD_SC的基本表是SC表，内层查询中涉及的基本表也是SC，所以视图GOOD_SC是不允许更新的 一个不允许更新的视图上定义的视图也不允许更新","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"SQL语句","slug":"SQLGRammar","date":"2024-09-17T02:01:46.000Z","updated":"2024-11-08T02:21:34.890Z","comments":true,"path":"2024/09/17/SQLGRammar/","permalink":"http://example.com/2024/09/17/SQLGRammar/","excerpt":"","text":"数据库定义语言(DDL)创建数据库1create database &lt;database_name&gt; 为了支持中文，我们需要在创建的时候可以修改编码格式 1CREATE DATABASE IF NOT EXISTS &lt;database_name&gt; DEFAULT CHARSET utf8 COLLATE utf8_general_ci 创建表12345create table &lt;table_name&gt;(列名 数据类型[列级约束条件], 列名 数据类型[列级约束条件], ... [, 表级约束条件]) SQL数据类型数值类型 (Numeric Types) 整数类型： TINYINT: 存储很小的整数，通常范围是 -128 到 127。 SMALLINT: 存储较小的整数，通常范围是 -32768 到 32767。 MEDIUMINT: MySQL 特有的类型，适合存储中等大小的整数。 INT 或 INTEGER: 存储普通大小的整数，通常范围是 -2147483648 到 2147483647。 BIGINT: 存储非常大的整数，通常范围是 -9223372036854775808 到 9223372036854775807。 UNSIGNED: 以上整数类型可以加上此属性以存储非负整数，范围从 0 开始。 小数类型： DECIMAL 或 NUMERIC: 用于存储精确的小数，格式为 DECIMAL(M, D)，其中 M 是数字总长度，D 是小数点后的位数。 FLOAT: 用于存储浮点数，可能丢失精度。 DOUBLE 或 REAL: 用于存储更高精度的浮点数。 位类型： BIT: 用于存储位字段值。 字符串类型 (String Types) 定长字符串： CHAR(n): 存储定长的字符串，其中 n 是字符串的最大长度。如果输入的字符串长度不够，会用空格填充。 变长字符串： VARCHAR(n): 存储变长的字符串，其中 n 是字符串的最大长度。 BINARY(n) 和 VARBINARY(n): 分别存储定长和变长的二进制字符串。 大对象类型： TEXT: 用于存储较大的文本数据。 BLOB: 用于存储较大的二进制数据。 MEDIUMTEXT 和 MEDIUMBLOB: MySQL 特有的类型，用于存储中等大小的文本或二进制数据。 LONGTEXT 和 LONGBLOB: MySQL 特有的类型，用于存储非常大的文本或二进制数据。 日期&#x2F;时间类型 (Date&#x2F;Time Types) 日期类型： DATE: 存储日期值。 TIME: 存储时间值。 YEAR: MySQL 特有的类型，用于存储四位数的年份。 日期时间类型： DATETIME: 存储日期和时间值，支持的范围通常是 1000-01-01 00:00:00 至 9999-12-31 23:59:59。 TIMESTAMP: 存储日期和时间值，并且在插入或更新时可以自动设置为当前的日期和时间。 INTERVAL: PostgreSQL 特有的类型，用于存储时间间隔。 其他类型 枚举类型： ENUM(&#39;value1&#39;, &#39;value2&#39;, ... ): 存储一系列预先定义的值中的一个。 集合类型： SET(&#39;value1&#39;, &#39;value2&#39;, ... ): 存储一系列预先定义的值中的一个或多个值。 JSON 类型： JSON: MySQL 8.0 之后支持的类型，用于存储 JSON 文档。 空间类型： POINT, LINESTRING, POLYGON, MULTIPOINT, MULTILINESTRING, MULTIPOLYGON, GEOMETRYCOLLECTION: 用于存储地理空间数据。 列级约束条件有六种:主键(Primary Key),非空(NotNull)&#x2F;空值null, 默认(Default),外键(外键约束),唯一键(Unique Key),检查约束(Check)(MySql不支持)、默认Default。 表级约束条件有四种：主键、外键、唯一、检查 1[CONSTRAINT &lt;外键名&gt;] FOREIGN KEY 字段名 [..., 字段名2, ...] REFERENCES &lt;主表名&gt; 主键列1 [, 主键列2, ...] 现在来创建三个表 12345678910111213141516171819mysql&gt; CREATE TABLE study(sid INT PRIMARY KEY, -&gt; name VARCHAR(10) NOT NULL, -&gt; sex ENUM(&#x27;male&#x27;, &#x27;female&#x27;) NOT NULL DEFAULT &#x27;male&#x27;);mysql&gt; CREATE TABLE teacher(tid INT PRIMARY KEY, -&gt; name VARCHAR(10) NOT NULL);CREATE TABLE teach ( tid INT NOT NULL, sid INT NOT NULL, CONSTRAINT f_tid FOREIGN KEY (tid) REFERENCES teacher(tid));-- mysql&gt; CREATE TABLE teach(tid int not null, sid int not null);-- mysql&gt; ALTER TABLE teach-- -&gt; ADD CONSTRAINT f_tid-- -&gt; FOREIGN KEY(tid)-- -&gt; REFERENCES teacher(tid); 修改表如果我们想要修改表结构，可以通过alter table进行修改 12345ALTER TABLE 表名[ADD 新列名 数据类型[列级约束条件]] [DROP COLUMN 列名[restrict|cascade]] [ALTER COLUMN 列名 数据类型] 删除表1DROP TABLE 表名[restrict|cascade] 数据库操作语言(DML)插入数据1INSERT INTO 表名 VALUES(值1, 值2, ...) 如果插入的数据与列一一对应，那么可以省略列名，但是如果希望向指定列上插入数据，就需要给出列名 1INSERT INTO 表名(列名1, 列名2, ...) VALUES(值1, 值2, ...) 也可以一次性向数据库中插入多条数据 1INSERT INTO 表名(列名1, 列名2, ...) VALUES(值1, 值2, ...), (值1, 值2, ...) 修改数据1UPDATE 表名 SET 列名 = 值, 列名 = 值, ... WHERE 条件 注意，SQL语句中等于判断是= 如果忘记加where来限定条件，那么将使得整个表的数据都被修改 删除数据删除全部数据 1DELETE FROM 表名 删除指定数据 1DELETE FROM 表名 WHERE 条件 数据库查询语言DQL单表查询只需要在一张表中查找数据，使用select语句即可 123456789101112-- 指定查询某一列数据SELECT 列名[, 列名] FROM 表名-- 会以别名来显示此列SELECT 列名 AS 别名 FROM 表名-- 查询所有列的数据SELECT * FROM 表名-- 只查询不重复的值SELECT DISTINCT 列名 FROM 表名-- 使用where来限定条件SELECT * FROM 表名 WHERE 条件 常用查询条件 一般的比较运算符=, &gt;, &lt;, &lt;=, &gt;=, != 是否会在集合中in, not in 字符模糊匹配like, not like 多重条件连接查询and, or, not 排序查询1SELECT * FROM 表名 WHERE 条件 ORDER BY 列名 ASC|DESC ASC 升序 DESC 降序 默认为升序 添加多个排序 1SELECT * FROM 表名 WHERE 条件 ORDER BY 列名1 ASC|DESC, 列名2 ASC|DESC 会先按照列名1进行排序，再按照列名2进行排序 聚集函数SQL 中的聚集函数（Aggregate Functions）用于对一组值执行计算，并返回单个值。这些函数通常用于对表中的数据进行汇总和分析。以下是一些常见的 SQL 聚集函数： 1. COUNT() 用途：计算表中行的数量或满足特定条件的行的数量。 示例：12SELECT COUNT(*) FROM employees; -- 计算 employees 表中的总行数SELECT COUNT(DISTINCT department) FROM employees; -- 计算 employees 表中不同部门的数量 2. SUM() 用途：计算某一列值的总和。 示例：1SELECT SUM(salary) FROM employees; -- 计算 employees 表中所有员工的总工资 3. AVG() 用途：计算某一列值的平均值。 示例：1SELECT AVG(salary) FROM employees; -- 计算 employees 表中所有员工的平均工资 4. MIN() 用途：返回某一列的最小值。 示例：1SELECT MIN(salary) FROM employees; -- 返回 employees 表中最低的工资 5. MAX() 用途：返回某一列的最大值。 示例：1SELECT MAX(salary) FROM employees; -- 返回 employees 表中最高的工资 6. GROUP_CONCAT() 用途：将某一列的值连接成一个字符串，通常用于将分组后的值合并。 示例：1SELECT department, GROUP_CONCAT(name) FROM employees GROUP BY department; -- 将每个部门的员工名字连接成一个字符串 7. VARIANCE() 和 STDDEV() 用途：计算某一列值的方差和标准差。 示例：12SELECT VARIANCE(salary) FROM employees; -- 计算 employees 表中工资的方差SELECT STDDEV(salary) FROM employees; -- 计算 employees 表中工资的标准差 8. BIT_AND(), BIT_OR(), BIT_XOR() 用途：对某一列的值执行按位与、按位或、按位异或操作。 示例：1SELECT BIT_AND(flags) FROM employees; -- 对 employees 表中的 flags 列执行按位与操作 使用聚集函数的注意事项： NULL 值：聚集函数通常会忽略 NULL 值。例如，SUM() 函数不会将 NULL 值计入总和。 GROUP BY 子句：聚集函数通常与 GROUP BY 子句一起使用，以便对数据进行分组并计算每个组的汇总值。 HAVING 子句：用于过滤分组后的结果，通常与 GROUP BY 子句一起使用。 示例：1234SELECT department, AVG(salary) AS avg_salaryFROM employeesGROUP BY departmentHAVING AVG(salary) &gt; 50000; 这个查询会计算每个部门的平均工资，并只返回平均工资大于 50000 的部门。 分组分页查询通过group by来对查询结果进行分组，需要结合聚集函数一起使用 在 MySQL 中，分组分页查询通常涉及使用 GROUP BY 子句对数据进行分组，然后使用 LIMIT 子句对结果进行分页。以下是详细解释和示例： 1. GROUP BY 子句GROUP BY 子句用于将数据按照一个或多个列进行分组。通常与聚集函数（如 COUNT, SUM, AVG, MIN, MAX 等）一起使用，以便对每个组进行汇总计算。 2. LIMIT 子句LIMIT 子句用于限制查询结果的行数。通常用于分页查询，通过指定起始行和返回的行数来实现分页。 示例：分组分页查询假设我们有一个 orders 表，结构如下： 123456CREATE TABLE orders ( order_id INT PRIMARY KEY, customer_id INT, order_date DATE, amount DECIMAL(10, 2)); 我们希望按 customer_id 分组，并计算每个客户的订单总金额，然后对结果进行分页。 查询每个客户的订单总金额123SELECT customer_id, SUM(amount) AS total_amountFROM ordersGROUP BY customer_id; 分页查询每个客户的订单总金额假设我们希望每页显示 10 个客户，查询第 2 页的数据（即第 11 到第 20 个客户）： 1234SELECT customer_id, SUM(amount) AS total_amountFROM ordersGROUP BY customer_idLIMIT 10 OFFSET 10; 解释： **LIMIT 10 OFFSET 10**： LIMIT 10 表示每页显示 10 行。 OFFSET 10 表示从第 11 行开始（因为 OFFSET 是从 0 开始计数的）。 LIMIT 起始位置, 数量 使用变量进行分页如果你希望动态地指定页码和每页的行数，可以使用变量： 1234567SET @page_number = 2; -- 页码，从 1 开始SET @page_size = 10; -- 每页的行数SELECT customer_id, SUM(amount) AS total_amountFROM ordersGROUP BY customer_idLIMIT @page_size OFFSET ((@page_number - 1) * @page_size); 注意事项： 性能问题：分组和分页查询可能会影响性能，尤其是在处理大量数据时。可以考虑使用索引来优化查询。 HAVING 子句：如果你需要在分组后对结果进行过滤，可以使用 HAVING 子句。例如，只显示订单总金额大于 1000 的客户：12345SELECT customer_id, SUM(amount) AS total_amountFROM ordersGROUP BY customer_idHAVING total_amount &gt; 1000LIMIT 10 OFFSET 10; 多表查询多表查询是同时查询两个或两个以上的表，多表查询会通过连接转换为单表查询 1SELECT * FROM 表1, 表2 直接这样查询会得到两张笛卡尔积，也就是每一项数据和另一张表的每一项数据都结合一次，会产生庞大的数据 1SELECT * FROM 表1, 表2 WHERE 条件 这样只会从笛卡尔积的结果中得到满足条件的数据 自身连接查询自身连接就是将表自身和表进行笛卡尔积计算，得到结果，但是由于表名相同，因此要先起一个别名 1SELECT * FROM 表1 AS t1, 表1 AS t2 外连接查询SQL 中的外连接（Outer Join）用于从两个或多个表中获取数据，即使某些行在连接条件中没有匹配的行。外连接分为三种类型：左外连接（Left Outer Join）、右外连接（Right Outer Join）和全外连接（Full Outer Join）。 假设我们现在有一张存储所有用户的表，还有一张用户详细信息的表，我们希望将这两张表结合到一起来查看完整数据 1. 左外连接（Left Outer Join）左外连接返回左表中的所有行，即使右表中没有匹配的行。如果右表中没有匹配的行，结果集中对应右表的列将为 NULL。 语法：1234SELECT columnsFROM left_tableLEFT JOIN right_tableON left_table.column = right_table.column; 示例：假设有两个表 employees 和 departments： 12345678910CREATE TABLE employees ( employee_id INT PRIMARY KEY, employee_name VARCHAR(100), department_id INT);CREATE TABLE departments ( department_id INT PRIMARY KEY, department_name VARCHAR(100)); 我们希望获取所有员工及其所属部门的信息，包括那些没有部门的员工： 1234SELECT employees.employee_name, departments.department_nameFROM employeesLEFT JOIN departmentsON employees.department_id = departments.department_id; 2. 右外连接（Right Outer Join）右外连接返回右表中的所有行，即使左表中没有匹配的行。如果左表中没有匹配的行，结果集中对应左表的列将为 NULL。 语法：1234SELECT columnsFROM left_tableRIGHT JOIN right_tableON left_table.column = right_table.column; 示例：我们希望获取所有部门及其员工的信息，包括那些没有员工的部门： 1234SELECT employees.employee_name, departments.department_nameFROM employeesRIGHT JOIN departmentsON employees.department_id = departments.department_id; 3. 全外连接（Full Outer Join）全外连接返回左表和右表中的所有行，即使它们在连接条件中没有匹配的行。如果某个表中没有匹配的行，结果集中对应另一个表的列将为 NULL。 语法：1234SELECT columnsFROM left_tableFULL OUTER JOIN right_tableON left_table.column = right_table.column; 示例：我们希望获取所有员工和所有部门的信息，包括那些没有部门或没有员工的记录： 1234SELECT employees.employee_name, departments.department_nameFROM employeesFULL OUTER JOIN departmentsON employees.department_id = departments.department_id; 注意事项： MySQL 不支持全外连接：MySQL 不直接支持 FULL OUTER JOIN，但可以通过 UNION 操作符来模拟全外连接。 模拟全外连接：123456789SELECT employees.employee_name, departments.department_nameFROM employeesLEFT JOIN departmentsON employees.department_id = departments.department_idUNIONSELECT employees.employee_name, departments.department_nameFROM employeesRIGHT JOIN departmentsON employees.department_id = departments.department_id; 总结外连接允许你从两个或多个表中获取数据，即使某些行在连接条件中没有匹配的行。左外连接返回左表中的所有行，右外连接返回右表中的所有行，全外连接返回两个表中的所有行。通过合理使用外连接，你可以更灵活地处理数据关联和缺失情况。 嵌套查询可以将查询的结果作为另一个查询的条件 1SELECT * FROM 表名 WHERE 列名 IN (SELECT 列名 FROM 表名 WHERE 条件); SQL 中的嵌套查询（Nested Query），也称为子查询（Subquery），是指在一个查询语句中嵌套另一个查询语句。子查询可以出现在 SELECT、FROM、WHERE、HAVING 等子句中，用于从数据库中获取更复杂的数据。 1. 子查询的基本概念子查询是一个完整的 SELECT 语句，它可以返回一个标量值（单个值）、一个行、一个列或一个表。子查询通常用括号 () 括起来，并且可以嵌套在主查询的各个部分。 2. 子查询的类型根据子查询返回的结果类型，子查询可以分为以下几种类型： 2.1 标量子查询（Scalar Subquery）标量子查询返回单个值（即一行一列）。它通常用于 SELECT 子句、WHERE 子句或 HAVING 子句中。 示例：假设我们有一个 employees 表和一个 departments 表，我们希望查询每个员工的姓名及其所属部门的名称： 12345SELECT employee_name, (SELECT department_name FROM departments WHERE departments.department_id = employees.department_id) AS department_nameFROM employees; 2.2 行子查询（Row Subquery）行子查询返回一行数据（即多列）。它通常用于 WHERE 子句中。 示例：假设我们希望查询工资最高的员工的姓名和工资： 1234SELECT employee_name, salaryFROM employeesWHERE (salary, employee_id) = (SELECT MAX(salary), employee_id FROM employees); 2.3 列子查询（Column Subquery）列子查询返回一列数据（即多行一列）。它通常用于 WHERE 子句中。 示例：假设我们希望查询所有工资高于平均工资的员工： 123SELECT employee_name, salaryFROM employeesWHERE salary &gt; (SELECT AVG(salary) FROM employees); 2.4 表子查询（Table Subquery）表子查询返回一个表（即多行多列）。它通常用于 FROM 子句中。 示例：假设我们希望查询每个部门的平均工资，并按平均工资排序： 123456SELECT department_name, avg_salaryFROM (SELECT department_id, AVG(salary) AS avg_salary FROM employees GROUP BY department_id) AS dept_avgJOIN departments ON dept_avg.department_id = departments.department_idORDER BY avg_salary DESC; 3. 子查询的位置子查询可以出现在以下位置： 3.1 SELECT 子句子查询可以出现在 SELECT 子句中，用于计算每个行的特定值。 示例：1234SELECT employee_name, salary, (SELECT AVG(salary) FROM employees) AS avg_salaryFROM employees; 3.2 FROM 子句子查询可以出现在 FROM 子句中，用于生成一个临时表，供主查询使用。 示例：12345SELECT department_name, avg_salaryFROM (SELECT department_id, AVG(salary) AS avg_salary FROM employees GROUP BY department_id) AS dept_avgJOIN departments ON dept_avg.department_id = departments.department_id; 3.3 WHERE 子句子查询可以出现在 WHERE 子句中，用于过滤数据。 示例：123SELECT employee_name, salaryFROM employeesWHERE salary &gt; (SELECT AVG(salary) FROM employees); 3.4 HAVING 子句子查询可以出现在 HAVING 子句中，用于过滤分组后的数据。 示例：1234SELECT department_id, AVG(salary) AS avg_salaryFROM employeesGROUP BY department_idHAVING AVG(salary) &gt; (SELECT AVG(salary) FROM employees); 4. 注意事项 性能问题：嵌套查询可能会影响性能，尤其是在处理大量数据时。可以考虑使用连接（Join）或其他优化方法来替代嵌套查询。 相关子查询：相关子查询是指子查询依赖于外部查询的值。相关子查询通常会导致性能问题，因为它们会对外部查询的每一行执行一次子查询。 数据库控制语言DCL创建用户1CREATE USER &lt;username&gt; IDENTIFIED BY &lt;password&gt; 也可以不带密码 1CREATE USER &lt;username&gt; 登录用户1mysql -u &lt;username&gt; -p &lt;password&gt; 用户授权1. GRANTGRANT 命令用于授予用户或角色对数据库对象（如表、视图、存储过程等）的访问权限。 语法：1GRANT privileges ON object TO user_or_role; 参数说明： privileges：要授予的权限，可以是 SELECT, INSERT, UPDATE, DELETE, ALL PRIVILEGES 等。 object：要授予权限的数据库对象，如表、视图、存储过程等。 user_or_role：要授予权限的用户或角色。 示例：12345678-- 授予用户 &#x27;alice&#x27; 对表 &#x27;employees&#x27; 的 SELECT 权限GRANT SELECT ON employees TO alice;-- 授予用户 &#x27;bob&#x27; 对表 &#x27;employees&#x27; 的所有权限GRANT ALL PRIVILEGES ON employees TO bob;-- 授予角色 &#x27;developers&#x27; 对数据库 &#x27;mydb&#x27; 的所有权限GRANT ALL PRIVILEGES ON DATABASE mydb TO developers; 2. REVOKEREVOKE 命令用于撤销用户或角色对数据库对象的访问权限。 语法：1REVOKE privileges ON object FROM user_or_role; 参数说明： **privileges**：要撤销的权限，可以是 SELECT, INSERT, UPDATE, DELETE, ALL PRIVILEGES 等。 **object**：要撤销权限的数据库对象，如表、视图、存储过程等。 **user_or_role**：要撤销权限的用户或角色。 示例：12345678-- 撤销用户 &#x27;alice&#x27; 对表 &#x27;employees&#x27; 的 SELECT 权限REVOKE SELECT ON employees FROM alice;-- 撤销用户 &#x27;bob&#x27; 对表 &#x27;employees&#x27; 的所有权限REVOKE ALL PRIVILEGES ON employees FROM bob;-- 撤销角色 &#x27;developers&#x27; 对数据库 &#x27;mydb&#x27; 的所有权限REVOKE ALL PRIVILEGES ON DATABASE mydb FROM developers; 3. DENYDENY 命令用于显式拒绝用户或角色对数据库对象的访问权限。与 REVOKE 不同，DENY 会阻止用户通过角色或其他方式继承权限。 语法：1DENY privileges ON object TO user_or_role; 参数说明： **privileges**：要拒绝的权限，可以是 SELECT, INSERT, UPDATE, DELETE, ALL PRIVILEGES 等。 **object**：要拒绝权限的数据库对象，如表、视图、存储过程等。 **user_or_role**：要拒绝权限的用户或角色。 示例：12345678-- 拒绝用户 &#x27;alice&#x27; 对表 &#x27;employees&#x27; 的 SELECT 权限DENY SELECT ON employees TO alice;-- 拒绝用户 &#x27;bob&#x27; 对表 &#x27;employees&#x27; 的所有权限DENY ALL PRIVILEGES ON employees TO bob;-- 拒绝角色 &#x27;developers&#x27; 对数据库 &#x27;mydb&#x27; 的所有权限DENY ALL PRIVILEGES ON DATABASE mydb TO developers; 4. CREATE ROLE 和 DROP ROLECREATE ROLE 和 DROP ROLE 命令用于创建和删除角色。角色是一组权限的集合，可以授予用户或其他角色。 语法：12CREATE ROLE role_name;DROP ROLE role_name; 示例：12345-- 创建一个名为 &#x27;developers&#x27; 的角色CREATE ROLE developers;-- 删除名为 &#x27;developers&#x27; 的角色DROP ROLE developers; 5. ALTER ROLEALTER ROLE 命令用于修改角色的属性，如重命名角色、修改角色的默认配置等。 语法：1ALTER ROLE role_name WITH options; 示例：12345-- 重命名角色 &#x27;developers&#x27; 为 &#x27;devs&#x27;ALTER ROLE developers RENAME TO devs;-- 修改角色 &#x27;devs&#x27; 的默认配置ALTER ROLE devs WITH LOGIN; 6. SET ROLESET ROLE 命令用于在当前会话中切换角色。 语法：1SET ROLE role_name; 示例：12-- 在当前会话中切换到角色 &#x27;developers&#x27;SET ROLE developers;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"数据库设计规范","slug":"DataBaseDesign","date":"2024-09-15T07:47:19.000Z","updated":"2024-11-08T02:21:34.889Z","comments":true,"path":"2024/09/15/DataBaseDesign/","permalink":"http://example.com/2024/09/15/DataBaseDesign/","excerpt":"","text":"数据库范式数据库范式是一套用于设计关系数据库的规范化标准，其目的是减少数据冗余并提高数据的完整性和一致性。范式化是一种将数据库表设计成符合一定级别的过程，每个级别称为一个范式。通过范式化，可以减少数据存储中的冗余，同时避免潜在的数据不一致问题。 数据库范式通常分为六个级别，其中最常用的是前三范式（1NF、2NF、3NF）： 1. 第一范式 (1NF) 第一范式要求表中的每一列都是不可分割的原子值，即每个单元格中只包含一个值。这确保了表中的每一列都是单一的事实，而不是列表或集合。例如，如果有一个“联系方式”列包含了电话号码和电子邮件地址，则这样的设计就不符合第一范式。 不符合1NF的例子：假设我们有一个学生表，记录学生的姓名和他们所选的课程： 学号 姓名 课程 S001 张三 数学, 物理 S002 李四 英语 这个表不是1NF，因为“课程”这一列包含了多个值（数学和物理），而1NF要求每一列都应该是原子的，即不可再分。 符合1NF的例子：为了使上述表符合1NF，我们可以将其拆分成两个表： 学生表： 学号 姓名 S001 张三 S002 李四 选课表： 学号 课程 S001 数学 S001 物理 S002 英语 2. 第二范式 (2NF) 第二范式建立在第一范式的基础上，要求所有的非主键字段完全依赖于主键。这意味着表中的非主键字段不能部分依赖于主键的一部分。例如，如果主键是一个复合键，那么所有非主键字段都必须依赖于整个复合键，而不仅仅是部分主键。 不符合2NF的例子：假设我们有一个员工表，记录员工的基本信息以及部门信息： 员工ID 名字 部门名称 部门地址 E001 王五 销售 北京 E002 赵六 技术 上海 这里的问题在于，部门名称和部门地址是依赖于部门的，而不是单独依赖于员工ID。如果部门信息发生变化，就需要在每个员工记录中更新，这样容易导致数据不一致。 符合2NF的例子：为了使上述表符合2NF，我们需要将部门信息提取出来： 员工表： 员工ID 名字 部门ID E001 王五 D001 E002 赵六 D002 部门表： 部门ID 部门名称 部门地址 D001 销售 北京 D002 技术 上海 3. 第三范式 (3NF) 第三范式进一步加强了第二范式的要求，它要求所有非主键字段直接依赖于主键，而不是通过另一个非主键字段间接依赖于主键（即避免传递依赖）。例如，如果存在一个表，其中一个非主键字段依赖于另一个非主键字段，那么就需要将它们分离到不同的表中。 不符合3NF的例子：考虑以下一个学生-课程-教师的示例： 学号 课程编号 教师编号 教师姓名 S001 C001 T001 刘老师 S002 C002 T002 陈老师 在这个表中，教师姓名直接与学生关联，而没有直接依赖于主键（学号），而是依赖于教师编号。这是一个传递依赖的例子，因此不符合3NF。 符合3NF的例子：为了使上述表符合3NF，我们需要创建一个新的教师表： 学生表： 学号 课程编号 教师编号 S001 C001 T001 S002 C002 T002 教师表： 教师编号 教师姓名 T001 刘老师 T002 陈老师 除了这三个主要的范式之外，还有更高层次的范式： 4. BCNF (Boys-Codd范式) BCNF范式要求每个决定因素都是一个超键。这意味着除了主键之外，没有任何其他字段可以决定任何非键字段。 不符合BCNF的例子：假设我们有一个图书作者表，记录书籍的信息以及作者的信息： 图书ID 书名 作者ID 作者名 作者国籍 B001 梦幻森林 A001 小明 中国 B002 星际旅行 A002 小红 美国 B003 梦幻森林 A001 小明 中国 在这个表中，作者名和作者国籍依赖于作者ID，而不是直接依赖于图书ID。此外，如果我们只改变某本书的作者信息，那么所有包含该作者的记录都需要更新。这表明存在部分依赖（作者名和作者国籍依赖于作者ID）和传递依赖（作者国籍依赖于作者ID），这使得该表不符合BCNF的要求。 符合BCNF的例子：为了使上述表符合BCNF，我们需要将作者信息分离到另一个表中： 图书表： 图书ID 书名 作者ID B001 梦幻森林 A001 B002 星际旅行 A002 B003 梦幻森林 A001 作者表： 作者ID 作者名 作者国籍 A001 小明 中国 A002 小红 美国 现在，图书表中的每一项都是基于图书ID和作者ID这两个组合键，而作者表中的每一项都是基于作者ID。在这种情况下，没有任何非平凡函数依赖涉及非候选键的情况，因此这两个表都符合BCNF的要求。 5. 第四范式 (4NF) 第四范式是在BCNF的基础上进一步消除非平凡的多值依赖。 6. 第五范式 (5NF)： 第五范式，也被称为完美范式或PJ范式，关注的是关系模式在连接操作后的数据一致性。 范式化的过程通常涉及到将数据分解成多个相互关联的表，以确保每个表都有一个明确的主题或目的，并且表中的每个字段都直接依赖于主键。虽然遵循范式可以带来许多好处，但在实际应用中，有时候为了提高查询性能或其他原因，可能会选择不完全遵循这些范式，而是采用一定程度的反范式化（denormalization）。 关于键: 超键(super key): 在关系中能唯一标识元组的属性集称为关系模式的超键只要含有“学号”或者“身份证号”两个属性的集合就叫超键，例如R1（学号 性别）、R2（身份证号 身高）、R3（学号 身份证号）等等都可以称为超键！ 候选键(candidate key): 不含有多余属性的超键称为候选键。也就是在候选键中，若再删除属性，就不是键了！不含有多余的属性的超键，比如（学号）、（身份证号）都是候选键，又比如R1中学号这一个属性就可以唯一标识元组了，而有没有性别这一属性对是否唯一标识元组没有任何的影响！ 主键(primary key): 用户选作元组标识的一个候选键程序主键就是用户从很多候选键选出来的一个键就是主键，比如你要求学号是主键，那么身份证号就不可以是主键了 外键(foreign key)：如果关系模式R中属性K是其它模式的主键，那么k在模式R中称为外键。 宿舍号就是学生信息表的外键","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"QT信号和槽","slug":"QT-Signal","date":"2024-08-27T02:23:12.000Z","updated":"2024-11-08T02:21:34.889Z","comments":true,"path":"2024/08/27/QT-Signal/","permalink":"http://example.com/2024/08/27/QT-Signal/","excerpt":"","text":"信号和槽当我们需要一个界面通知另一个界面时，可以采用信号和槽机制。通过链接信号和槽，当一个界面发送信号时，链接该信号的槽会被响应，从而达到消息传递的目的。 我们先创建两个界面并为两个界面添加一个按钮，通过按钮的点击来实现界面的切换 主界面 先实现主界面的点击按钮功能，并在终端打印一条信息”show child dialog”现在MainWindow的构造函数中添加信号和槽的逻辑连接 1connect(ui-&gt;showChildButton, SIGNAL(clicked()), this, SLOT(showChildDialog())); 然后在MainWindow的头文件中添加槽函数，槽函数需要slots声明 12public slots: void showChildDialog(); 接下来实现该函数 123void MainWindow::showChildDialog() &#123; qDebug() &lt;&lt; &quot;show child dialog&quot; &lt;&lt; endl;&#125; 子界面 不同的连接方式上面我们使用的是qt4的连接方式，用SIGNAL和SLOT将信号和槽转化为字符串。但是这种方式存在一个问题，qt要求槽函数的参数不能超过信号定义的参数，比如我们用到的信号clicked(bool)参数就是bool，我们定义的槽函数showChildDialog()参数是不带参数的，可以连接成功，如果我们在连接的时候将showChildDialog()的参数写成三个，也可以连接成功 12// qt4 style 连接信号和槽connect(ui-&gt;showChildButton, SIGNAL(clicked(bool)), SLOT(showChildDialog(1, 2, 3))); 但是点击会没有反应，说明qt4 这种连接信号和槽的方式不做编译检查，只是将信号和槽函数转译成字符串。 推荐qt5的连接方式 12345connect(_child_dialog, &amp;ChildDialog::showMainSig, this, &amp;MainWindow::showMainDialog);connect(_child_dialog, &amp;ChildDialog::showMainSig, this, [this]() &#123; this-&gt;_child_dialog-&gt;hide(); this-&gt;show();&#125;); 实现界面切换在MainWindow类中，加入一个子界面类的指针，方便访问 123456789101112131415class MainWindow : public QMainWindow&#123; Q_OBJECTpublic: MainWindow(QWidget *parent = nullptr); ~MainWindow();public slots: void showChildDialog(); void showMainDialog();private: Ui::MainWindow *ui; ChildDialog *_child_dialog;&#125;; 然后改写槽函数，当单击按钮时弹出对话框 12345void MainWindow::showChildDialog()&#123; _child_dialog-&gt;show(); this-&gt;hide();&#125; 这么做有一个问题就是可能会重复创建子窗口，但是Qt的对象树机制会保证父窗口回收时才回收子窗口，所以关闭子窗口只是隐藏了。那么随着点击，久而久之窗口会越来越多。我们想到的一个避免重复创建的办法就是在MainWindow的构造函数里创建好子界面，在槽函数中只控制子界面的显示即可。但同时要注意在MainWindow的析构函数里回收子界面类对象。 1234567891011121314151617181920212223242526MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) , ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); _child_dialog = new ChildDialog(this); // qt4 style 连接信号和槽 // connect(ui-&gt;showChildButton, SIGNAL(clicked(bool)), SLOT(showChildDialog())); // qt5 style(recommend) connect(ui-&gt;showChildButton, &amp;QPushButton::clicked, this, &amp;MainWindow::showChildDialog); // connect(_child_dialog, &amp;ChildDialog::showMainSig, this, &amp;MainWindow::showMainDialog); connect(_child_dialog, &amp;ChildDialog::showMainSig, this, [this]() &#123; this-&gt;_child_dialog-&gt;hide(); this-&gt;show(); &#125;);&#125;MainWindow::~MainWindow()&#123; delete ui; if (_child_dialog != nullptr) &#123; delete _child_dialog; _child_dialog = nullptr; &#125;&#125; 这样我们频繁点击显示子界面按钮就不会重复创建窗口了。那接下来实现点击主界面的按钮，显示子界面，并隐藏主窗口。实现点击子界面的按钮，显示主窗口，并隐藏子界面。先实现点击子界面按钮显示主窗口，我们可以在ChildDialog类修改下构造函数，使其接受一个QWidget指针，这个指针指向父窗口也就是MainWindow.我们新增成员_parent用来存储MainWindow。新增槽函数showMainWindow用来显示主窗口。 123456789101112131415class ChildDialog : public QDialog&#123; Q_OBJECTsignals: void showMainSig();public: explicit ChildDialog(QWidget *parent = nullptr); ~ChildDialog(); void showMainWindow();private: Ui::ChildDialog *ui; QWidget *_parent;&#125;; 实现槽函数 12345void ChildDialog::showMainWindow()&#123; this-&gt;hide(); emit showMainSig(); //发出信号&#125; 在MainWindow连接这个信号 12345678910111213141516MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) , ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); _child_dialog = new ChildDialog(this); // qt4 style 连接信号和槽 // connect(ui-&gt;showChildButton, SIGNAL(clicked(bool)), SLOT(showChildDialog())); // qt5 style(recommend) connect(ui-&gt;showChildButton, &amp;QPushButton::clicked, this, &amp;MainWindow::showChildDialog); // connect(_child_dialog, &amp;ChildDialog::showMainSig, this, &amp;MainWindow::showMainDialog); connect(_child_dialog, &amp;ChildDialog::showMainSig, this, [this]() &#123; this-&gt;_child_dialog-&gt;hide(); this-&gt;show(); &#125;);&#125; 连接信号上面的程序还可以进一步优化，因为Qt提供了信号连接信号的方式，也就是说我们可以把子界面的按钮点击信号和showMainSig信号连接起来。 12345678ChildDialog::ChildDialog(QWidget *parent) : QDialog(parent) , ui(new Ui::ChildDialog) , _parent(parent)&#123; ui-&gt;setupUi(this); connect(ui-&gt;showMainWindow, &amp;QPushButton::clicked, this, &amp;ChildDialog::showMainSig);&#125; 将clicked和showMainSig两个信号连接起来，也可以实现消息的传递。","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"},{"name":"QT","slug":"QT","permalink":"http://example.com/tags/QT/"}]},{"title":"asio-IOServicePool","slug":"asio-IOServicePool","date":"2024-08-24T14:51:44.000Z","updated":"2024-11-08T02:21:34.890Z","comments":true,"path":"2024/08/24/asio-IOServicePool/","permalink":"http://example.com/2024/08/24/asio-IOServicePool/","excerpt":"","text":"简介IOServicePool是一个用于管理多个io_context实例的多线程模型，每一个线程管理一个io_context，它的主要目的是在多线程环境中高效地分发和异步处理I&#x2F;O操作 单线程和多线程对比单线程模式图 多线程模式图 优点 每一个io_context跑在不同的线程里，所以同一个socket会被注册在同一个io_context里，它的回调函数也会被单独的一个线程回调，那么对于同一个socket，他的回调函数每次触发都是在同一个线程里，就不会有线程安全问题，网络io层面上的并发是线程安全的。 但是对于不同的socket，回调函数的触发可能是同一个线程(两个socket被分配到同一个io_context)，也可能不是同一个线程(两个socket被分配到不同的io_context里)。所以如果两个socket对应的上层逻辑处理，如果有交互或者访问共享区，会存在线程安全问题。比如socket1代表玩家1，socket2代表玩家2，玩家1和玩家2在逻辑层存在交互，比如两个玩家都在做工会任务，他们属于同一个工会，工会积分的增加就是共享区的数据，需要保证线程安全。可以通过加锁或者逻辑队列的方式解决安全问题，我们目前采取了后者。 多线程相比单线程，极大的提高了并发能力，因为单线程仅有一个io_context服务用来监听读写事件，就绪后回调函数在一个线程里串行调用, 如果一个回调函数的调用时间较长肯定会影响后续的函数调用，毕竟是穿行调用。而采用多线程方式，可以在一定程度上减少前一个逻辑调用影响下一个调用的情况，比如两个socket被部署到不同的iocontext上，但是当两个socket部署到同一个iocontext上时仍然存在调用时间影响的问题。不过我们已经通过逻辑队列的方式将网络线程和逻辑线程解耦合了，不会出现前一个调用时间影响下一个回调触发的问题。 IOServicePool实现IOServicePool本质上是一个线程池，基本功能就是根据构造函数传入的数量创建n个线程和iocontext，然后每个线程跑一个iocontext，这样就可以并发处理不同iocontext读写事件了。声明如下： 12345678910111213141516171819202122232425262728293031323334#pragma once// NOTE:// 如果要使用这个线程池的话，// 将CServer的io_context替换为AsioIOServicePool::GetInstance()-&gt;get_io_service()// main函数需要给服务器创建一个io_context#include &lt;thread&gt;#include &lt;boost/asio.hpp&gt;#include &lt;memory&gt;#include &lt;vector&gt;#include &quot;Singleton.hpp&quot;class AsioIOServicePool : public Singleton&lt;AsioIOServicePool&gt; &#123; friend class Singleton&lt;AsioIOServicePool&gt;;public: using IOService = boost::asio::io_context; using Work = boost::asio::io_context::work; using WorkPtr = std::unique_ptr&lt;Work&gt;; ~AsioIOServicePool(); AsioIOServicePool( const AsioIOServicePool &amp; ) = delete; AsioIOServicePool &amp;operator=( const AsioIOServicePool &amp; ) = delete; boost::asio::io_context &amp;get_io_service(); void Stop();private: explicit AsioIOServicePool( size_t thread_size = std::thread::hardware_concurrency() ); std::vector&lt;IOService&gt; _ioServices; std::vector&lt;WorkPtr&gt; _works; std::vector&lt;std::thread&gt; _threads; std::size_t _nextIOservice; // 轮询索引&#125;; 实现如下： 12345678910111213141516171819202122232425262728293031AsioIOServicePool::AsioIOServicePool(size_t thread_size) : _ioServices(thread_size), _works(thread_size), _nextIOservice(0) &#123; for (size_t i = 0; i &lt; thread_size; ++i) &#123; _works[i] = std::make_unique&lt;Work&gt;(Work(_ioServices[i])); &#125; for (auto &amp;IOService : _ioServices) &#123; _threads.emplace_back([this, &amp;IOService]() &#123; IOService.run(); &#125;); &#125;&#125;boost::asio::io_context &amp;AsioIOServicePool::get_io_service() &#123; auto &amp;service = _ioServices[_nextIOservice++ % _ioServices.size()]; return service;&#125;void AsioIOServicePool::Stop() &#123; for (auto &amp;work : _works) &#123; work.reset(); &#125; for (auto &amp;t : _threads) &#123; t.join(); &#125;&#125;AsioIOServicePool::~AsioIOServicePool() &#123; std::cout &lt;&lt; &quot;AsioIOServicePool destroyed&quot; &lt;&lt; std::endl;&#125; 这段代码实现了一个基于 boost::asio 的 I&#x2F;O 服务池（AsioIOServicePool），并使用了单例模式（通过 Singleton&lt;AsioIOServicePool&gt;）来确保全局只有一个实例。以下是对代码的详细解释： 类定义12345678910111213141516171819202122class AsioIOServicePool : public Singleton&lt;AsioIOServicePool&gt; &#123; friend class Singleton&lt;AsioIOServicePool&gt;;public: using IOService = boost::asio::io_context; using Work = boost::asio::io_context::work; using WorkPtr = std::unique_ptr&lt;Work&gt;; ~AsioIOServicePool(); AsioIOServicePool( const AsioIOServicePool &amp; ) = delete; AsioIOServicePool &amp;operator=( const AsioIOServicePool &amp; ) = delete; boost::asio::io_context &amp;get_io_service(); void Stop();private: explicit AsioIOServicePool( size_t thread_size = std::thread::hardware_concurrency() ); std::vector&lt;IOService&gt; _ioServices; std::vector&lt;WorkPtr&gt; _works; std::vector&lt;std::thread&gt; _threads; std::size_t _nextIOservice; // 轮询索引&#125;; AsioIOServicePool 继承自 Singleton&lt;AsioIOServicePool&gt;，确保它是单例的。 friend class Singleton&lt;AsioIOServicePool&gt;;：允许 Singleton 类访问 AsioIOServicePool 的私有成员。 使用 using 别名定义了 IOService、Work 和 WorkPtr。 删除了拷贝构造函数和赋值操作符，防止对象被复制。 get_io_service() 方法用于获取一个 io_context 实例。 Stop() 方法用于停止所有 io_context 并等待线程结束。 私有构造函数 AsioIOServicePool 接受一个线程数量参数，默认为硬件并发数。 成员变量包括 _ioServices（io_context 数组）、_works（工作对象数组）、_threads（线程数组）和 _nextIOservice（轮询索引）。 实现文件1234567891011AsioIOServicePool::AsioIOServicePool(size_t thread_size) : _ioServices(thread_size), _works(thread_size), _nextIOservice(0) &#123; for (size_t i = 0; i &lt; thread_size; ++i) &#123; _works[i] = std::make_unique&lt;Work&gt;(Work(_ioServices[i])); &#125; for (auto &amp;IOService : _ioServices) &#123; _threads.emplace_back([this, &amp;IOService]() &#123; IOService.run(); &#125;); &#125;&#125; 构造函数初始化 _ioServices、_works 和 _nextIOservice。 为每个 io_context 创建一个 Work 对象，防止 io_context 在没有工作时退出。 为每个 io_context 创建一个线程，并在该线程中运行 io_context。 1234boost::asio::io_context &amp;AsioIOServicePool::get_io_service() &#123; auto &amp;service = _ioServices[_nextIOservice++ % _ioServices.size()]; return service;&#125; get_io_service() 方法通过轮询方式返回一个 io_context 实例。 123456789void AsioIOServicePool::Stop() &#123; for (auto &amp;work : _works) &#123; work.reset(); &#125; for (auto &amp;t : _threads) &#123; t.join(); &#125;&#125; Stop() 方法重置所有 Work 对象，使 io_context 可以退出。 等待所有线程结束。 123AsioIOServicePool::~AsioIOServicePool() &#123; std::cout &lt;&lt; &quot;AsioIOServicePool destroyed&quot; &lt;&lt; std::endl;&#125; 析构函数输出一条消息，表示对象被销毁。 关于优雅退出IOServicePool多线程服务器退出时，需要捕获退出信号如SIGINT、SIGTERM等，然后通知所有线程退出，然后等待线程结束，将退出信号和一个io_context绑定，当接收到退出信号时，我们将IOServicePool中的io_context退出，然后等待所有线程退出，最后销毁线程池。 12345678910111213141516int main() &#123; try &#123; auto pool = AsioIOServicePool::GetInstance(); boost::asio::io_context io_context; boost::asio::signal_set signals(io_context, SIGINT, SIGTERM); signals.async_wait([&amp;io_context,pool](auto, auto) &#123; io_context.stop(); pool-&gt;Stop(); &#125;); CServer s(io_context, 10086); io_context.run(); &#125; catch (std::exception&amp; e) &#123; std::cerr &lt;&lt; &quot;Exception: &quot; &lt;&lt; e.what() &lt;&lt; endl; &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"},{"name":"网络编程","slug":"网络编程","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"socket","slug":"socket","permalink":"http://example.com/tags/socket/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"protobuf的配置和使用","slug":"protobuf-configuration","date":"2024-08-01T02:59:34.000Z","updated":"2024-11-08T02:21:34.892Z","comments":true,"path":"2024/08/01/protobuf-configuration/","permalink":"http://example.com/2024/08/01/protobuf-configuration/","excerpt":"","text":"protobuf简介Protocol Buffers（简称 protobuf）是 Google 开发的一种数据交换格式。它是一种灵活、高效且自动化的结构化数据序列化方法，类似于 XML、JSON 和其他配置文件格式，但更小、更快、更简单。我们的逻辑是有类等抽象数据构成的，而tcp是面向字节流的，我们需要将类结构序列化为字符串来传输。 主要特点： 语言无关：protobuf 支持多种编程语言，包括 C++、Java、Python 等，并且可以轻松地在不同语言之间进行通信。 平台无关：可以跨多个平台使用，无论是在 32 位还是 64 位系统上。 效率高：相比于 XML 或 JSON，protobuf 在序列化和反序列化时的性能更好，生成的数据也更紧凑。 编译protobuf如果是linux系统，可以直接从自己的包管理器下载protobuf 例如archlinux 1yay -S protobuf 如果是windows系统，我们需要从官网 下载源代码进行编译 具体教程 当protobuf编译完成后，我们可以通过protobuf --version来检查是否安装成功 使用流程 定义消息格式：首先需要定义消息的结构，这通常是通过 .proto 文件完成的。这些文件描述了你想要交换的数据的结构。 我们先创建一个msg.proto文件，并且写入如下内容 1234567syntax = &quot;proto3&quot;;message Book&#123; string name = 1; int32 pages = 2; float price = 3;&#125; 这个文件用来定义我们需要发送的信息 编译 .proto 文件：使用 Protocol Buffers 编译器（protoc），根据 .proto 文件生成特定语言的源代码 1protoc --cpp_out=. ./msg.proto .&#x2F;msg.proto 表示msg.proto所在的位置，因为我们是在msg.proto所在文件夹中执行的protoc命令,所以是当前路径即可。执行后，会看到当前目录生成了msg.pb.h和msg.pb.cc两个文件，这两个文件就是我们要用到的头文件和cpp文件。 序列化与反序列化：使用生成的类来创建消息对象，并将这些对象序列化为字节流，或者从字节流中反序列化为对象。 这里我们写一个测试函数 12345678910111213141516void test_protobuf() &#123; Book book; book.set_name(&quot;CPP programing&quot;); book.set_pages(100); book.set_price(200); std::string bookstr; book.SerializeToString(&amp;bookstr); std::cout &lt;&lt; &quot;serialize str is &quot; &lt;&lt; bookstr &lt;&lt; std::endl; Book book2; book2.ParseFromString(bookstr); std::cout &lt;&lt; &quot;book2 name is &quot; &lt;&lt; book2.name() &lt;&lt; &quot; price is &quot; &lt;&lt; book2.price() &lt;&lt; &quot; pages is &quot; &lt;&lt; book2.pages() &lt;&lt; std::endl; getchar();&#125; 输出如下： 123serialize str isCPP programingdHCbook2 name is CPP programing price is 200 pages is 100 上面的demo中将book对象先序列化为字符串，再将字符串反序列化为book2对象。 在网络中的应用先为服务器定义一个用来通信的protobuf 123456syntax = &quot;proto3&quot;;message MsgData&#123; int32 id = 1; string data = 2;&#125; id代表消息的编号，data代表消息的内容 接着修改服务器接收和发送数据的逻辑当服务器收到数据并完成切包处理，将信息反序列化为具体要使用的结构，打印相关信息，然后再发送给客户端 12345678910111213Data msgdata;std::string receive_data;msgdata.ParseFromString( std::string( _recv_msg_node-&gt;_msg, _recv_msg_node-&gt;_total_len ) );std::cout &lt;&lt; &quot;Recv msg is: &quot; &lt;&lt; msgdata.data() &lt;&lt; std::endl;std::string return_str = &quot;server has receive msg, msg data is &quot; + msgdata.data();Data msgreturn;msgreturn.set_id( msgdata.id() );msgreturn.set_data( msgdata.data() );msgreturn.SerializeToString( &amp;return_str );Send( return_str ); 同样，客户端在发送的时候也利用protobu进行消息序列化，然后发送给服务器 12345678910Data msgdata;msgdata.set_id( 1001 );msgdata.set_data( &quot;Hello world!&quot; );std::string request;msgdata.SerializeToString( &amp;request );std::cout &lt;&lt; &quot;message id: &quot; &lt;&lt; msgdata.id() &lt;&lt; &quot; content: &quot; &lt;&lt; msgdata.data() &lt;&lt; std::endl;boost::asio::write( sock, boost::asio::buffer( request, request.length() ) ); 关于protbuf在CMake中的配置 注意一定要在编译参数中加入-Wl,--copy-dt-needed-entries，否则会报DSO missing 1234set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -g -O2 -Wall -Wextra -Weffc++ -Werror=uninitialized -Werror=return-type -Wconversion -Wsign-compare -Werror=unused-result -Werror=suggest-override -Wzero-as-null-pointer-constant -Wmissing-declarations -Wold-style-cast -Wnon-virtual-dtor -Wl,--copy-dt-needed-entries&quot;) 关于对proto文件的配置，可以参考这个 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# 获取编译器find_program( PROTOC_CXX protoc DOC &quot;Protobuf Compiler (protoc)&quot; REQUIRED)# 需要编译的 proto 文件file (GLOB PROTO_SOURCE_FILES &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/*.proto&quot;)set(PROTO_PATH &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&quot;)set(PROTO_CXX_OUT &quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/gen_cxx&quot;)file(MAKE_DIRECTORY $&#123;PROTO_CXX_OUT&#125;)# 使用 protoc 处理 proto 文件foreach(input_proto $&#123;PROTO_SOURCE_FILES&#125;) get_filename_component(DIR $&#123;input_proto&#125; DIRECTORY) get_filename_component(FILE_NAME $&#123;input_proto&#125; NAME_WE) set(OUTPUT_CXX_HEADER &quot;$&#123;PROTO_CXX_OUT&#125;/$&#123;FILE_NAME&#125;.pb.h&quot;) set(OUTPUT_CXX_SOURCE &quot;$&#123;PROTO_CXX_OUT&#125;/$&#123;FILE_NAME&#125;.pb.cc&quot;) list(APPEND OUTPUT_SOURCES_CXX $&#123;OUTPUT_CXX_HEADER&#125; $&#123;OUTPUT_CXX_SOURCE&#125;)endforeach()add_custom_command( OUTPUT $&#123;OUTPUT_SOURCES_CXX&#125; COMMAND $&#123;PROTOC_CXX&#125; --cpp_out=$&#123;PROTO_CXX_OUT&#125; --proto_path=$&#123;PROTO_PATH&#125; $&#123;PROTO_SOURCE_FILES&#125; DEPENDS $&#123;PROTO_SOURCE_FILES&#125; WORKING_DIRECTORY $&#123;PROTO_PATH&#125; COMMENT &quot;Generate Cpp Protobuf Source Files&quot;)add_custom_target( compile_cxx_protos DEPENDS $&#123;OUTPUT_SOURCES_CXX&#125;)# 设置生成源文件包含目录变量供上层引用set(PROTO_GEN_CXX_INCLUDE_DIRS $&#123;PROTO_CXX_OUT&#125; PARENT_SCOPE)# 将生成的文件打包为库 proto_gen_cxx# 程序可以链接到该库add_library(proto_gen_cxx $&#123;OUTPUT_SOURCES_CXX&#125;)target_link_libraries(proto_gen_cxx protobuf)add_dependencies(proto_gen_cxx compile_cxx_protos)","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"},{"name":"网络编程","slug":"网络编程","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"socket","slug":"socket","permalink":"http://example.com/tags/socket/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"protobuf","slug":"protobuf","permalink":"http://example.com/tags/protobuf/"}]},{"title":"tcp粘包问题","slug":"tcp-packet","date":"2024-07-26T13:11:21.000Z","updated":"2024-11-08T02:21:34.892Z","comments":true,"path":"2024/07/26/tcp-packet/","permalink":"http://example.com/2024/07/26/tcp-packet/","excerpt":"","text":"什么是粘包TCP粘包问题是指在使用TCP协议进行网络通信时，客户端和服务器之间发送的数据包可能会被TCP协议栈在底层进行合并或者拆分，导致客户端接收到的数据不再是单独、完整的数据包，而是多个数据包的内容被粘在一起或者多个数据包的内容被拆分到不同的接收缓冲区中。 粘包原因1. 因为TCP是面向字节流的协议传输的数据是以流的形式,而流数据是没有明确的开始结尾边界,所以 TCP 也没办法判断哪一段流属于一个消息;TCP协议是流式协议;所谓流式协议,即协议的内容是像流水一样的字节流,内容与内容之间没有明确的分界标志,需要认为手动地去给这些协议划分边界。 例如客户端每次发送N个字节给服务端，N取决于当前客户端的发送缓冲区是否有数据，比如发送缓冲区总大小为10个字节，当前有5个字节数据（例如上次要发送的数据‘loveu’）未发送完，那么此时只有5个字节的空闲空间，客户端调用发送接口发送“hello world!”其实就是只能发送“hello”给服务器，那么服务器一次性得到的数据就是“loveuhello”，而剩余的“world！”只能留给下一次发送，下一次服务器收到的就是“world！” 2. 数据发送和接收速率不匹配如果发送方发送数据的速度比接收方处理数据的速度快，就可能导致多个消息被一次性读取。比如客户端1s内发送了两次“hello world！”，服务器过了2s才接收到数据，那一次性就会读出两个“hello world” 3. tcp底层的安全和效率机制不允许字节数特别少的小包发送频率过高tcp会在底层累计数据长度到一定大小才一起发送，比如连续发送1字节的数据要累计到多个字节才发送，可以了解下tcp底层的Nagle算法 。 处理粘包处理粘包的方式主要采用应用层定义收发包格式的方式，这个过程俗称切包处理，常用的协议被称为tlv协议(消息id+消息长度+消息内容) 为了方便理解，这里先简化发送格式，改成“消息长度+消息内容”的方式 消息节点123456789101112131415161718192021222324252627282930#define MAX_LENGTH 1024 * 2#define HEAD_LENGTH 2class MsgNode &#123;public: friend class Session; MsgNode( char *msg, short max_len ) : _cur_len( 0 ), _total_len( max_len + HEAD_LENGTH ) &#123; _msg = new char[_total_len + 1](); // 这里➕1是为了存放&#x27;\\0&#x27; memcpy( _msg, &amp;max_len, HEAD_LENGTH ); // 留出两个字节存储消息头 mempcpy( _msg + HEAD_LENGTH, msg, max_len ); // 存储消息体 _msg[_total_len] = &#x27;\\0&#x27;; &#125; MsgNode( short max_len ) : _cur_len( 0 ), _total_len( max_len ) &#123; _msg = new char[_total_len + 1](); &#125; void clear() &#123; memset( _msg, 0, _total_len ); _cur_len = 0; &#125; ~MsgNode() &#123; delete[] _msg; &#125;private: short _cur_len; // 当前已处理的数据长度 short _total_len; // 数据的总长度 char *_msg; // 存储的数据指针&#125;; Session的改进为了能够对收到的数据进行切包处理，需要定义一个消息接收节点、一个bool变量表示头部信息是否处理完成，以及将处理好的头部先缓存起来的结构 123std::shared_ptr&lt;MsgNode&gt; _recv_msg_node; //收到消息结构bool _b_head_parse; //是否处理完头部信息std::shared_ptr&lt;MsgNode&gt; _recv_head_node; //收到头部结构 完善接收逻辑123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142void Session::HandleRead( const boost::system::error_code &amp;error, size_t bytes_transferred, std::shared_ptr&lt;Session&gt; _self_shared ) &#123; if ( !error ) &#123; PrintRecvData(_data, bytes_transferred); std::chrono::seconds duration(2); std::this_thread::sleep_for(duration); // 已经移动的字符串 int copy_len = 0; while ( bytes_transferred &gt; 0 ) &#123; // 判断头部是否处理 if ( !_b_head_parse ) &#123; // NOTE: step 1 // 如果数据小于头部大小，先将数据放入_recv_head_node if ( bytes_transferred + _recv_head_node-&gt;_cur_len &lt; HEAD_LENGTH ) &#123; memcpy( _recv_head_node-&gt;_msg + _recv_head_node-&gt;_cur_len, _data + copy_len, bytes_transferred ); _recv_head_node-&gt;_cur_len += bytes_transferred; memset( _data, 0, MAX_LENGTH ); _socket.async_read_some( boost::asio::buffer( _data, MAX_LENGTH ), std::bind( &amp;Session::HandleRead, this, std::placeholders::_1, std::placeholders::_2, _self_shared ) ); return; &#125; // NOTE: step 2 // 收到的数据比头部多，可能是多个逻辑包，要做切包处理 // 头部剩余未复制的长度 int head_remain = HEAD_LENGTH - _recv_head_node-&gt;_cur_len; memcpy( _recv_head_node-&gt;_msg + _recv_head_node-&gt;_cur_len, _data + copy_len, head_remain ); // 更新已处理的data长度和剩余未处理长度 copy_len += head_remain; bytes_transferred -= head_remain; // 获取头部数据 short data_len = 0; memcpy( &amp;data_len, _recv_head_node-&gt;_msg, HEAD_LENGTH ); std::cout &lt;&lt; &quot;data_len is: &quot; &lt;&lt; data_len &lt;&lt; std::endl; // 头部非法长度 if ( data_len &gt; HEAD_LENGTH ) &#123; std::cout &lt;&lt; &quot;Invalid data length is: &quot; &lt;&lt; data_len &lt;&lt; std::endl; _server-&gt;ClearSession( _uuid ); return; &#125; _recv_msg_node = std::make_shared&lt;MsgNode&gt;( data_len ); // NOTE: step 3 // 消息的长度小于头部规定的长度，说明数据未收集全，则先将部分消息放到接收节点里 if ( (int)bytes_transferred &lt; data_len ) &#123; memcpy( _recv_msg_node-&gt;_msg + _recv_msg_node-&gt;_cur_len, _data + copy_len, bytes_transferred ); _recv_msg_node-&gt;_cur_len += bytes_transferred; memset( _data, 0, MAX_LENGTH ); _socket.async_read_some( boost::asio::buffer( _data, MAX_LENGTH ), std::bind( &amp;Session::HandleRead, this, std::placeholders::_1, std::placeholders::_2, _self_shared ) ); // 头部处理完成 _b_head_parse = true; return; &#125; memcpy( _recv_msg_node-&gt;_msg + _recv_msg_node-&gt;_cur_len, _data + copy_len, data_len ); _recv_msg_node-&gt;_cur_len += data_len; copy_len += data_len; bytes_transferred -= data_len; _recv_msg_node-&gt;_msg[_recv_msg_node-&gt;_total_len] = &#x27;\\0&#x27;; std::cout &lt;&lt; &quot;Recv msg is: &quot; &lt;&lt; _recv_msg_node-&gt;_msg &lt;&lt; std::endl; // use Send for testing Send( _recv_msg_node-&gt;_msg, _recv_msg_node-&gt;_total_len ); // 继续轮询未处理的数据 _b_head_parse = false; _recv_head_node-&gt;clear(); if ( bytes_transferred &lt;= 0 ) &#123; memset( _data, 0, MAX_LENGTH ); _socket.async_read_some( boost::asio::buffer( _data, MAX_LENGTH ), std::bind( &amp;Session::HandleRead, this, std::placeholders::_1, std::placeholders::_2, _self_shared ) ); return; &#125; continue; &#125; // NOTE: step 4 // 已经处理完头部，处理上次未接收完的消息数据 // 接收的数据仍不足剩余未处理的 int remain_msg = _recv_msg_node-&gt;_total_len - _recv_msg_node-&gt;_cur_len; if ( (int)bytes_transferred &lt; remain_msg ) &#123; memcpy( _recv_msg_node-&gt;_msg + _recv_msg_node-&gt;_cur_len, _data + copy_len, bytes_transferred ); _recv_msg_node-&gt;_cur_len += bytes_transferred; memset( _data, 0, MAX_LENGTH ); _socket.async_read_some( boost::asio::buffer( _data, MAX_LENGTH ), std::bind( &amp;Session::HandleRead, this, std::placeholders::_1, std::placeholders::_2, _self_shared ) ); return; &#125; memcpy( _recv_msg_node-&gt;_msg + _recv_msg_node-&gt;_cur_len, _data + copy_len, remain_msg ); bytes_transferred -= remain_msg; copy_len += remain_msg; _recv_msg_node-&gt;_msg[_recv_msg_node-&gt;_total_len] = &#x27;\\0&#x27;; std::cout &lt;&lt; &quot;Recv msg is: &quot; &lt;&lt; _recv_msg_node-&gt;_msg &lt;&lt; std::endl; // use Send for testing Send( _recv_msg_node-&gt;_msg, _recv_msg_node-&gt;_total_len ); // 继续轮询未处理的数据 _b_head_parse = false; _recv_head_node-&gt;clear(); if ( bytes_transferred &lt;= 0 ) &#123; _socket.async_read_some( boost::asio::buffer( _data, MAX_LENGTH ), std::bind( &amp;Session::HandleRead, this, std::placeholders::_1, std::placeholders::_2, _self_shared ) ); return; &#125; continue; &#125; &#125; else &#123; std::cout &lt;&lt; &quot;handle read failed, code is: &quot; &lt;&lt; error.value() &lt;&lt; &quot; message is: &quot; &lt;&lt; error.message() &lt;&lt; std::endl; _server-&gt;ClearSession( _uuid ); &#125;&#125; copy_len：已经处理的数据长度，因为存在一次接收多个包的情况，所以copy_len的意义是在于记录已经处理的数据的长度 首先判断_b_head_parse是否为false，如果为false，则表示头部未处理，需要先处理头部。先判断接收的数据是否小于HEAD_LENGTH，如果小于则需要拷贝数据到_recv_head_node中，然后再读取剩余的数据。 如果受到的数据比头部数据多，可能是多个数据包，需要做切包处理。根据之前保留在_recv_head_node中的数据长度，计算出剩余未读取的头部长度，然后取出剩余头部长度保存在_recv_head_node中。然后通过memcpy从节点拷贝出数据写入short类型的data_len，并更新copy_len，进而得到消息长度， 然后再读取剩余的消息体。先判断接收到数据未处理部分的长度和总共要接收的数据长度大小，如果小于总共要接收的长度，说明消息体还没接收完，则将未处理的部分写入到_recv_msg_node里，回调读事件。否则说明消息体接收完全 将消息体数据接收到_recv_msg_node中，接收完全后返回给对端。当然存在多个逻辑包粘连，此时要判断bytes_transferred是否&lt;&#x3D;0，如果是则说明只有一个逻辑包，我们处理完了，继续监听读事件，就直接返回即可，否则说明有多个数据包粘连，就继续执行上述操作 因为存在_b_head_parse为true，就是包头接收并处理完的情况，但是包体未接收完，则再次出发读事件，此时就要继续进行上述操作 总体流程如下 粘包测试为了测试粘包，需要制造粘包产生的现象，可以让客户端发送的频率高一些，服务器接收的频率低一些，这样造成前后端收发数据不一致导致多个数据包在服务器tcp缓冲区滞留产生粘包现象。 测试粘包之前，在服务器的Session中添加打印二进制函数 123456789101112void Session::PrintRecvData(char *data, int length) &#123; std::stringstream ss; std::string result = &quot;0x&quot;; for(int i = 0; i &lt; length; i++) &#123; std::string hexstr; ss &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; std::setfill(&#x27;0&#x27;) &lt;&lt; int(data[i]) &lt;&lt; std::endl; ss &gt;&gt; hexstr; result += hexstr; &#125; std::cout &lt;&lt; &quot;Recv raw data is: &quot; &lt;&lt; result &lt;&lt; std::endl;&#125; 然后将这个函数放到HandleRead里，每次收到数据就调用这个函数打印接收到的最原始的数据，然后睡眠2秒再进行收发操作，用来延迟接收对端数据制造粘包，之后的逻辑不变 12345678void Session::HandleRead( const boost::system::error_code &amp;error, size_t bytes_transferred, std::shared_ptr&lt;Session&gt; _self_shared ) &#123; if ( !error ) &#123; PrintRecvData(_data, bytes_transferred); std::chrono::seconds duration(2); std::this_thread::sleep_for(duration); 客户端代码实现收发分离 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;boost/asio.hpp&gt;#include &lt;chrono&gt;#include &lt;iostream&gt;#include &lt;thread&gt;using namespace std;using boost::asio::ip::tcp;constexpr int MAX_LENGTH = 1024 * 2;constexpr int HEAD_LENGTH = 2;int main() &#123; try &#123; boost::asio::io_context ioc; tcp::endpoint remote_ep( boost::asio::ip::address::from_string( &quot;127.0.0.1&quot; ), 10086 ); tcp::socket sock( ioc ); boost::system::error_code ec = boost::asio::error::host_not_found; sock.connect( remote_ep, ec ); if ( ec ) &#123; cout &lt;&lt; &quot;connect failed: &quot; &lt;&lt; ec.message() &lt;&lt; endl; return 0; &#125; std::thread send_thread( [&amp;]() &#123; while ( true ) &#123; this_thread::sleep_for( std::chrono::milliseconds( 1 ) ); const char *request_msg = &quot;Hello World!&quot;; size_t request_len = strlen( request_msg ); char send_data[MAX_LENGTH] = &#123; 0 &#125;; memcpy( send_data, &amp;request_len, 2 ); memcpy( send_data + 2, request_msg, request_len ); boost::asio::write( sock, boost::asio::buffer( send_data, request_len + 2 ) ); &#125; &#125; ); std::thread recv_thread( [&amp;]() &#123; while ( true ) &#123; this_thread::sleep_for(std::chrono::milliseconds(1)); std::cout &lt;&lt; &quot;Begin to receive&quot; &lt;&lt; std::endl; char reply_head[HEAD_LENGTH]; size_t reply_length = boost::asio::read( sock, boost::asio::buffer( reply_head, HEAD_LENGTH ) ); short msglen = 0; memcpy( &amp;msglen, reply_head, HEAD_LENGTH ); char msg[MAX_LENGTH] = &#123; 0 &#125;; size_t msg_length = boost::asio::read( sock, boost::asio::buffer( msg, msglen ) ); cout &lt;&lt; &quot;Reply is: &quot;; cout.write( msg, msg_length ) &lt;&lt; endl; cout &lt;&lt; &quot;Reply length is: &quot; &lt;&lt; msg_length &lt;&lt; endl; &#125; &#125; ); send_thread.join(); recv_thread.join(); &#125; catch ( std::exception &amp;e ) &#123; cerr &lt;&lt; e.what() &lt;&lt; endl; &#125; return 0;&#125; 总结该服务虽然实现了粘包处理，但是服务器仍存在不足，比如当客户端和服务器处于不同平台时收发数据会出现异常，根本原因是未处理大小端模式的问题。","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"},{"name":"网络编程","slug":"网络编程","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"socket","slug":"socket","permalink":"http://example.com/tags/socket/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"单例模式","slug":"singleton","date":"2024-07-12T16:57:35.000Z","updated":"2024-11-08T02:21:34.892Z","comments":true,"path":"2024/07/13/singleton/","permalink":"http://example.com/2024/07/13/singleton/","excerpt":"","text":"介绍单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个全局对象，这样有利于我们调整系统行为 实现思路 一个类能返回一个对象的引用(永远都是同一个)和一个获得该实例的方法(必须是静态方法) getInstance 调用这个方法时，如果类持有的引用不为空就返回这个引用。如果类保持的引用为空，就创建该类的实例返回这个实例的引用 将该类的构造函数定义为私有方法，这样其他处的代码就无法通过调用该类的构造函数来实例化该对象，只有通过该类的静态方法来实现唯一实例。 实现方式 懒汉式 这种lazyloading很明显，不要求线程安全，在多线程不能正常工作 是否lazy初始化 是否多线程安全 实现难度 是 否 易 实现：局部静态变量方式 1234567891011121314151617181920class SingleLazy&#123;private: SingleLazy() &#123; &#125; SingleLazy(const SingleLazy&amp;) = delete; SingleLazy&amp; operator=(const SingleLazy&amp;) = delete;public: static SingleLazy&amp; getInstance() &#123; static SingleLazy single; return single; &#125;&#125;;void test_SingleLazy() &#123; // 多线程可能出现问题 std::cout &lt;&lt; &quot;s1 addr is &quot; &lt;&lt; &amp;SingleLazy::getInstance() &lt;&lt; &quot;\\n&quot;; std::cout &lt;&lt; &quot;s2 addr is &quot; &lt;&lt; &amp;SingleLazy::getInstance() &lt;&lt; &quot;\\n&quot;;&#125; 输出如下 12s1 addr is 0x557ab517b151s2 addr is 0x557ab517b151 确实生成了唯一实例，但是存在隐患，多线程可能生成多个实例 饿汉式 是否lazy初始化 是否多线程安全 实现难度 否 是 易 优点：没有加锁，执行效率会提高 缺点：类加载时就初始化，浪费内存 实现：静态成员变量指针方式 定义一个类的静态成员变量，用来控制实现单例 12345678910111213141516171819202122232425262728293031323334class SingleHungry&#123;private: SingleHungry() &#123; &#125; SingleHungry(const SingleHungry&amp;) = delete; SingleHungry&amp; operator=(const SingleHungry&amp;) = delete;public: static SingleHungry* getInstance() &#123; if(single == nullptr) &#123; single = new SingleHungry(); &#125; return single; &#125;private: static SingleHungry *single;&#125;;// 饿汉式初始化SingleHungry *SingleHungry::single = SingleHungry::getInstance();void thread_func(int num) &#123; std::cout &lt;&lt; &quot;this is thread &quot; &lt;&lt; num &lt;&lt; &quot;\\n&quot;; std::cout &lt;&lt; &quot;Instance is &quot; &lt;&lt; SingleHungry::getInstance() &lt;&lt; &quot;\\n&quot;;&#125;void test_SingleHungry() &#123; std::cout &lt;&lt; &quot;s1 addr is &quot; &lt;&lt; SingleHungry::getInstance() &lt;&lt; &quot;\\n&quot;; std::cout &lt;&lt; &quot;s2 addr is &quot; &lt;&lt; SingleHungry::getInstance() &lt;&lt; &quot;\\n&quot;; for(int i = 0; i &lt; 3; i++) &#123; std::thread ti(thread_func , i); ti.join(); &#125;&#125; 输出结果如下 12345678s1 addr is 0x56334e3ae2b0s2 addr is 0x56334e3ae2b0this is thread 0Instance is 0x56334e3ae2b0this is thread 1Instance is 0x56334e3ae2b0this is thread 2Instance is 0x56334e3ae2b0 可见无论是单线程还是多线程模式下，通过静态成员变量的指针实现的单例类都是唯一的。 但是无论是饿汉式还是懒汉式都存在一个问题，那就是什么时候释放内存？多线程情况下，释放内存就很难了，还有二次释放内存的风险。 下面我们定义一个单例类并用懒汉式调用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class SinglePointer &#123;private: SinglePointer() &#123; &#125; SinglePointer(const SinglePointer&amp;) = delete; SinglePointer&amp; operator=(const SinglePointer&amp;) = delete;public: static SinglePointer* getInstance() &#123; if(single != nullptr) &#123; return single; &#125; Lock.lock(); if(single != nullptr) &#123; Lock.unlock(); return single; &#125; single = new SinglePointer(); Lock.unlock(); return single; &#125;private: static SinglePointer *single; static std::mutex Lock;&#125;;std::mutex SinglePointer::Lock;SinglePointer *SinglePointer::single = nullptr;void thread_func_ptr(int num) &#123; std::cout &lt;&lt; &quot;this thread is &quot; &lt;&lt; num &lt;&lt; &quot;\\n&quot;; std::cout &lt;&lt; &quot;Instance is &quot; &lt;&lt; SinglePointer::getInstance() &lt;&lt; &quot;\\n&quot;;&#125;void test_SinglePointer() &#123; std::cout &lt;&lt; &quot;s1 addr is &quot; &lt;&lt; SinglePointer::getInstance() &lt;&lt; &quot;\\n&quot;; std::cout &lt;&lt; &quot;s2 addr is &quot; &lt;&lt; SinglePointer::getInstance() &lt;&lt; &quot;\\n&quot;; for(int i = 0; i &lt; 3; i++) &#123; std::thread ti(thread_func_ptr , i); ti.join(); &#125; // 何时释放new的对象?造成内存泄漏&#125; 输出结果如下： 12345678s1 addr is 0x55cede7582d0s2 addr is 0x55cede7582d0this thread is 0Instance is 0x55cede7582d0this thread is 1Instance is 0x55cede7582d0this thread is 2Instance is 0x55cede7582d0 此时生成的单例对象的内存空间还没回收，这是个问题，另外如果多线程情况下多次delete也会造成崩溃。 所以需要一种自动回收内存的机制帮助我们回收内存，所以可以使用智能指针来做这个操作 实现方式：智能指针方式 可以利用智能指针自动回收内存的机制设计单例类 123456789101112131415161718192021222324252627282930313233343536373839404142class SingleAuto&#123;private: SingleAuto() &#123; &#125; SingleAuto(const SingleAuto&amp;) = delete; SingleAuto&amp; operator=(const SingleAuto&amp;) = delete;public: ~SingleAuto() &#123; std::cout &lt;&lt; &quot;single auto delete success\\n&quot;; &#125; static std::shared_ptr&lt;SingleAuto&gt; getInstance() &#123; if(single != nullptr) &#123; return single; &#125; Lock.lock(); if(single != nullptr) &#123; Lock.unlock(); return single; &#125; single = std::shared_ptr&lt;SingleAuto&gt;(new SingleAuto()); Lock.unlock(); return single; &#125;private: static std::shared_ptr&lt;SingleAuto&gt; single; static std::mutex Lock;&#125;;std::shared_ptr&lt;SingleAuto&gt; SingleAuto:: single = nullptr;std::mutex SingleAuto::Lock;void test_SingleAuto() &#123; auto sp1 = SingleAuto::getInstance(); auto sp2 = SingleAuto::getInstance(); std::cout &lt;&lt; &quot;sp1 is &quot; &lt;&lt; sp1 &lt;&lt; &quot;\\n&quot;; std::cout &lt;&lt; &quot;sp2 is &quot; &lt;&lt; sp2 &lt;&lt; &quot;\\n&quot;; // 存在隐患，可以手动删除裸指针，造成崩溃，因为会二次释放内存 // delete sp1.get();&#125; 输出如下 12sp1 is 0x56252c7252f0sp2 is 0x56252c7252f0 智能指针方式不存在内存泄漏，但是有一个隐患就是单例类的析构函数是public,如果被人手动调用会存在崩溃问题，比如将上面的test_SingleAuto中的注释打开，程序会崩溃。 实现：辅助类智能指针单例模式 智能指针在构造的时候可以指定删除器，所以可以传递一个辅助类或者辅助函数帮助智能指针回收内存时调用我们指定的析构函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// NOTE: safe deletorr// 防止外界deletor// 声明辅助类// 该类定义放函数调用SingleAutoSafe析构函数// 不可以提前声明辅助类，编译器会报 incomplete type// class SafeDeletor// 所以要提前定义辅助类class SingleAutoSafe;class SafeDeletor &#123;public: void operator()(SingleAutoSafe* s) &#123; std::cout &lt;&lt; &quot;this is safe deletor operator()\\n&quot;; delete s; &#125;&#125;;void SafeDeletorFunc(SingleAutoSafe* s) &#123; std::cout &lt;&lt; &quot;this is safe deletor func\\n&quot;; delete s;&#125;class SingleAutoSafe &#123;private: SingleAutoSafe() &#123; &#125; ~SingleAutoSafe() &#123; std::cout &lt;&lt; &quot;this is sing auto safe deletor\\n&quot;; &#125; SingleAutoSafe(const SingleAutoSafe&amp;) = delete; SingleAutoSafe&amp; operator=(const SingleAutoSafe&amp;) = delete; friend class SafeDeletor; friend void SafeDeletorFunc(SingleAutoSafe* s);public: static std::shared_ptr&lt;SingleAutoSafe&gt; getInstance() &#123; if(single != nullptr) &#123; return single; &#125; Lock.lock(); if(single != nullptr) &#123; Lock.unlock(); return single; &#125; // NOTE:额外指定删除器 // single = std::shared_ptr&lt;SingleAutoSafe&gt;(new SingleAutoSafe() , SafeDeletor()); // NOTE:额外指定删除函数 single = std::shared_ptr&lt;SingleAutoSafe&gt;(new SingleAutoSafe() , SafeDeletorFunc); Lock.unlock(); return single; &#125;private: static std::shared_ptr&lt;SingleAutoSafe&gt; single; static std::mutex Lock;&#125;;std::shared_ptr&lt;SingleAutoSafe&gt; SingleAutoSafe::single = nullptr;std::mutex SingleAutoSafe::Lock;void test_SingleAutoSafe() &#123; auto sp1 = SingleAutoSafe::getInstance(); auto sp2 = SingleAutoSafe::getInstance(); std::cout &lt;&lt; &quot;sp1 is &quot; &lt;&lt; sp1 &lt;&lt; &quot;\\n&quot;; std::cout &lt;&lt; &quot;sp2 is &quot; &lt;&lt; sp2 &lt;&lt; &quot;\\n&quot;; // 此时无法访问析构函数，非常安全 // delete sp1.get();&#125; 输出如下 123sp1 is 0x563f192162b0sp2 is 0x563f192162b0this is safe deletor func SafeDeletor要写在SingleAutoSafe上边，并且SafeDeletor要声明为SingleAutoSafe类的友元类，这样就可以访问SingleAutoSafe的析构函数了。 我们在构造single时制定了SafeDeletor(),single在回收时，会调用SingleAutoSafe的仿函数，从而完成内存的销毁。 并且SingleAutoSafe的析构函数为私有的无法被外界手动调用了。 通过辅助类调用单例类的析构函数保证了内存释放的安全性和唯一性。这种方式是生产中常用的。如果将test_SingleAutoSafe的注释打开，手动删除在编译阶段就会报错，达到了代码安全的目的。 通过单例模板类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#pragma once#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;mutex&gt;#include &lt;thread&gt;template&lt;typename T&gt;class TD;template&lt;typename T&gt;class Single_T;template&lt;typename T&gt;class SafeDeletor &#123;public: void operator()(T* s) &#123; std::cout &lt;&lt; &quot;this is safe deletor operator()\\n&quot;; delete s; &#125;&#125;;template&lt;typename T&gt;void SafeDeletorFunc(T* s) &#123; std::cout &lt;&lt; &quot;this is safe deletor func\\n&quot;; delete s;&#125;template&lt;typename T&gt;class Single_T &#123;protected: Single_T() = default; ~Single_T() &#123; std::cout &lt;&lt; &quot;this is single template deletor\\n&quot;; &#125; Single_T(const Single_T&amp;) = delete; Single_T&amp; operator=(const Single_T&amp;) = delete; friend class SafeDeletor&lt;T&gt;; friend void SafeDeletorFunc&lt;T&gt;(T* s);public: static std::shared_ptr&lt;T&gt; getInstance() &#123; if(single != nullptr) &#123; return single; &#125; Lock.lock(); if(single != nullptr) &#123; Lock.unlock(); return single; &#125; // NOTE:额外指定删除器 // single = std::shared_ptr&lt;T&gt;(new T, SafeDeletor&lt;T&gt;()); // NOTE:额外指定删除函数 single = std::shared_ptr&lt;T&gt;(new T , SafeDeletorFunc&lt;T&gt;); Lock.unlock(); return single; &#125;private: static std::shared_ptr&lt;T&gt; single; static std::mutex Lock;&#125;;// NOTE: 模板类的static成员要放在hpp文件内初始化template&lt;typename T&gt;std::shared_ptr&lt;T&gt; Single_T&lt;T&gt;::single = nullptr;template&lt;typename T&gt;std::mutex Single_T&lt;T&gt;::Lock; 12345678910111213141516171819202122232425262728293031// 使用std::call_once#pragma once#include &lt;mutex&gt;#include &lt;memory&gt;#include &lt;iostream&gt;template&lt;typename T&gt;class SingleTon &#123;protected: explicit SingleTon() = default; SingleTon(const SingleTon&amp; ) = delete; SingleTon&amp; operator=(const SingleTon&amp;) = delete; ~SingleTon() &#123; std::cout &lt;&lt; &quot;This is SingleTon deletor&quot; &lt;&lt; std::endl; &#125; static std::shared_ptr&lt;T&gt; single;public: static std::shared_ptr&lt;T&gt; getInstance() &#123; static std::once_flag flag; std::call_once(flag, [&amp;]()&#123; single = std::make_shared&lt;T&gt;(new T); &#125;); return single; &#125;&#125;;template&lt;typename T&gt;std::shared_ptr&lt;T&gt; SingleTon&lt;T&gt;::single = nullptr; 使用方式：我们只需要定一个单例类，继承这个模板，并将构造和析构都设置为私有，同时设置友元保证自己的析构和构造可以被友元调用即可。 1234567891011121314151617class SingleNet : public Single_T&lt;SingleNet&gt; &#123;private: SingleNet() = default; ~SingleNet() = default; SingleNet(const SingleNet&amp;) = delete; SingleNet&amp; operator=(const SingleNet&amp;) = delete; friend class SafeDeletor&lt;SingleNet&gt;; friend class Single_T&lt;SingleNet&gt;; friend void SafeDeletorFunc&lt;SingleNet&gt;(SingleNet* s);&#125;;void test_Single_T() &#123; auto sp1 = SingleNet::getInstance(); auto sp2 = SingleNet::getInstance(); std::cout &lt;&lt; &quot;sp1 is &quot; &lt;&lt; sp1 &lt;&lt; &quot;\\n&quot;; std::cout &lt;&lt; &quot;sp2 is &quot; &lt;&lt; sp2 &lt;&lt; &quot;\\n&quot;;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"建造者模式","slug":"builder","date":"2024-07-12T16:57:29.000Z","updated":"2024-11-08T02:21:34.890Z","comments":true,"path":"2024/07/13/builder/","permalink":"http://example.com/2024/07/13/builder/","excerpt":"","text":"简介建造者模式（Builder Pattern）是一种在软件设计中用来组织对象的构造过程的方法。它将对象的构建和表示分离，允许独立改变构建过程或生成不同的表示形式。这种模式特别适用于那些需要创建复杂对象的场景，在这些场景中，对象的组成部分可能相互依赖或者取决于外部环境条件。 建造者模式的主要组件建造者模式通常包含以下主要组件： 产品（Product）接口：定义了一个通用的产品或对象结构。所有具体产品的构建都会遵循这个接口。 抽象建造者（Builder Interface）：为创建特定产品提供一组方法，这些方法用于设置产品的不同部分。该接口是所有具体建造者的超类。 具体建造者（Concrete Builder）：实现抽象建造者接口，并定义了如何构建具体的产品实例。每个具体的建造者将根据需要构建不同的部分或选择不同的配置来创建产品。 产品工厂（Product Factory） 或 导演（Director）：在一些情况下，可以使用一个中心类来调用特定的建造者方法并构建出一个完整的产品对象。这个类通常不直接与产品的具体实现交互，而是通过调用建造者的接口来完成构建过程。 应用场景建造者模式适用于以下几种情况： 复杂对象构造：当创建对象时涉及多个步骤或依赖于外部环境条件（例如操作系统版本、网络配置等）。 可选功能构建：在产品中包含可选择的组件或选项，如定制电脑配置（CPU类型、内存大小、硬盘驱动器类型等）。 实例说明为了更好地理解建造者模式，我们可以使用一个简单的例子来说明如何应用这个设计模式。假设我们正在组装一台电脑开发一个构建过程，允许用户根据需求自定义电脑的配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;memory&gt;// Productclass Computer &#123;public: explicit Computer() = default; void setCPU( const std::string &amp;cpu ) &#123; cpu_ = cpu; &#125; void setMemory( const std::string &amp;memory ) &#123; memory_ = memory; &#125; void setStorage( const std::string &amp;storage ) &#123; storage_ = storage; &#125; void print() const &#123; std::cout &lt;&lt; &quot;CPU: &quot; &lt;&lt; cpu_ &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Memory: &quot; &lt;&lt; memory_ &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Storage: &quot; &lt;&lt; storage_ &lt;&lt; std::endl; &#125;private: std::string cpu_; std::string memory_; std::string storage_;&#125;;// Builder interfaceclass ComputerBuilder &#123;public: virtual ~ComputerBuilder() = default; virtual void buildCPU( const std::string &amp; ) = 0; virtual void buildMemory( const std::string &amp; ) = 0; virtual void buildStorage( const std::string &amp; ) = 0; virtual std::shared_ptr&lt;Computer&gt; getResult() = 0;&#125;;// Concrete Builderclass DesktopComputerBuilder : public ComputerBuilder &#123;public: DesktopComputerBuilder() : computer_( std::make_shared&lt;Computer&gt;() ) &#123;&#125; void buildCPU( const std::string &amp;cpu ) override &#123; computer_-&gt;setCPU( cpu ); &#125; void buildMemory( const std::string &amp;memory ) override &#123; computer_-&gt;setMemory( memory ); &#125; void buildStorage( const std::string &amp;storage ) override &#123; computer_-&gt;setStorage( storage ); &#125; std::shared_ptr&lt;Computer&gt; getResult() override &#123; return computer_; &#125;private: std::shared_ptr&lt;Computer&gt; computer_;&#125;;// Directorclass ComputerAssembler &#123;public: std::shared_ptr&lt;Computer&gt; assembleComputer( ComputerBuilder &amp;builder ) &#123; builder.buildCPU( &quot;Inter i7&quot; ); builder.buildStorage( &quot;980 PRO 1TB SSD&quot; ); builder.buildMemory( &quot;16GB&quot; ); return builder.getResult(); &#125;&#125;;void test_func() &#123; DesktopComputerBuilder builder; ComputerAssembler assembler; auto computer = assembler.assembleComputer( builder ); computer-&gt;print();&#125; 分析在给出的代码示例中，实现了建造者模式的主要组成部分： 产品接口（Computer）：定义了一个用于创建电脑的基本接口。所有的具体产品（如台式电脑、笔记本电脑等）都必须遵循这个接口。 抽象建造者（Builder Interface）（ComputerBuilder）：定义了构建电脑所需的通用方法，比如设置CPU、内存和存储设备等。这些方法对所有具体的建造者类开放，允许它们独立于具体产品来操作构建过程。 具体建造者（DesktopComputerBuilder）：实现了抽象建造者接口并提供了具体实现的方法。每个具体建造者会根据自己的规则和逻辑来执行构建步骤，比如在台式电脑上选择不同的组件配置。 导演类（Director）（ComputerAssembler）：负责调用具体的建造者类进行构建过程。它不直接与产品接口或具体的产品实例交互，而是通过调用抽象建造者的接口方法完成构建。 test_func 函数展示了如何使用这些组成部分来构建一个台式电脑的例子： 1234DesktopComputerBuilder builder;ComputerAssembler assembler;auto computer = assembler.assembleComputer( builder );computer-&gt;print(); 在这个例子中： Builder (DesktopComputerBuilder) 实例化并执行了具体的构建步骤，比如选择CPU型号、内存大小和存储设备类型。 Director (ComputerAssembler) 负责调用 DesktopComputerBuilder 的方法来逐步构造电脑。 通过这样的结构设计，建造者模式使得在不同场景下可以有不同的构建过程（不同的具体产品），同时保持了代码的可扩展性和灵活性。例如，我们可以轻松地添加新的构建步骤或创建完全不同的产品类型而无需修改现有的组装逻辑。 结论建造者模式是一种强大的设计模式，尤其在需要创建具有复杂构造过程的对象时非常有用。它通过封装构建过程和分离产品构建逻辑来提高系统的灵活性、可扩展性和可维护性。 建造者模式的缺点尽管建造者模式在很多情况下能够提供强大的对象构造能力，但就像任何设计模式一样，它也有其局限性和潜在的问题： 增加系统复杂性：引入多个类和接口会增加系统的复杂度。对于那些没有足够需求变化或不需要高度可配置性的项目来说，构建者模式可能会导致过度工程化。 创建过多的实例：如果建造过程涉及到很多步骤或者每个步骤都有可能产生不同的实例，那么在某些实现中可能会创建大量的对象，这可能导致内存使用和性能问题。优化构建过程以减少不必要的对象创建是很重要的。 代码维护难度：由于构造过程的细节被封装在多个类中，这对于系统维护来说可能需要更多的关注点。如果建造过程发生变化（例如引入新的组件或改变现有组件的选择逻辑），那么通常需要修改不止一个地方，这可能导致维护和更新的成本增加。 耦合性问题：尽管抽象建造者试图通过接口来隐藏构建步骤的细节，但具体建造者的实现可能会与产品类紧密关联。这种依赖关系可能使得重构变得困难，并且如果对建造过程进行微小调整，可能需要修改多个相关部分。 代码可读性和理解难度：建造者模式中的类和方法通常用于封装复杂的构建逻辑，这在一定程度上增加了代码的阅读和理解难度。对于没有熟悉此设计模式的人来说，在初次接触时可能会觉得难以理解整个系统的构造过程。 资源消耗：如果构建步骤涉及外部依赖或需要大量计算资源（如网络请求、数据库查询等），那么建造者模式可能会增加整体系统对这些资源的需求，从而影响性能和用户体验。 非线性构建路径：在某些实现中，建造过程可能不是单一线性的，而是有多个选择点。这可能导致难以预测的结果或更复杂的错误处理逻辑。","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"工厂模式","slug":"factory","date":"2024-07-12T16:57:23.000Z","updated":"2024-11-08T02:21:34.891Z","comments":true,"path":"2024/07/13/factory/","permalink":"http://example.com/2024/07/13/factory/","excerpt":"","text":"简介在软件开发中，工厂模式是一种设计模式，主要用于创建对象而不暴露具体类的创建细节。这种模式的主要目标是封装创建过程，并将创建逻辑从客户端代码中解耦出来。 定义和意图：工厂模式的意图在于提供一个创建一系列相关或相互依赖的对象的过程，而无需指定这些对象的具体类。它通过定义一个工厂类来实现这一功能，该工厂类负责根据输入参数决定创建哪个具体类的实例。 常见形式工厂模式通常有以下几种常见形式： 简单工厂（Simple Factory）：这是最基础的形式，它不依赖于类层次结构，并且通常被用于静态语言中。工厂只创建一个类族中的对象，通过传入参数来决定创建哪个具体类。 抽象工厂（Abstract Factory）：抽象工厂模式提供了一系列的工厂方法，用于创建一组相关的产品对象。这些产品可以属于不同的家族，但必须遵循共同的接口或抽象定义。其目的是在多个产品的上下文之间进行隔离，使得客户端代码只需要知道如何使用产品而不是如何创建它们。 单例工厂（Singleton Factory）：在此模式中，工厂类是单例的，确保了在整个应用范围内只有一个实例存在，并且提供一个公共的方法来访问这个实例。这是一种常见的设计模式，用于限制资源访问或配置设置。 构造函数工厂（Constructor Factory）：这种形式在面向对象语言中较为常见，它通过构造方法创建和初始化对象。构造函数工厂可以接受参数构建具有特定配置的对象，提供了一种动态调整对象属性的机制。 使用场景 在需要根据环境或运行时条件选择具体类时。 当客户端代码不应该依赖于具体的类实现细节，而是应该通过抽象接口进行交互时。 当创建复杂对象需要多个步骤、参数和依赖关系时（例如，配置文件中的信息用于决定对象实例的创建）。 示例假设我们有一个简单工厂模式的例子。假设我们要根据用户输入创建不同类型的形状： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;memory&gt;#include &lt;iostream&gt;// Abstract productclass Shape &#123;public: Shape() = default; virtual ~Shape() = default; virtual void draw() = 0;&#125;;// Concrete Productclass Circle : public Shape &#123;public: virtual void draw() override &#123; std::cout &lt;&lt; &quot;this is a circle&quot; &lt;&lt; std::endl; &#125;&#125;;class Square : public Shape &#123;public: virtual void draw() override &#123; std::cout &lt;&lt; &quot;this is a square&quot; &lt;&lt; std::endl; &#125;&#125;;// Abstract Creatorclass ShapeFactory &#123;public: virtual std::shared_ptr&lt;Shape&gt; createShape() = 0; virtual ~ShapeFactory() = default;&#125;;class CircleFactory : public ShapeFactory &#123;public: std::shared_ptr&lt;Shape&gt; createShape() override &#123; return std::make_shared&lt;Circle&gt;(); &#125;&#125;;class SquareFactory : public ShapeFactory &#123;public: virtual std::shared_ptr&lt;Shape&gt; createShape() override &#123; return std::make_shared&lt;Square&gt;(); &#125;&#125;;// Clientvoid test_func() &#123; std::unique_ptr&lt;CircleFactory&gt; circleFactory = std::make_unique&lt;CircleFactory&gt;(); std::unique_ptr&lt;SquareFactory&gt; squareFactory = std::make_unique&lt;SquareFactory&gt;(); auto circle = circleFactory-&gt;createShape(); auto square = squareFactory-&gt;createShape(); circle-&gt;draw(); square-&gt;draw();&#125; 在这个例子中，Shape 和 ShapeFactory 是接口和抽象类的例子。工厂模式通过创建具体实现的实例（即 Circle 或 Square）来满足客户端的不同需求，而不需要在代码中硬编码具体的类名。 具体分析： 接口（Abstract Class）： Shape：这是抽象产品类，定义了一个纯虚函数draw()，用于绘制形状。 CircleFactory, SquareFactory：这些是抽象创建者类的实现。它们都实现了从抽象创建者类继承的createShape()接口方法。 具体类： Circle 和 Square 是具体产品类。它们各自实现了draw()函数以表示不同形状的绘制方式。 工厂模式： 在这个例子中，通过使用抽象创建者（ShapeFactory）和具体创建者（CircleFactory, SquareFactory），我们可以在不直接引用具体产品类的情况下创建产品对象。这种方法使得客户端代码与具体的产品实现解耦。 测试函数： test_func() 函数展示了如何通过工厂模式实例化不同的产品。它首先创建了CircleFactory和SquareFactory的实例，然后调用每个工厂的createShape()方法来获取相应的形状对象，并调用它们的draw()方法来验证是否正确创建并绘制出了圆形和正方形。 使用场景： 当需要在运行时决定使用哪个具体产品类时。 需要将产品的创建过程与产品的客户端代码分离，以提高代码可维护性和灵活性。 避免类的爆炸问题（即大量的相似类），通过一个工厂类来管理类的选择和实例化。 通过这种方式，工厂模式提供了一种灵活的方式来根据特定需求动态地生成不同类型的对象。在实际开发中，这种设计模式常用于UI组件、数据库连接器等场景，以提高代码的可扩展性和维护性。 总结工厂模式为创建对象提供了极大的灵活性和封装性，并有助于降低耦合度和提高代码的可维护性。它通过提供一个统一的方式来实例化特定类型的对象或一组相关的对象，使得系统结构更加清晰、更易于调整和扩展。 工厂模式的缺点虽然工厂模式在对象创建时提供了便利性和灵活性，但它同样存在一些潜在的局限和问题： 代码复杂性：随着功能的增加或需求的变化，工厂类可能会变得非常大且难以维护。每个产品都需要对应的创建方法或工厂实例，这可能导致代码结构混乱，尤其是在有大量相关产品的大型项目中。 单一职责原则违背：在某些情况下，一个工厂类可能需要处理多个不同类的创建问题，这违反了单一职责原则（SRP）。理想的工厂应该只负责创建特定类型的产品，如果必须同时处理多种类型，则其职责会变得过于广泛。 依赖增加：使用工厂模式引入了一个新的接口或抽象层，这可能导致代码中对工厂类的依赖增加。在某些情况下，这种依赖可能难以去除，尤其是当工厂类成为多个客户端组件之间的耦合点时。 动态性限制：虽然工厂模式允许通过传递参数或配置文件来控制创建过程中的决策（如产品实例的选择），但这些设置往往需要在代码中硬编码。如果需要在运行时进行更复杂的自定义逻辑，可能需要更复杂的方法或额外的工厂类，这会增加系统的复杂性。 调用链复杂：当一个工厂负责多个层次的对象创建时（例如，父工厂创建子工厂），可能会形成复杂的调用链。这种结构可能难以理解、测试和维护，尤其是在对象树非常深的情况下。 资源管理问题：在处理大量或动态创建的对象时，工厂模式可能导致资源管理问题，如内存泄露或未正确关闭的资源（例如数据库连接）。如果产品实例需要特定生命周期管理，那么必须仔细考虑如何在工厂中实现这一点，以避免这些问题。 非确定性创建过程：如果产品的创建过程依赖于外部因素（比如用户输入、配置文件、环境变量等），则工厂模式可能难以保证创建过程的确定性和可预测性。这可能会导致在某些情况下（如自动化测试）出现预期之外的结果或错误。 对需求变化的适应性差：如果产品的需求或类型经常发生变化，那么需要频繁地修改工厂类以支持这些新需求。这可能导致代码库中大量重复的工作和维护负担。","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"智能指针","slug":"cpp-pointer","date":"2024-07-10T13:38:33.000Z","updated":"2024-11-08T02:21:34.891Z","comments":true,"path":"2024/07/10/cpp-pointer/","permalink":"http://example.com/2024/07/10/cpp-pointer/","excerpt":"","text":"智能指针概述 为什么要有智能指针：直接用new和delete运算符极其容易导致内存泄露，而且非常难以避免，于是人们发明了智能指针这种可以自动回收内存的的工具 智能指针一共就三种：普通的指针可以单独一个指针占用一块内存，也可以多个指针共享一块内存 共享型智能指针：shared_ptr 同一块堆内存可以被多个shared_ptr共享 独享型智能指针：unique_ptr 同一块堆内存只能被一个unique_ptr拥有 弱引用智能指针：weak_ptr 也是一种共享型智能指针，可以视为对共享型智能指针的一种补充 1234567#include &lt;iostream&gt;int main() &#123; int *pi = new int(10); int *pi2(pi); //NOTE: pi和pi2共享同一块内存 return 0;&#125; 智能指针的注意事项 智能指针和裸指针不要混用 shared_ptr工作原理 我们在动态内存分配时，堆上的内存必须通过栈上的内存来寻址，也就是说栈上的指针(堆上的指针也可以指向堆内存，但终究是要通过栈来寻址)是寻找堆内存的唯一方式 所以我们可以给堆内存添加一个引用计数，有几个指针指向它，它的引用计数就是几。当引用计数为 0 时，操作系统就会释放掉这块内存 常用操作1. 初始化使用new运算符初始化 一般来说不推荐使用new进行初始化，因为 C++标准提供了专门创建shared_ptr的函数make_shared()，该函数是经过优化的，效率更高 使用make_shared()初始化 注意 ： 千万不要用裸指针初始化shared_ptr，容易出现内存泄露的问题 使用复制构造函数初始化也行 12345678910111213141516#include &lt;iostream&gt;#include &lt;memory&gt;int main() &#123; std::shared_ptr&lt;int&gt; shared1(new int (100)); std::shared_ptr&lt;int&gt; shared2 = std::make_shared&lt;int&gt;(100); std::shared_ptr&lt;int&gt; shared3(shared2);// 使用复制构造函数初始化也行 int *pi = new int(100); std::shared_ptr&lt;int&gt; shared4(pi); // delete pi; // NOTE: 会造成二次释放(堆内存的重复释放) return 0;&#125; 2. shared_ptr 的引用计数智能指针就是通过引用计数来判断释放内存的时机的use_count()函数可以得到shared_ptr对象的引用计数 1234567891011121314151617#include &lt;iostream&gt;#include &lt;memory&gt;int main() &#123; std::shared_ptr&lt;int&gt; shared1 = std::make_shared&lt;int&gt;(100); std::cout &lt;&lt; shared1.use_count() &lt;&lt; std::endl; std::shared_ptr&lt;int&gt; shared2(shared1); std::cout &lt;&lt; shared1.use_count() &lt;&lt; std::endl; shared2.reset(); // NOTE: 释放掉该指针对对象的控制权 std::cout &lt;&lt; shared1.use_count() &lt;&lt; std::endl; return 0;&#125; 3. 把 shared_ptr 当成普通指针使用智能指针可以像普通指针那样使用，shared_ptr早已对各种操作进行了重载，就当它是普通指针就可以了 123456789101112#include &lt;iostream&gt;#include &lt;memory&gt;int main() &#123; std::shared_ptr&lt;int&gt; shared1 = std::make_shared&lt;int&gt;(100); std::cout &lt;&lt; *shared1 &lt;&lt; std::endl; return 0;&#125; 4. 常用函数 unique函数 判断该shared_ptr对象是否独占，若独占，返回true，否则返回false 123456789101112131415161718#include &lt;iostream&gt;#include &lt;memory&gt;int main() &#123; std::shared_ptr&lt;int&gt; shared1 = std::make_shared&lt;int&gt;(100); std::cout &lt;&lt; shared1.unique() &lt;&lt; std::endl; std::shared_ptr&lt;int&gt; shared2(shared1); std::cout &lt;&lt; shared1.unique() &lt;&lt; std::endl; shared2.reset(); std::cout &lt;&lt; shared1.unique() &lt;&lt; std::endl; return 0;&#125; reset函数 当reset函数有参数时，改变此shared_ptr对象指向的内存 当reset函数无参数时，将此shared_ptr对象置空，也就是将对象内存的指针设置为nullptr 1234567891011121314151617#include &lt;iostream&gt;#include &lt;memory&gt;int main() &#123; std::shared_ptr&lt;int&gt; shared1 = std::make_shared&lt;int&gt;(100); std::cout &lt;&lt; shared1.unique() &lt;&lt; std::endl; std::shared_ptr&lt;int&gt; shared2 = std::make_shared&lt;int&gt;(100); shared1.reset(new int(100)); shared2 = shared1; shared1.reset(); return 0;&#125; get函数， 强烈不推荐使用 如果一定要用，那么一定不能delete返回的指针 12345678910111213#include &lt;iostream&gt;#include &lt;memory&gt;int main() &#123; std::shared_ptr&lt;int&gt; shared1 = std::make_shared&lt;int&gt;(100); std::cout &lt;&lt; shared1.unique() &lt;&lt; std::endl; delete shared1.get(); // NOTE: 堆内存重复释放 return 0;&#125; swap函数 交换两个智能指针所指向的内存 std命名空间中全局的swap函数 shared_ptr类提供的swap函数 123456789101112131415161718#include &lt;iostream&gt;#include &lt;memory&gt;int main() &#123; std::shared_ptr&lt;int&gt; shared1 = std::make_shared&lt;int&gt;(100); std::shared_ptr&lt;int&gt; shared2 = std::make_shared&lt;int&gt;(1000); shared1.swap(shared2); std::cout &lt;&lt; *shared1 &lt;&lt; std::endl; std::cout &lt;&lt; *shared2 &lt;&lt; std::endl; std::swap(shared1, shared2); std::cout &lt;&lt; *shared1 &lt;&lt; std::endl; std::cout &lt;&lt; *shared2 &lt;&lt; std::endl; return 0;&#125; 5. 关于智能指针创建数组的问题6. 用智能指针作为参数传递时直接值传递就行shared_ptr的大小为固定的8或16字节 也就是两倍指针的大小，32 位系统指针为4个字节，64 位系统指针为8个字节，shared_ptr中就两个指针，所以直接按值传递就行了 7. 总结在现代程序中，当想要共享一块堆内存时，优先使用shared_ptr，可以极大的减少内存泄露的问题 weak_ptr1. 介绍 这个智能指针是在 C++11 的时候引入标准库，它的出现完全是为了弥补shared_ptr的天生缺陷，其实shared_ptr可以说是几乎完美 只是通过引用计数实现的方式也引来了引用成环的问题，这种问题靠他自己是没法解决的，所以在 C++11 的时候将shared_ptr和weak_ptr一起引入了标准库，依次来解决循环引用的问题 2. shared_ptr 循环引用的问题12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;memory&gt;class B;class A &#123;public: std::shared_ptr&lt;B&gt; sharedB;&#125;;class B &#123;public: std::weak_ptr&lt;A&gt; sharedA; // NOTE: 只有把其中一个堆内存用weak_ptr来控制，这两块堆内存才会被释放&#125;;int main() &#123; // std::shared_ptr&lt;int&gt; shared1 = std::make_shared&lt;int&gt;(100); // std::cout &lt;&lt; shared1.use_count() &lt;&lt; std::endl; // // std::weak_ptr&lt;int&gt; weak1(shared1); // std::cout &lt;&lt; shared1.use_count() &lt;&lt; std::endl; std::shared_ptr&lt;A&gt; sharedA1 = std::make_shared&lt;A&gt;(); std::shared_ptr&lt;B&gt; sharedB1 = std::make_shared&lt;B&gt;(); sharedA1-&gt;sharedB = sharedB1; // NOTE: 两个堆内存，你指我，我指你，双方都在等着对方释放 引用计数都为1，当引用计数为0的时候，堆内存才会被释放，所以这就造成了内存泄露 sharedB1-&gt;sharedA = sharedA1; return 0;&#125; 3. weak_ptr 的作用原理weak_ptr的作用对象需要绑定到shared_ptr对象上，作用原理是weak_ptr不会改变shared_ptr的引用计数，只要shared_ptr对象的引用计数为 0，就会释放内存，weak_ptr不会影响到释放内存的功能 4. 总结weak_ptr是用比较少，就是为了处理shared_ptr循环引用问题设计的 unique_ptr1. 介绍独占式智能指针，在是用智能指针时，我们一般优先考虑独占式智能指针，因为消耗更小，如果发现内存需要共享，那么再去是用shared_ptr 2. unique_ptr 的初始化 和 shared_ptr 完全类似 使用new运算符初始化 使用make_unique初始化 123456789101112#include &lt;iostream&gt;#include &lt;memory&gt;int main() &#123; std::unique_ptr&lt;int&gt; unique1(new int(100)); std::unique_ptr&lt;int&gt; unique2 = std::make_unique&lt;int&gt;(1000); std::cout &lt;&lt; *unique1 &lt;&lt; std::endl; std::cout &lt;&lt; *unique2 &lt;&lt; std::endl; return 0;&#125; 3. unique_ptr 的常用操作 unique_ptr禁止复制构造函数，他禁止赋值运算符的重载运算。否则独占毫无意义 unique_ptr允许移动构造，移动赋值。移动语义代表之前的对象已经失去了意义，移动操作自然不影响独占的特性 12345678910111213#include &lt;iostream&gt;#include &lt;memory&gt;int main() &#123; std::unique_ptr&lt;int&gt; unique1 = std::make_unique&lt;int&gt;(100); std::unique_ptr&lt;int&gt; unique2 = std::make_unique&lt;int&gt;(1000); unique2 = std::move(unique1); std::cout &lt;&lt; *unique2 &lt;&lt; std::endl; return 0;&#125; reset()函数 不带参数的情况下，释放智能指针的对象，并将智能指针置空 带参数的情况下，释放智能指针的对象，并将智能指针指向新的对象 123456789101112131415#include &lt;iostream&gt;#include &lt;memory&gt;int main() &#123; std::unique_ptr&lt;int&gt; unique1 = std::make_unique&lt;int&gt;(100); std::unique_ptr&lt;int&gt; unique2 = std::make_unique&lt;int&gt;(1000); unique1.reset(); unique2.reset(new int(12)); std::cout &lt;&lt; *unique2 &lt;&lt; std::endl; return 0;&#125; 将unique_ptr的对象转化为shared_ptr的对象，当unique_ptr的对象作为一个右值时，就可以将该对象转化为shared_ptr的对象 这个使用的并不多，需要将独占式指针转化为共享式指针常常是因为先前设计失误注意：shared_ptr 对象无法将其转化为 unique_ptr 对象 1234567891011121314#include &lt;iostream&gt;#include &lt;memory&gt;void myfunc(std::unique_ptr&lt;int&gt; unique3) &#123; std::shared_ptr&lt;int&gt; shared1(std::move(unique3));&#125; // NOTES: 一旦将一个对象转化成右值时，必须保证以后不再单独是用这个对象int main() &#123; std::unique_ptr&lt;int&gt; unique1 = std::make_unique&lt;int&gt;(100); std::unique_ptr&lt;int&gt; unique2 = std::make_unique&lt;int&gt;(1000); return 0;&#125; 智能指针的适用范围1. 能使用智能指针就尽量是用智能指针 ， 但是有些情况下不能使用智能指针有些函数必须使用 C 语言的指针，这些函数又没有替代，这种情况下，才使用普通的指针，其他情况一律是用智能指针 必须使用 C 语言的指针包括: 网络传输函数：比如 windows 下的send,recv函数，智能使用 C 语言的指针，无法替代 C 语言文件操作部分：这方面 C++已经有了替代品，C++的文件部分完全支持智能指针，所以在做大型项目时，推荐使用 C++的文件操作功能 2. 我们应该是用哪个智能指针呢？ 优先使用unique_ptr，内存需要共享时使用shared_ptr 当使用shared_ptr时，如果出现循环引用的情况下，再去考虑weak_ptr","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"}]},{"title":"asio socket的创建和连接","slug":"linux-socket-programming-2","date":"2024-07-03T08:22:19.000Z","updated":"2024-11-08T02:21:34.892Z","comments":true,"path":"2024/07/03/linux-socket-programming-2/","permalink":"http://example.com/2024/07/03/linux-socket-programming-2/","excerpt":"","text":"终端节点的创建所谓终端节点就是用来通信的端对端的节点，可以通过ip地址和端口构造，其的节点可以连接这个终端节点做通信 如果是客户端，可以通过对端的ip和端口构造一个endpoint对象 12345678910111213141516171819202122232425int client_endpoint() { // 定义需要解析的IP地址字符串和端口号 std::string raw_ip_address = \"127.0.0.1\"; unsigned short port_num = 8080; boost::system::error_code error; // 错误代码容器 // 使用Boost.Asio库中的ip::address_from_string()函数解析IP地址字符串 boost::asio::ip::address ip_address = boost::asio::ip::address::from_string( raw_ip_address, error ); // 检查解析过程是否有错误发生，并输出相应的错误信息或返回错误代码 if (error.value() != 0) { std::cout &lt;&lt; \"Failed to parse IP address. Error code is: \" &lt;&lt; error.value() &lt;&lt; \", Message: \" &lt;&lt; error.message() &lt;&lt; std::endl; return error.value(); // 返回错误代码 } // 使用解析的IP地址和端口号构建TCP endpoint对象 boost::asio::ip::tcp::endpoint ep( ip_address, port_num ); // 函数返回值，表示操作是否成功执行（如果未抛出异常则假设为0） return 0;} 如果是服务端，则只需要本地地址绑定就可以生成endpoint 123456789101112int server_endpoint() { unsigned short port_num = 8080; // 设置服务器监听端口号为8080 // 使用IPv4地址类型设置一个任意的本地IP地址。这意味着服务器将侦听来自任何合法的IPv4地址。 boost::asio::ip::address ip_address = boost::asio::ip::address_v4::any(); // 创建一个TCP端点（endpoint），它将绑定到指定的本地IP地址和端口号上 boost::asio::ip::tcp::endpoint ep(ip_address, port_num); return 0; // 表示函数执行成功，返回值为0} 创建socket 创建上下文io_context 选择协议 生成socket 打开socket 12345678910111213141516171819202122int create_tcp_socket() { // 使用boost::asio中的ip模块和tcp类定义协议版本v4的套接字 using boost::asio::ip::tcp; boost::asio::io_context ios; // 创建IO上下文，用于处理异步操作 tcp protocol = tcp::v4(); // 初始化并配置为IPv4协议 tcp::socket sock( ios, protocol ); // 使用给定的io_context创建一个新套接字，并将其初始化为指定协议版本 boost::system::error_code ec; // 创建错误代码对象，用于捕获可能发生的异常 sock.open( protocol, ec ); // 尝试打开一个与指定协议兼容的新套接字 if ( ec.value() != 0 ) { // 检查是否发生任何错误 std::cout &lt;&lt; \"Failed to open the socket! Error code: \" &lt;&lt; ec.value() &lt;&lt; \" Message: \" &lt;&lt; ec.message() &lt;&lt; std::endl; return ec.value(); // 如果打开套接字失败，返回错误代码作为结果值 } return 0; // 成功的情况下，函数返回0表示成功创建了TCP套接字} 上面的socket只是通信的socket,如果是服务端，我们还需要生成一个acceptor的socket,用来接受新的连接 1234567891011121314151617181920212223int create_acceptor_socket() { // 使用boost::asio中的ip模块和tcp类定义协议版本v6的套接字接受器（acceptor） using boost::asio::ip::tcp; boost::asio::io_context ios; // 创建IO上下文，用于处理异步操作 tcp protocol = tcp::v6(); // 初始化并配置为IPv6协议 tcp::acceptor acceptor( ios ); // 使用给定的io_context创建一个新接受器（acceptor），用于监听连接请求 boost::system::error_code ec; // 创建错误代码对象，用于捕获可能发生的异常 // 尝试打开一个与指定协议兼容的新接受器 acceptor.open( protocol, ec ); if ( ec.value() != 0 ) { // 检查是否发生任何错误 std::cout &lt;&lt; \"Failed to open the socket! Error code: \" &lt;&lt; ec.value() &lt;&lt; \" Message: \" &lt;&lt; ec.message() &lt;&lt; std::endl; return ec.value(); // 如果打开接受器失败，返回错误代码作为结果值 } return 0; // 成功的情况下，函数返回0表示成功创建了IPv6协议的接受器（acceptor）} 绑定acceptor对于acceptor类型的socket,服务器需要将其绑定到指定的断点，所有连接这个端点的连接都可以被接收到 12345678910111213141516171819202122232425262728293031int bind_acceptor_socket() { // 使用boost::asio中的ip模块和tcp类定义协议版本v4的套接字接受器（acceptor） using boost::asio::ip::tcp; // 指定要绑定的端口号，这里为8080 unsigned short port_num = 8080; tcp::endpoint endpoint( boost::asio::ip::address_v4::any(), port_num ); // 创建一个网络端点对象用于指定IP地址和端口 // 创建IO上下文，用于处理异步操作 boost::asio::io_context ios; tcp::acceptor acceptor( ios, endpoint ); // 使用给定的io_context创建并初始化一个新接受器（acceptor），同时绑定到指定的端点 boost::system::error_code ec; // 创建错误代码对象，用于捕获可能发生的异常 // 尝试将接受器（acceptor）绑定到指定的网络端点 acceptor.bind( endpoint, ec ); if ( ec.value() != 0 ) { // 检查是否发生任何错误 std::cout &lt;&lt; \"Failed to bind the socket! Error code: \" &lt;&lt; ec.value() &lt;&lt; \" Message: \" &lt;&lt; ec.message() &lt;&lt; std::endl; return ec.value(); // 如果绑定失败，返回错误代码作为结果值 } return 0; // 成功的情况下，函数返回0表示成功绑定了接受器（acceptor）到指定端口} 连接指定的端点作为客户端可以连接服务器指定的端点进行连接 1234567891011121314151617181920212223242526272829int connect_to_endpoint() { // IP地址字符串和端口号定义 std::string raw_ip_address = \"127.0.0.1\"; unsigned short port_num = 8080; // 使用std::exception类来捕获可能抛出的异常 using boost::asio::ip::tcp; try { tcp::endpoint endpoint(boost::asio::ip::address::from_string(raw_ip_address), port_num); // 创建IO上下文，用于处理异步操作 boost::asio::io_context ios; // 创建socket并初始化为指定协议版本的套接字 tcp::socket soc(ios, endpoint.protocol()); // 尝试连接到指定端点（endpoint） soc.connect(endpoint); } catch (std::exception &amp;e) { // 如果在尝试连接时抛出异常，捕获它并输出错误信息 std::cerr &lt;&lt; e.what() &lt;&lt; std::endl; return -1; // 返回一个非零值表示连接失败 } return error.value(); // 函数返回0表示成功建立了与指定端点的连接} 服务器接收连接当有客户端连接时，服务器需要接收连接 123456789101112131415161718192021222324252627282930313233343536int accept_new_connection() { // 指定要监听的端口号，这里为8080 unsigned short port_num = 8080; using boost::asio::ip:: tcp; // 使用ip模块和tcp类定义协议版本v4的套接字接受器（acceptor） tcp::endpoint endpoint( boost::asio::ip::address_v4::any(), port_num ); // 创建一个网络端点对象用于指定IP地址为任何可用地址和指定的端口 // 创建IO上下文，用于处理异步操作 boost::asio::io_context ios; try { tcp::acceptor acceptor( ios, endpoint.protocol() ); // 使用给定的io_context创建并初始化一个新接受器（acceptor），同时绑定到指定的端点 // 设置最大连接队列长度为BACKLOG acceptor.listen( BACKLOG ); // 创建socket并初始化为指定协议版本的套接字 tcp::socket socket( ios, endpoint.protocol() ); // 接受新的客户端连接请求，并将其绑定到新的socket对象上 acceptor.accept( socket ); } catch ( std::exception &amp;e ) { // 如果在处理过程中抛出异常，捕获并输出错误信息 std::cerr &lt;&lt; e.what() &lt;&lt; std::endl; return -1; // 返回一个非零值表示接受新连接失败 } return 0; // 成功接收新的客户端连接后返回0作为结果值} bufferbuffer就是用来接收和发送数据时缓存数据的接口 boost::asio提供了asio::mutable_buffer和asio::const_buffer两种类型的buffer，他们是一段连续的空间，首字节存储了后续数据的长度。asio::mutable_buffer用于写服务，asio::const_buffer用于读服务。但是着这两个结构都没有被asio的api直接使用 对于api的buffer参数，asio提出了MutableBufferSequence和ConstBufferSequence两种类型的buffer参数，他们是由多个asio::mutable_buffer和多个asio::const_buffer组成的容器。MutableBufferSequence和ConstBufferSequence的具体类型是boost::asio::mutable_buffer和boost::asio::const_buffer。也就是说boost::asio为了节省空间，将一部分连续空间组合起来，交给api使用。可以理解为MutableBufferSequence的数据结构为std::vector&lt;boost::asio::mutable_buffer&gt;，ConstBufferSequence的数据结构为std::vector&lt;boost::asio::const_buffer&gt; std::vector&lt;boost::asio::mutable_buffer&gt;的结构如下 每个vector存储的都是mutable_buffer的地址，每个mutable_buffer的第一个字节表示数据的长度，后面跟着数据内容。 这么复杂的结构交给用户使用并不合适，所以asio提出了buffer()函数，该函数接收多种形式的字节流，该函数返回asio::mutable_buffers_1或者asio::const_buffers_1结构的对象。 如果传递给buffer()的参数是一个只读类型，则函数返回asio::const_buffers_1 类型对象。 如果传递给buffer()的参数是一个可写类型，则返回asio::mutable_buffers_1 类型对象。 asio::const_buffers_1和asio::mutable_buffers_1是asio::mutable_buffer和asio::const_buffer的适配器，提供了符合MutableBufferSequence和ConstBufferSequence概念的接口，所以他们可以作为boost::asio的api函数的参数使用。 总的来说，我们可以用buffer()函数来生成我们要使用的缓存存储数据比如boost的发送接口send要求的参数为ConstBufferSequence类型 12template&lt;typename ConstBufferSequence&gt;std::size_t send(const ConstBufferSequence &amp;buffers); 将”Hello World”转换成这种类型 123456void use_const_buffer() { std::string buf = \"Hello World\"; boost::asio::const_buffer asio_buf(buf.c_str(), buf.length()); std::vector&lt;boost::asio::const_buffer&gt; buffers; buffers.push_back(asio_buf);} 现在buffers就是可以传递给接口send的类型，但是这样太复杂了，可以直接使用buffer函数转为为send所需要的类型 123void use_buffer_str() { asio::const_buffer asio_buf(\"Hello World\");} asio_buf可以直接传递给send接口。也可以将数组转化为send接受的类型 12345void use_buffer_array() { const size_t BUF_SIZE = 20; std::unique_ptr&lt;char[]&gt; buf(new char[BUF_SIZE]); auto input_buf = boost::asio::buffer(static_cast&lt;void*&gt;(buf.get()), BUF_SIZE);} 对于流式操作，可以用streambuf，将输入输出流和streambuf组合起来，可以实现流式输入和输出 12345678910111213141516171819202122void use_stream_buffer() { // 创建一个 asio::streambuf 对象来存储和处理流操作。 asio::streambuf buf; // 将 std::ostream 与作为参数传递给 `operator&lt;&lt;` 的 streambuf 关联起来，用于写入数据。 std::ostream output(&amp;buf); // 向输出流中写入两条消息，并以换行符分隔。 output &lt;&lt; \"Message1\\n\"; output &lt;&lt; \"Message2\"; // 创建一个 std::istream 与 streambuf 相关联，以便从其中读取数据。 // 注意：这里传递的 `&amp;buf` 实际上是作为 `std::streambuf*` 的指针，而不是 `asio::streambuf` 类型。这是一个小错误示例代码中的注释可能未能正确地指出这一点。 std::istream input(&amp;buf); // 定义一个字符串变量用于存储读取的数据，并使用 getline() 函数从输入流中读取数据直到遇到换行符 '\\n'。 std::string message1; std::getline(input, message1); // 现在，`message1` 变量将包含读取的 \"Message1\" 字符串（因为 getline() 函数停止在遇到下一个换行符之前）。}","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"},{"name":"网络编程","slug":"网络编程","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"socket","slug":"socket","permalink":"http://example.com/tags/socket/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"操作系统笔记01","slug":"operating-system-1","date":"2024-07-02T15:22:47.000Z","updated":"2025-03-06T09:39:24.492Z","comments":true,"path":"2024/07/02/operating-system-1/","permalink":"http://example.com/2024/07/02/operating-system-1/","excerpt":"","text":"操作系统的概念、功能、目标作为用户和计算机硬件之间的接口 提供的功能： 命令接口： 联机命令接口(输入一次，输出一次) 脱机命令接口(批处理命令) 程序接口： 提供系统调用(广义指令) 目标： 方便用户使用 关于库函数和系统调用的区别 库函数是语言或应用程序的一部分，可以运行在运行在用户空间中 系统调用是操作系统的一部分，是内核为用户提供的程序接口，运行在内核空间中，并且许多库函数都是用系统调用来实现功能 注意未使用系统调用的库函数，其执行效率通常要比系统调用的高。因为使用系统调用时，需要上下文的切换及状态转换(由用户态转向核心态) 操作系统的特征并发和并行并发: 是指两个或多个时间在统一时间间隔发生(宏观同时发生，微观交替发生) 并行: 是指在同一时刻能同时完成两种或两种以上的工作 互斥和共享互斥: 在一段时间内只允许一个进程访问资源(例如写入操作) 共享: 在一段时间内允许多个进程访问资源(例如读取操作) 虚拟是指将一个物理上的实体变为若干逻辑上的对应物(例如虚拟机) 异步在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停的，以不可预知的速度向前推进。只有系统拥有并发性，才有可能导致异步性。(例如C++的async，开辟一个一次性的线程执行并行任务，主线程可以通过future在合适的时机执行等待汇总结果。) 操作系统的发展与分类手工操作阶段 纸带机(用户独占全机，人机速度矛盾) 缺点： 用户独占全机，CPU需要等待人工操作，人机速度矛盾，资源利用率低 批处理阶段 单道批处理阶段(外围及–磁带) 优点：解决了人机矛盾和CPU与I&#x2F;O设备速度不匹配问题 缺点： 每次只能运行一道程序，不能充分地利用系统资源 多道批处理系统(操作系统开始出现) 分时操作系统 轮流处理作业 不能处理紧急任务 实时操作系统 优先处理紧急任务 硬实时系统: 必须在严格的时间内完成处理 软实时系统: 可以偶尔犯错 网络操作系统分布式操作系统个人计算机操作系统操作系统的运行环境处理器运行模式 内核态&#x2F;核心态&#x2F;管态 用户态&#x2F;目态 程序的运行原理: 高级语言编写代码–&gt;机器指令 程序运行的过程就是CPU执行指令的效果 两类程序 内核程序 应用程序 两类指令 特权指令: 是指用户不允许直接使用的指令 I&#x2F;O指令 关中断指令 内存清零指令 存取用于内存保护的级存器 送PSW到程序状态字寄存器的指令 非特权指令: 是指允许用户直接使用的指令 无法直接访问系统中的软硬资源 仅限于用户的地址空间 内核(kernel) 内核是操作系统最重要最核心的部分 有很多内核程序组成操作系统内核 如何改变状态 内核态-&gt;用户态: 一条修改PSW的特权指令 用户态-&gt;内核态: 由中断引起，硬件自动完成 中断和异常的概念中断 定义: 是指来自CPU执行指令外部的时间，通常用于信息输入&#x2F;输出。 时钟中断 I&#x2F;O中断请求 分类: 可屏蔽中断: 通过INTR线发出的中断请求，通过改变屏蔽字可以实现多重中断 不可屏蔽中断: 通过NMI线发出的中断请求，通常是紧急的硬件故障 异常 定义: 是指来自CPU执行指令内部的时间，例如程序的非法操作码、地址越界、运算溢出、虚存系统的缺页及专门的陷入指令等引起的事件 分类: 故障: 由指令执行引起的异常 (软件中断) 自陷: 是一种事先安排的“异常”事件，用于在用户态下调用操作系统内核程序 (软件中断) 终止: 出现了使得CPU无法继续执行的硬件故障 (硬件中断) 中断机制的基本实现原理 检查中断信号 内中断: CPU在执行指令时会检查是否会有异常发生 外中断: 每个指令周期末尾，CPU都会检查是否由外中断信号需要处理 找到相应的中断处理程序 通过“中断向量表”实现 系统调用凡是与资源有关的操作，都必须通过系统调用方式向操作系统提出服务请求，并有操作系统代为完成 设备管理: 完成设备的请求或释放，以及设备的启动等功能 文件管理: 完成文件的读、写、创建、删除等功能 进程控制: 完成进程的创建、撤销、阻塞、唤醒等功能 进程通信: 完成进程之间的消息传递或信号传递 内存管理: 完成内存分配、回收及获取作业占用内存区大小和起始地址等功能 系统调用的过程 传参 陷入指令&#x2F;Trap&#x2F;访管 由操作系统内核程序处理系统调用请求 返回应用程序 操作系统的运行机制和体系结构分层结构内核分多层，每层可以单项调用更低一层提供的接口 优点: 便于系统的调试和验证，自底向上逐层调试验证，简化了系统设计和实现 易扩充和易维护，各层之间调用接口清晰固定 缺点: 合理定义各层关系比较困难，仅可调用相邻底层，难以合理定义各层的边界 效率较差，不可跨层调用，系统调用执行时间长 模块化将内核划分为多个模块，各模块之间相互协作 内核 &#x3D; 主模块+可加载内核模块 主模块: 只负责核心功能，如进程调度、内存管理可加载内核模块: 可以动态加载新模块到内核，而无需重新编译整个内核 flowchart TD 操作系统 ---|模块| 进程管理 操作系统 --- 存储器管理 操作系统 --- 文件管理 进程管理 ---|子模块| 进程控制 进程管理 --- 进程调度 存储器管理 --- 内存分配 存储器管理 --- 内存保护 文件管理 --- 磁盘管理 文件管理 --- 目录管理 优点: 模块间逻辑清晰易于维护，确定模块间接口后即可多模块同时开发 支持动态加载新的内核模块(安装设备驱动、安装新的文件系统模块到内核)，增强OS的适应性 任何模块都可以直接调用其他模块，无需采用消息传递进行通信，效率高 缺点: 模块间的接口定义未必合理、使用 模块间相互以来，更难调试和验证 宏内核所有的系统功能都放在内核里（大内核结构的OS通常也采用了“模块的”的设计思想） 优点: 性能高，内核内部各种功能都可以直接相互调用 缺点: 内核庞大功能复杂，难以维护 大内核中某个功能模块出错，就可能导致整个系统崩溃 微内核只把中断、原语、进程通信等最核心的功能放入内核。进程管理、文件管理、设备管理等功能以用户进程的形式运行在用户态 优点: 内核小功能少、易于维护，内核可靠性高 内核外的某个功能模块出错不会导致整个系统的崩溃 缺点: 性能低，需要频繁切换用户态&#x2F;核心态 用户态下的各功能不可以直接相互调用，只能通过内核的“消息传递”来间接通信 外核内核负责进程调度、进程通信等功能。外核负责为用户进程分配未经抽象的硬件资源，且由外核负责保证资源使用安全 优点: 外核可直接给用户进程分配“不虚拟、不抽象”的硬件资源，使用户进程可以更灵活的使用硬件资源 减少了虚拟硬件资源的“映射层”，提升效率 缺点: 降低了系统的一致性 使系统变得更加复杂 操作系统引导 激活CPU 硬件自检 加载带有操作系统的硬盘 加载MBR(主引导记录) 扫描硬盘分区表 加载分区引导记录 加载启动管理器 加载操作系统 虚拟机虚拟机: 使用虚拟化技术，将一台物理机器虚拟化为多台虚拟机起，每个虚拟机起都可以独立运行一个操作系统 两类虚拟机管理程序的对比 第一类VM 第二类VM 对物理资源的控制权 直接运行在硬件之上，能直接控制和分配物理资源 运行在HOST OS之上，依赖于HOST OS为其分配物理资源 资源分配方式 在安装GUEST OS时，VMM要在原本的硬盘上进行分配 GUEST OS拥有自己的虚拟硬盘，是HOST OS文件系统中的一个大文件， 性能 性能更好 性能更差 可支持的虚拟机数量 更多，不需要和HOST OS竞争资源 更少，HOST OS本身也需要一定的系统资源 虚拟机的可迁移性 更差 只需要导出镜像文件即可 运行模式 运行在最高特权级，可以执行最高特权的指令 部分运行在用户态、部分运行在内核态。GUEST OS发出的系统调用会被VMM截获，转换为VMM对HOST OS的系统调用","categories":[{"name":"考研","slug":"考研","permalink":"http://example.com/categories/%E8%80%83%E7%A0%94/"}],"tags":[{"name":"408","slug":"408","permalink":"http://example.com/tags/408/"},{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"socket的创建和连接","slug":"linux-socket-programming-1","date":"2024-06-29T16:51:53.000Z","updated":"2024-11-08T02:21:34.892Z","comments":true,"path":"2024/06/30/linux-socket-programming-1/","permalink":"http://example.com/2024/06/30/linux-socket-programming-1/","excerpt":"","text":"socket编程socket的概念Socket（套接字）是计算机网络编程中的一个基本概念，它为应用程序提供了访问底层网络协议的接口，使得进程间能够通过网络进行通信。在更广泛的意义上，Socket 是操作系统提供的一个抽象层，用于简化网络编程并隐藏复杂的网络协议细节。 Socket 是两个进程间通信的端点，每个 Socket 都有唯一的地址，这个地址包括 IP 地址和端口号。IP 地址用于定位网络上的主机，而端口号则用于区分同一台主机上的不同服务。 socket的类型socket 可以分为几种类型，主要依据它们支持的协议和通信模式： 流式 Socket (SOCK_STREAM)： 基于 TCP 协议，提供面向连接的服务，保证数据的顺序传输，且不会丢失数据。 数据报 Socket (SOCK_DGRAM)： 基于 UDP 协议，提供无连接服务，数据报文独立传输，不保证数据的顺序和完整性，但传输效率较高。 原始 Socket (SOCK_RAW)： 直接访问 IP 层，允许应用程序直接处理 IP 数据包，常用于网络分析或特殊用途的软件。 socket提供的函数 socket() 创建一个新的确定类型的套接字，类型用一个整型数值标识，并为它分配系统资源。 bind() 一般用于服务器端，将一个套接字与一个套接字地址结构相关联，比如，一个指定的本地端口和IP地址。 listen() 用于服务器端，使一个绑定的TCP套接字进入监听状态。 connect()用于客户端，为一个套接字分配一个自由的本地端口号。 如果是TCP套接字的话，它会试图获得一个新的TCP连接。 accept()用于服务器端。 它接受一个从远端客户端发出的创建一个新的TCP连接的接入请求，创建一个新的套接字，与该连接相应的套接字地址相关联。 send()和recv(),或者write()和read(),或者recvfrom()和sendto(),用于往&#x2F;从远程套接字发送和接受数据。 close()用于系统释放分配给一个套接字的资源。 如果是TCP，连接会被中断。 gethostbyname()和&#96;gethostbyaddr() select()用于修整有如下情况的套接字列表： 准备读，准备写或者是有错误。 poll()用于检查套接字的状态。 套接字可以被测试，看是否可以写入、读取或是有错误。 getsockopt()用于查询指定的套接字一个特定的套接字选项的当前值。 setsockopt()用于为指定的套接字设定一个特定的套接字选项。 1. socket() 作用：创建一个新的 Socket。 参数： int domain：地址族，如 AF_INET（IPv4）或 AF_INET6（IPv6）。 int type：Socket 类型，如 SOCK_STREAM（面向连接，流式）或 SOCK_DGRAM（无连接，数据报）。 int protocol：协议，通常是 0，表示使用与 type 关联的默认协议。 2. bind() 作用：将 Socket 与本地地址（IP 地址和端口号）相关联。 参数： int sockfd：Socket 文件描述符。 const struct sockaddr *addr：指向包含地址信息的 sockaddr 结构体的指针。 socklen_t addrlen：sockaddr 结构体的长度。 3. listen() 作用：使 Socket 准备接收连接，通常用于服务器端。 参数： int sockfd：Socket 文件描述符。 int backlog：待处理连接请求的最大队列长度。 4. accept() 作用：接受传入的连接请求，并返回一个新的 Socket 文件描述符用于通信。 参数： int sockfd：监听的 Socket 文件描述符。 struct sockaddr *addr：可选参数，用于存储客户端的地址信息。 socklen_t *addrlen：可选参数，用于存储地址信息的长度。 5. connect() 作用：初始化与远程主机的连接，通常用于客户端。 参数： int sockfd：Socket 文件描述符。 const struct sockaddr *addr：指向包含远程主机地址信息的 sockaddr 结构体的指针。 socklen_t addrlen：sockaddr 结构体的长度。 6. send() 作用：发送数据到已连接的 Socket。 参数： int sockfd：Socket 文件描述符。 const void *buf：指向要发送数据的缓冲区的指针。 size_t len：要发送的数据长度。 int flags：发送标志，如 MSG_DONTROUTE。 7. recv() 作用：从 Socket 接收数据。 参数： int sockfd：Socket 文件描述符。 void *buf：接收数据的缓冲区。 size_t len：缓冲区的大小。 int flags：接收标志，如 MSG_PEEK。 8. sendto() 作用：向特定地址发送数据，通常用于无连接的 Socket（如 UDP）。 参数：与 send() 类似，额外包括目标地址和地址长度。 9. recvfrom() 作用：接收数据并返回源地址信息，通常用于无连接的 Socket（如 UDP）。 参数：与 recv() 类似，额外包括源地址信息和地址长度。 10. close() 作用：关闭 Socket 文件描述符，释放资源。 参数： int sockfd：要关闭的 Socket 文件描述符。 11. setsockopt() 作用：设置 Socket 的选项，如超时、重用地址等。 参数： int sockfd：Socket 文件描述符。 int level：设置选项的级别，如 SOL_SOCKET 或 IPPROTO_TCP。 int optname：选项名称。 const void *optval：指向选项值的指针。 socklen_t optlen：选项值的长度。 12. getsockopt() 作用：获取 Socket 的选项。 参数：与 setsockopt() 类似。 13. shutdown() 作用：关闭 Socket 的读取或写入方向。 参数： int sockfd：Socket 文件描述符。 int how：关闭的方向，如 SHUT_RD（读取方向）或 SHUT_WR（写入方向）。 注意事项 使用 Socket 编程时，应确保正确处理错误情况，检查每个函数的返回值，并适当地处理任何错误代码。 对于某些函数，如 send() 和 recv()，如果在非阻塞模式下使用，可能需要处理 EAGAIN 或 EWOULDBLOCK 错误码，这表明操作无法立即完成。 在实际编程中，根据具体需求，可能还需要使用到其他函数，例如 select() 或 poll() 用于多路复用，或者 fork() 和 exec() 用于创建子进程处理连接。 TCP socket通信流程 服务器端流程如下： 创建服务器的socket 初始化sever_addr(服务器地址) 将socket和server_addr绑定 bind 开始监听listen 开一个循环保证服务器不会结束，不断的accept接入的客户端请求，进行读写操作write和read (send()和recv()也行) 关闭socket 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;string.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#define SERVER_PORT 10005#define BUFFLEN 1024#define BACLOG 10// 创建新的socket，返回文件描述符int create_socket() &#123; int res = socket(AF_INET, SOCK_STREAM, 0); // NOTE: 如果想要使用UDP协议，只需要将SOCK_STREAM改为SOCK_DGRAM即可 if (res &lt; 0) &#123; perror(&quot;create socket failed&quot;); exit(EXIT_FAILURE); &#125; printf(&quot;create socket successfully\\n&quot;); return res;&#125;// 初始化服务器地址信息void initialize_address(struct sockaddr_in *server_addr) &#123; memset(server_addr, 0, sizeof(*server_addr)); server_addr-&gt;sin_family = AF_INET; // 监听所有可用地址 server_addr-&gt;sin_addr.s_addr = htons(INADDR_ANY); server_addr-&gt;sin_port = htons(SERVER_PORT);&#125;// 绑定socket到指定的地址void try_bind(int socket_fd, const struct sockaddr *server_addr) &#123; if (bind(socket_fd, server_addr, sizeof(*server_addr)) &lt; 0) &#123; perror(&quot;bind failed&quot;); exit(EXIT_FAILURE); &#125; puts(&quot;bind successfully&quot;);&#125;// 处理客户端请求void process_client_request(int socket_client) &#123; char send_buf[BUFFLEN] = &#123;0&#125;; char recv_buf[BUFFLEN] = &#123;0&#125;; // 发送的消息，以方便日后添加或修改 snprintf(send_buf, BUFFLEN, &quot;Hello, this is the server&quot;); while (1) &#123; ssize_t num_read = read(socket_client, recv_buf, BUFFLEN); // 客户端断开连接，或读取失败 if (num_read &lt;= 0) &#123; if (num_read == 0) puts(&quot;Client closed connection&quot;); else perror(&quot;read failed&quot;); return; &#125; recv_buf[num_read] = &#x27;\\0&#x27;; // 为接收的字符串添加结束字符 printf(&quot;From Client: %s\\n&quot;, recv_buf); if (strncmp(recv_buf, &quot;exit&quot;, 4) == 0) &#123; // 客户端请求退出 // 修改发送的消息 strcpy(send_buf, &quot;bye!!!&quot;); // 返回消息给客户端 write(socket_client, send_buf, strlen(send_buf)); printf(&quot;Me(Server)：%s\\n&quot;, send_buf); return; &#125; // 向客户端写入发送缓冲区的内容 if (write(socket_client, send_buf, strlen(send_buf)) &lt; 0) &#123; perror(&quot;write failed&quot;); return; &#125; printf(&quot;Me(Server): %s\\n&quot;, send_buf); // 清空接收缓冲区，准备下一次读取 memset(recv_buf, 0, BUFFLEN); &#125;&#125;int main() &#123; int socket_server = create_socket(); // 创建socket struct sockaddr_in server_addr; // 声明地址结构 initialize_address(&amp;server_addr); // 初始化地址结构 try_bind(socket_server, (struct sockaddr*)&amp;server_addr); // 绑定地址到socket // 开始监听连接请求，设定最大等待连接数量为BACLOG if (listen(socket_server, BACLOG) == -1) &#123; perror(&quot;listen failed&quot;); exit(EXIT_FAILURE); &#125; puts(&quot;start listening&quot;); struct sockaddr_in client_addr; socklen_t client_addr_size = sizeof(client_addr); while (1) &#123; // 初始化客户端地址结构 memset(&amp;client_addr, 0, sizeof(client_addr)); // 接受新的连接请求 int socket_client = accept(socket_server, (struct sockaddr*)&amp;client_addr, &amp;client_addr_size); printf(&quot;Client %s:%d connected\\n&quot;, inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port)); if (socket_client &lt; 0) &#123; perror(&quot;receive failed&quot;); continue; // 尝试接受另一个连接 &#125; // 满足要求后开始处理客户端请求 process_client_request(socket_client); close(socket_client); // 关闭客户端连接 &#125; // 正常情况下不会执行到这一步 close(socket_server); return 0;&#125; 客户端流程如下： 创建客户端socket 初始化server_addr 连接到服务器connect 利用write和read进行读写操作 (send()和recv()也行) 关闭socket 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;string.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#define SERVER_PORT 10005#define BUFFLEN 1024/* * 创建套接字并返回其文件描述符 * 如果创建失败，程序将以状态1退出 */int create_socket() &#123; int sock_fd = socket(AF_INET, SOCK_STREAM, 0); if (sock_fd &lt; 0) &#123; perror(&quot;socket创建失败&quot;); // 使用perror提供更多的错误信息 exit(EXIT_FAILURE); &#125; printf(&quot;socket create successfully\\n&quot;); return sock_fd;&#125;/* * 初始化服务器地址结构的函数 */void initialize_address(struct sockaddr_in *server_addr) &#123; memset(server_addr, 0, sizeof(*server_addr)); server_addr-&gt;sin_family = AF_INET; server_addr-&gt;sin_port = htons(SERVER_PORT); server_addr-&gt;sin_addr.s_addr = inet_addr(&quot;192.168.5.120&quot;); // 服务器IP&#125;/* * 建立到服务器的连接 * 如果连接失败，程序将以状态1退出 */void connect_to_server(int socket_fd, const struct sockaddr *server_addr) &#123; if (connect(socket_fd, server_addr, sizeof(*server_addr)) &lt; 0) &#123; perror(&quot;connection failed&quot;); exit(EXIT_FAILURE); &#125; printf(&quot;connection successful\\n&quot;);&#125;/* * 客户端程序开始的主函数 */int main() &#123; int socket_fd = create_socket(); // 创建socket struct sockaddr_in server_addr; initialize_address(&amp;server_addr); // 初始化服务器详细信息 connect_to_server(socket_fd, (struct sockaddr*)&amp;server_addr); // 连接到服务器 char send_buf[BUFFLEN] = &#123;0&#125;; // 用于发送数据的缓冲区 char recv_buf[BUFFLEN] = &#123;0&#125;; // 用于接收数据的缓冲区 // 持续从用户获取输入并发送到服务器，直到从服务器接收到&quot;bye!!!&quot; while (fgets(send_buf, BUFFLEN, stdin)) &#123; // 向服务器写入用户输入 if (write(socket_fd, send_buf, strnlen(send_buf, BUFFLEN)) == -1) &#123; perror(&quot;write failed&quot;); break; &#125; printf(&quot;Me(Client):%s&quot;, send_buf); // 打印用户输入 memset(send_buf, 0, BUFFLEN); // 清除发送缓冲区 // 读取服务器的响应 if (read(socket_fd, recv_buf, BUFFLEN) == -1) &#123; perror(&quot;receive failed&quot;); break; &#125; printf(&quot;Server:%s&quot;, recv_buf); // 打印服务器的响应 if (strcmp(recv_buf, &quot;bye!!!&quot;) == 0) &#123; break; &#125; memset(recv_buf, 0, BUFFLEN); // 清除接收缓冲区 &#125; close(socket_fd); // 关闭套接字 return 0;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"},{"name":"网络编程","slug":"网络编程","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"socket","slug":"socket","permalink":"http://example.com/tags/socket/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"python-grammar-1","slug":"python-grammar-1","date":"2024-05-02T08:47:48.000Z","updated":"2024-11-08T02:21:34.892Z","comments":true,"path":"2024/05/02/python-grammar-1/","permalink":"http://example.com/2024/05/02/python-grammar-1/","excerpt":"","text":"Python 数据类型数字在python中数字有三种类型：整数(int)、浮点数(float)、复数(complex)我们可以使用type()函数来判断一个变量或值属于哪个类，还可以通过instance()函数来检查对象是否属于特定的类 12345678910111213def checkType(a): print(a, type(a))a = 1b = 2.5c = 1+2jprint(c, &#x27;是复数吗？&#x27;, isinstance(c, complex))checkType(a)checkType(b)checkType(c) 输入 input([prompt]) 123456num = input(&#x27;Enter a number&#x27;)print(num)# 由于默认是字符串，需要做类型转换a = (int)(input(&#x27;Enter an integer&#x27;)) 列表列表中的项目允许不是同一类型。我们可以使用[]运算符从列表中提取一个项目 或 一系列项目。注意，在Python中，索引从0开始。 12345678# NOTE: 声明a = [1, 2.2, &#x27;python&#x27;]b = [5, 10, 14, 20, 30 , 50 , 4]print(&#x27;a[2]=&#x27;, a[2])print(&#x27;b[4]=&#x27;, b[4]) 元组元组和列表相同，但是元组中的元素是不可变的，元组一旦创建就不可修改 它在括号内 () 定义，其中各项之间用逗号分隔 123456# NOTE: 声明tup = (1 , &#x27;awdaw&#x27;, 12);print(tup)# BUG: tup[1] = 1 字符串字符串和元组一样，其中的元素是不可变的 123456# NOTE: 声明s = &quot;awdawdwada&quot;print(&quot;s[4]&quot;, s[4])# BUG: s[4] = 1 集合Set 是唯一项的无序集合。Set 由用大括号 { } 括起来，并由逗号分隔的值的集合。集合中的项目是无序的 1234# NOTE: 声明s = &#123;5, 5, 3, 3 ,1, 1, 2, 2, 4, 4, 6&#125;print(&#x27;s =&#x27;,s, type(s))# BUG: s[2] = 2; 字典类似哈希表，需要一个key和一个value，key是唯一的，value可以是任何类型。字典中的项目是无序的 1234567# NOTE: 声明d = &#123;1:&#x27;value&#x27;, &#x27;key&#x27;:2&#125;print(d, type(d))# NOTE: 访问print(&quot;d[&#x27;key&#x27;] = &quot;, d[&#x27;key&#x27;]) 类对象与类12345678910111213141516171819202122232425262728class Parrot: # 类属性 species = &#x27;bird&#x27; # Constructor def __init__(self, name, age): self.name = name; self.age = age; # Method def string(self, song): return &quot;&#123;&#125; song is &#123;&#125;&quot;.format(self.name, song) def dance(self): return &quot;&#123;&#125; is now dancing&quot;.format(self.name)blu = Parrot(&quot;麻雀&quot;, 10)woo = Parrot(&quot;鹦鹉&quot;, 14)print(&quot;麻雀是 &#123;&#125;&quot;.format(blu.__class__.species))print(&quot;鹦鹉是 &#123;&#125;&quot;.format(woo.__class__.species))print(&quot;&#123;&#125; is &#123;&#125; old&quot;.format(blu.name, blu.age))print(&quot;&#123;&#125; is &#123;&#125; old&quot;.format(woo.name, woo.age))print( blu.string(&quot;极乐净土&quot;) )print( blu.dance() ) 继承 可以使用isinstance 和 issubclass 来检查一个对象是该类的实例和是否是一个特定的类或者子类 123456789101112131415161718192021222324252627class Bird: def __init__(self): print(&quot;Bird is ready&quot;) def whoisThis(self): print(&quot;Bird&quot;) def swim(self): print(&quot;Swimming faster&quot;)class Penguin(Bird): def __init__(self): # call super() function super().__init__() print(&quot;Penguin is ready&quot;) def whoisThis(self): print(&quot;Penguin&quot;) def run(self): print(&quot;Run faster&quot;)peggy = Penguin()peggy.whoisThis()peggy.run()peggy.swim() 可封装性123456789101112131415161718class Computer: def __init__(self): self.__maxprice = 900 def sell(self): print(&quot;Price is: &#123;&#125;&quot;.format(self.__maxprice)) def setMaxPrice(self, price): self.__maxprice = pricec = Computer()c.sell()print(&quot;Change price&quot;)c.setMaxPrice(1000)c.sell() 多态123456789101112131415161718192021222324252627class Parrot: def fly(self): print(&quot;Parrot can fly&quot;) def swim(self): print(&quot;Parrot can&#x27;t swim&quot;)class Penguin: def fly(self): print(&quot;Penguin can&#x27;t fly&quot;) def swim(self): print(&quot;Penguin can swim&quot;)# universal methoddef flying_test(bird): bird.fly()blu = Parrot()peggy = Penguin()flying_test(blu)flying_test(peggy) 运算符重载 通过在中实现特殊函数(__function_name__) 运算符 表达 在内部 + p1 + p2 p1.__add__(p2) - p1 - p2 p1.__sub__(p2) * p1 * p2 p1.__mul__(p2) 求幂 ** p1 ** p2 p1.__pow__(p2) 相除 &#x2F; p1 &#x2F; p2 p1.__truediv__(p2) 整除 &#x2F;&#x2F; p1 &#x2F;&#x2F; p2 p1.__floordiv__(p2) % p1 % p2 p1.__mode__(p2) &lt;&lt; p1 &lt;&lt; p2 p1.__lshift__(p2) &gt;&gt; p1 &gt;&gt; p2 p1.__rshift__(p2) and p1 and p2 p1.__and__(p2) or p1 or p2 p1.__or__(p2) ^ p1 ^ p2 p1.__xor__(p2) ~ ~p1 p1.__invert__() &lt; p1 &lt; p2 p1.__lt__(p2) &gt; p1 &gt; p2 p1.__gt__(p2) &lt;&#x3D; p1 &lt;&#x3D; p2 p1.__le__(p2) &gt;&#x3D; p1 &gt;&#x3D; p2 p1.__ge__(p2) &#x3D;&#x3D; p1 &#x3D;&#x3D; p2 p1.__eq__(p2) !&#x3D; p1 !&#x3D; p2 p1.__ne__(p2) 迭代器Python中的Iterator只是一个可以迭代的对象。一个将返回数据的对象，一次返回一个元素。 自定类实现迭代器 123456789101112131415161718192021222324class PowTwo: def __init__(self, max = 0): self.max = max def __iter__(self): self.n = 0 return self def __next__(self): if self.n &lt;= self.max: result = 2 ** self.n self.n += 1 return result else: raise StopIterationa = PowTwo(4)i = iter(a)print(next(i))for i in PowTwo(5): print(i)","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"C++中的静态类型、动态类型、RTTI","slug":"C-Data-Type","date":"2024-04-22T13:10:39.000Z","updated":"2024-11-08T02:21:34.889Z","comments":true,"path":"2024/04/22/C-Data-Type/","permalink":"http://example.com/2024/04/22/C-Data-Type/","excerpt":"","text":"简介本文介绍了C++中的静态类型、动态类型、RTTI。 静态类型C++ 是一种静态类型语言（static typing），这意味着类型检查是在编译时进行而非运行时。换句话说，每个变量、对象、函数返回值等在编译时都必须明确其类型。这种类型系统的主要优点是能够在程序运行之前发现类型不匹配等错误，从而提高代码的安全性和稳定性。 举一个例子 12345678910111213#include &lt;iostream&gt;int main() &#123; int num = 42; // &#x27;num&#x27; 静态类型为int double pi = 3.14159; // &#x27;pi&#x27; 静态类型为double // FIX: num = pi; 这种写法会造成编译错误，因为类型不匹配 std::cout &lt;&lt; &quot;The value of num is: &quot; &lt;&lt; num &lt;&lt; std::endl; std::cout &lt;&lt; &quot;The value of pi is: &quot; &lt;&lt; pi &lt;&lt; std::endl; return 0;&#125; 动态类型在C++这种静态类型语言中，通常所说的”dynamic typing”（动态类型）并不是内置的语言特性，因为C++要求变量在编译时就明确其类型。相对的，”dynamic typing”通常指的是在运行时能够处理多种不同类型的数据。在C++中实现类似动态类型的行为，通常是通过以下几种方式： void指针 ：void* 类型，这种方式通常称为”smart pointer”，它允许程序员在不担心对象的生存周期的情况下，指向任意对象，从而实现动态类型的支持，但使用它们往往需要手动管理类型和内存，同时要在使用前将其转换（强制类型转换）回正确的类型。 多态：利用C++的多态特性，可以通过基类指针或引用来操作一组派生自同一基类的对象。这使得代码可以在运行时处理多种不同类型的对象，而不必在编译时知道具体的派生类型。 任意类型： 通过使用std::any类型，你可以存放任何类型的值，并且在需要的时候通过std::any_cast来提取原始类型，这在某种程度上提供了动态类型的能力。 举点例子： 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;any&gt;void test_void_pointer() &#123; int x = 42; float y = 3.14f; std::string z = &quot;hello world\\n&quot;; void* void_ptr; void_ptr = &amp;x; std::cout &lt;&lt; &quot;int_value: &quot; &lt;&lt; *(static_cast&lt;int*&gt;(void_ptr)) &lt;&lt; std::endl; void_ptr = &amp;y; std::cout &lt;&lt; &quot;double_value: &quot; &lt;&lt; *(static_cast&lt;double*&gt;(void_ptr)) &lt;&lt; std::endl; void_ptr = &amp;z; std::cout &lt;&lt; &quot;string_value: &quot; &lt;&lt; *(static_cast&lt;std::string*&gt;(void_ptr)) &lt;&lt; std::endl;&#125;void test_any() &#123; std::any any_value; any_value = 42; std::cout &lt;&lt; &quot;int_value: &quot; &lt;&lt; std::any_cast&lt;int&gt;(any_value) &lt;&lt; std::endl; any_value = 3.14; std::cout &lt;&lt;&quot;double_value: &quot; &lt;&lt; std::any_cast&lt;double&gt;(any_value) &lt;&lt; std::endl; any_value = std::string( &quot;awdawda&quot; ); std::cout &lt;&lt; &quot;string_value: &quot; &lt;&lt; std::any_cast&lt;std::string&gt;(any_value) &lt;&lt; std::endl;&#125;int main() &#123; test_void_pointer(); test_any(); return 0;&#125; 需要注意的是，上面实例中的void*和std::any由于额外的类型检查和转换，会在运行时导致额外的性能开销。 RTTIRTTI，即运行时类型信息（Run-Time Type Identification），是C++语言中的一个机制，它允许在程序运行时获取对象的类型信息。RTTI是面向对象编程中多态性的一个重要特性，它能够让我们在程序运行时确定对象的实际派生类型。 RTTI主要涉及以下两个操作符和一个类类型特性： dynamic_cast: 用于安全地在继承体系中转换指针或引用。它是类型转换的一种，可以将基类的指针或引用转换为派生类的指针或引用，并在转换不安全的情况下提供错误检查。 typeid: 当你对表达式使用typeid时，它会返回一个std::type_info对象的引用，该对象代表了表达式的类型。如果该表达式是一个多态类型（即含有虚函数的类）的对象，typeid会返回该对象的动态类型，也就是最派生的类型。 std::type_info: 这是与typeid一起使用的标准库类，其对象包含了类型的信息，如类型的名称。它提供了比较两个类型是否相等的能力，即通过type_info的operator==来确定两个对象是否为同一类型。 例子： typeid: 123456789101112131415#include &lt;iostream&gt;#include &lt;typeinfo&gt;class Base &#123; virtual void dummy() &#123;&#125; &#125;;class Derived : public Base &#123; /* ... */ &#125;;int main() &#123; Base* base_ptr = new Derived; // Using typeid to get the type of the object std::cout &lt;&lt; &quot;Type: &quot; &lt;&lt; typeid(*base_ptr).name() &lt;&lt; &#x27;\\n&#x27;; delete base_ptr; return 0;&#125; dynamic_cast: 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;class Base &#123; virtual void dummy() &#123;&#125; &#125;;class Derived1 : public Base &#123; /* ... */ &#125;;class Derived2 : public Base &#123; /* ... */ &#125;;int main() &#123; Base* base_ptr = new Derived1; // Using dynamic_cast to safely downcast the pointer Derived1* derived1_ptr = dynamic_cast&lt;Derived1*&gt;(base_ptr); if (derived1_ptr) &#123; std::cout &lt;&lt; &quot;Downcast to Derived1 successful\\n&quot;; &#125; else &#123; std::cout &lt;&lt; &quot;Downcast to Derived1 failed\\n&quot;; &#125; Derived2* derived2_ptr = dynamic_cast&lt;Derived2*&gt;(base_ptr); if (derived2_ptr) &#123; std::cout &lt;&lt; &quot;Downcast to Derived2 successful\\n&quot;; &#125; else &#123; std::cout &lt;&lt; &quot;Downcast to Derived2 failed\\n&quot;; &#125; delete base_ptr; return 0;&#125; RTTI通常用于实现某些需要类型检查的功能，尤其是那些与继承体系交互的场景。但是，也应当注意它可能会导致一些性能开销，因此程序设计时还应考虑是否有其他方式能够达到相同目的，如使用虚函数来实现多态，而不是依赖RTTI来进行类型判断。在使用RTTI时，请确保编译器的相应设置或选项已经开启，因为某些编译器可能允许关闭RTTI来减少程序的体积和提高性能。在这种情况下，RTTI相关的功能将不可用。 type_info: 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;memory&gt;class Base&#123;public: virtual ~Base() &#123;&#125;&#125;;class Derived : public Base &#123;&#125;;int main() &#123; std::unique_ptr&lt;Base&gt; b(new Base()); std::unique_ptr&lt;Derived&gt; d(new Derived()); const std::type_info&amp; ti_b = typeid(*b); const std::type_info&amp; ti_d = typeid(*d); std::cout &lt;&lt; &quot;Base class type: &quot; &lt;&lt; ti_b.name() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Derived class type: &quot; &lt;&lt; ti_d.name() &lt;&lt; std::endl; if(ti_b == ti_d) &#123; std::cout &lt;&lt; &quot;The types are the same!&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;The types are different!&quot; &lt;&lt; std::endl; &#125; return 0;&#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"}]},{"title":"函数式编程","slug":"functional-programming","date":"2024-04-08T14:18:55.000Z","updated":"2024-11-08T02:21:34.891Z","comments":true,"path":"2024/04/08/functional-programming/","permalink":"http://example.com/2024/04/08/functional-programming/","excerpt":"","text":"介绍函数式编程是一种编程范式，它将计算视为数学函数的求值，并避免使用程序状态以及易变对象。其核心概念是使用函数来抽象作用在数据上的操作，而这些函数相互之间几乎没有或没有任何副作用。以下是一些函数式编程的关键特点： 不可变性：在函数式编程中，状态是不可变的。这意味着一旦创建，数据就不能改变。所有的变化都通过返回新的数据副本来完成，而不是直接修改现有数据。 纯函数：这些是没有副作用的函数。这意味着给定相同的输入，一个纯函数总是会产生相同的输出，并且在执行过程中不会对系统的其他部分产生影响（例如，不会修改全局变量或状态）。 高阶函数：函数在函数式编程中可以作为参数传递给其他函数，也可以作为结果返回。这允许创建抽象和组合函数。 函数组合：这是一种将两个或更多函数结合起来形成一个新函数的技术。组合的结果是一个包装了原来函数行为的新函数。 递归：由于不使用循环语句，函数式编程通常依赖于递归来执行重复或循环任务。 延迟计算（惰性求值）：这是一种技术，其中表达式不会立即计算，而是在需要结果之前延迟计算。 模式匹配：这常用于代数数据类型的解构和分析，允许直接根据数据的结构来处理数据。 在C++中，函数式编程风格可能不像在一些其他语言中那样自然和直观，因为C++本身是一种多范式编程语言，它同时支持面向对象和过程式编程。然而，C++11及其之后的标准引入了一些特性，可以支持更函数式的编程风格。例如，C++提供了标准库中的算法和函数对象，使得函数式编程风格的应用成为可能。 以下是一个使用C++标准库实现map和filter的例子 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iterator&gt;int main() { std::vector&lt;int&gt; nums = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; std::vector&lt;int&gt; evenNums, doubleNums; std::transform(nums.begin(), nums.end(), std::back_inserter(doubleNums), [](int x){ return x * 2; }); std::copy_if(nums.begin(), nums.end(), std::back_inserter(evenNums), [](int x){ return x % 2; }); std::cout &lt;&lt; \"The even numbers are: \"; for(auto&amp; x : evenNums) { std::cout &lt;&lt; x &lt;&lt; \" \"; } std::cout &lt;&lt; std::endl; std::cout &lt;&lt; \"The double numbers are: \"; for(auto&amp; x : doubleNums) { std::cout &lt;&lt; x &lt;&lt; \" \"; } return 0;} 在这个例子中，我们定义了一个数组numbers，使用std::transform 函数遍历它并创建一个新的数组doubledNumbers(其中包含 numbers 的每个元素乘以2的结果）。然后我们使用std::copy_if 函数过滤出偶数并创建了另一个数组 evenNumbers。 C++20标准加入了ranges库，对于支持这个标准的编译器，可以写出更接近函数式编程风格的代码。例如： 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iterator&gt;#include &lt;ranges&gt;int main() { std::vector&lt;int&gt; nums = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; auto doubles = nums | std::views::transform( []( int i ) { return i * 2; } ); auto evens = nums | std::views::filter( []( int i ) { return i % 2 == 0; } ); std::cout &lt;&lt; \"The even numbers are: \"; for ( auto x : evens ) { std::cout &lt;&lt; x &lt;&lt; \" \"; } std::cout &lt;&lt; std::endl; std::cout &lt;&lt; \"The double numbers are: \"; for ( auto x : doubles ) { std::cout &lt;&lt; x &lt;&lt; \" \"; } return 0;} 接下来演示一下如果通过并行和函数式编程提高运行效率 快速排序介绍快速排序是一种高效的排序算法，它使用分而治之的策略来对一系列元素进行排序。其核心思想是选择一个“基准”（pivot）元素，然后将数组分为两部分，使得左边部分的所有元素都不大于基准元素，而右边部分的所有元素都不小于基准元素，然后对这两部分递归地进行快速排序。以下是一个 C++ 实现的快速排序的示例代码： 123456789101112131415161718192021//c++ 版本的快速排序算法template&lt;typename T&gt;void quick_sort_recursive(T arr[], int start, int end) { if (start &gt;= end) return; T key = arr[start]; int left = start, right = end; while(left &lt; right) { while (arr[right] &gt;= key &amp;&amp; left &lt; right) right--; while (arr[left] &lt;= key &amp;&amp; left &lt; right) left++; std::swap(arr[left], arr[right]); } if (arr[left] &lt; key) { std::swap(arr[left], arr[start]); } quick_sort_recursive(arr, start, left - 1); quick_sort_recursive(arr, left + 1, end);}template&lt;typename T&gt;void quick_sort(T arr[], int len) { quick_sort_recursive(arr, 0, len - 1);} 排序演示 假设一开始序列是：5，3，7，6，4，1，0，2，9，10，8。 此时，ref=5，i=1，j=11，从后往前找，第一个比5小的数是x8=2，因此序列为：2，3，7，6，4，1，0，5，9，10，8。 此时i=1，j=8，从前往后找，第一个比5大的数是x3=7，因此序列为：2，3，5，6，4，1，0，7，9，10，8。 此时，i=3，j=8，从第8位往前找，第一个比5小的数是x7=0，因此：2，3，0，6，4，1，5，7，9，10，8。 此时，i=3，j=7，从第3位往后找，第一个比5大的数是x4=6，因此：2，3，0，5，4，1，6，7，9，10，8。 此时，i=4，j=7，从第7位往前找，第一个比5小的数是x6=1，因此：2，3，0，1，4，5，6，7，9，10，8。 此时，i=4，j=6，从第4位往后找，直到第6位才有比5大的数，这时，i=j=6，ref成为一条分界线，它之前的数都比它小，之后的数都比它大，对于前后两部分数，可以采用同样的方法来排序。 改进我们用函数式编程来修改上面的快速排序 改进分为了两种版本，如下： 迭代器版：123456789101112131415161718192021222324252627// @brief 快速排序// @param first 起始迭代器// @param last 结束迭代器template &lt;typename RandomAccessIterator&gt;void quick_sort(RandomAccessIterator first, RandomAccessIterator last) {// NOTE: 4. 终止条件：// 当递归到子数组长度为 0 或 1，即 first &gt;= last 时，排序函数返回，因为长度为 0 或 1 的数组自然是有序的，不需要进一步排序。 if (first &gt;= last) return;// NOTE: 1. 选择基准元素：// 函数首先选择一个基准（pivot）。在这个例子中，基准被选择为要排序部分的中间元素。 auto pivot = *std::next(first, std::distance(first, last) / 2);// NOTE: 2. 划分操作：// 使用两次 std::partition 函数，第一次将所有小于基准的元素移动到基准的左边，第二次将所有等于基准的元素移动到基准右边的起始位置。// 这样一来，基准元素的正确位置就被找到了，即所有在基准左边的元素都不大于基准，所有在基准右边的元素都不小于基准。 RandomAccessIterator middle1 = std::partition(first, last, [pivot](const auto&amp; em) { return em &lt; pivot; }); RandomAccessIterator middle2 = std::partition(middle1, last, [pivot](const auto&amp; em) { return !(pivot &lt; em); });// NOTE: 3. 递归排序：// 对基准左边和右边的子数组递归地调用 quick_sort 函数。左子数组包含所有小于基准的元素，右子数组包含所有大于基准的元素。 quick_sort(first, middle1); quick_sort(middle2, last);} 通过这个过程，数组被分为越来越小的部分，并且每个部分通过递归调用都被排序，最终得到整个数组的有序排列。 std::list版:12345678910111213141516171819202122232425262728293031323334353637383940//@brief 快速排序//@param input 待排序的listtemplate &lt;typename T&gt; std::list&lt;T&gt; sequential_quick_sort( std::list&lt;T&gt; input ) { if ( input.empty() ) { return input; } std::list&lt;T&gt; result; // NOTE: 1. // 将input中的第一个元素放入result中，并且将这第一个元素从input中删除 result.splice( result.begin(), input, input.begin() ); // NOTE: 2. 去result的第一个元素，将来用这个元素做切割，切割input中的列表 T const &amp;pivot = *result.begin(); // NOTE: 3. // std::partition是一个标准库函数，用于将容器或数组中的元素按照指定的条件进行分区 // 使得满足条件的元素排在不满足元素之前 // 所以经过计算divide_point指向的是input中第一个大于等于pivot的元素 auto divide_point = std::partition( input.begin(), input.end(), [&amp;]( T const &amp;t ) { return t &lt; pivot; } ); // NOTE: 4. 我们将小于pivot的元素放入lower_part中 std::list&lt;T&gt; lower_part; lower_part.splice( lower_part.end(), input, input.begin(), divide_point ); // NOTE: 5. 我们将lower_part传递给sequential_quick_sort返回一个新的有序的从小到大的序列 // lower_part中都是小于divide_point的值 auto new_lower( sequential_quick_sort( std::move( lower_part ) ) ); // NOTE: 6. 我们剩余的input列表传递给sequential_quick_sort递归调用，input中都是大于divide_point的值 auto new_higher( sequential_quick_sort( std::move( input ) ) ); // NOTE: 7. 到此时new_hither和new_lower都是从小到大排序好的列表 // NOTE: 8. 进行拼接 // 比divide_point的值小的部分从当前result的起始位置开始插入，大的部分从当前result的终止位置开始插入 result.splice( result.end(), new_higher ); result.splice( result.begin(), new_lower ); return result;} 补充知识: 关于list.splice() 1234567891011121314splice()函数是list中的一个剪贴函数，将另外一个list中的元素剪贴到本list中，共有三个重载list1为要操作的listlist2为被剪去的listposition为list1中的某个位置的迭代器list1调用splice()函数1. list1.splice(position , list2) 将list2中的所有元素剪贴到list1中的position位置2. list1.splice(position , list2 , iter) 将list2中某个位置的迭代器iter所指向的元素剪贴到list1中的position位置3. list1.splice(position , list2 , iter1 , iter2) 将list2中的某个范围迭代器iter1到iter2中的所有元素剪贴到list1中的从position开始的位置 调用如下 123456789void test_sequential_quick_sort() { std::list&lt;int&gt; nums = {6 , 1 , 0 , 7 , 5 , 2 , 9 , -1}; auto sort_result = sequential_quick_sort(nums); std::cout &lt;&lt; \"The result is: \"; for(auto&amp; item : sort_result) { std::cout &lt;&lt; \" \" &lt;&lt; item; } std::cout &lt;&lt; std::endl;} 这个函数是一个使用快速排序对链表进行排序的实现。快速排序是一种常用的排序算法，它的基本思想是选择一个基准元素，然后将数组分为两部分，一部分是小于基准元素的元素，另一部分是大于基准元素的元素。然后对这两部分再分别进行快速排序。这个函数使用了C++模板，可以处理任何数据类型的链表。函数的主要步骤包括： 将链表的第一个元素作为基准元素，并将其从链表中删除。 使用std::partition函数将链表分为两部分，一部分是小于基准元素的元素，另一部分是大于或等于基准元素的元素。 对这两部分分别进行递归排序。将排序后的两部分和基准元素合并，返回排序后的链表。 并行方式我们提供并行方式的函数式编程，可以极大的利用cpu多核的优势，这在并行计算中很常见。 迭代器版本： 123456789101112131415template &lt;typename RandomAccessIterator&gt;void Sort(RandomAccessIterator first, RandomAccessIterator last) { if (first &gt;= last) return; auto pivot = *std::next(first, std::distance(first, last) / 2); RandomAccessIterator middle1 = std::partition(first, last, [pivot](const auto&amp; em) { return em &lt; pivot; }); RandomAccessIterator middle2 = std::partition(middle1, last, [pivot](const auto&amp; em) { return !(pivot &lt; em); }); std::future&lt;void&gt; f1 = std::async(std::launch::async, &amp;Sort&lt;RandomAccessIterator&gt;, first, middle1); std::future&lt;void&gt; f2 = std::async( std::launch::async, &amp;Sort&lt;RandomAccessIterator&gt;, middle2, last ); f1.get(); f2.get();} std::list版本： 1234567891011121314151617181920212223242526template &lt;typename T&gt; std::list&lt;T&gt; parrallel_quick_sort( std::list&lt;T&gt; input ) { if(input.empty()) { return input; } std::list&lt;T&gt; result; result.splice(result.begin() , input , input.begin()); T const&amp; pivot = *result.begin(); auto divide_point = std::partition(input.begin() , input.end() , [&amp;](T const &amp;t){ return t &lt; pivot; }); std::list&lt;T&gt; lower_part; lower_part.splice(lower_part.end() , input , input.begin() , divide_point); std::future&lt;std::list&lt;T&gt;&gt; new_lower(std::async(&amp;parrallel_quick_sort&lt;T&gt; , std::move(lower_part))); // std::future&lt;std::list&lt;T&gt;&gt; new_higher(std::async(&amp;parrallel_quick_sort&lt;T&gt; , std::move(input))); // result.splice(result.end() , new_higher.get()); auto new_higher(parrallel_quick_sort(std::move(input))); result.splice(result.end() , new_higher); result.splice(result.begin() , new_lower.get()); return result;} 我们对lower_part的排序调用了std::async并行处理，而higher_part则是串行执行的。这么做提高了计算的并行能力，但有人会问，如果一个数组的大小是1024,那么就是2的10次方，则需要启动10个线程执行，这仅是对一个1024大小的数组排序，如果有多个数组排序，开辟线程会不会很多？其实不用担心这个，因为std::async的实现方式是通过std::launch::deffered或者std::launch::async完成的。编译器会计算当前能否开辟线程，如果能则是使用std::launch::async模式开辟线程，如果不能则采用std::launch::deffered串行执行。当然，也可以通过线程池来实现并行计算 12345678910111213141516171819202122232425template &lt;typename T&gt;std::list&lt;T&gt; thread_pool_quicK_sort( std::list&lt;T&gt; input ) { ThreadPool &amp;ins = ThreadPool::getInstance(); if ( input.empty() ) { return input; } std::list&lt;T&gt; result; result.splice( result.begin(), input, input.begin() ); T const &amp;pivot = *result.begin(); auto divide_point = std::partition( input.begin(), input.end(), [&amp;]( T const &amp;t ) { return t &lt; pivot; } ); std::list&lt;T&gt; lower_part; lower_part.splice( lower_part.end(), input, input.begin(), divide_point ); auto new_lower = ins.commit( &amp;parrallel_quick_sort&lt;T&gt;, std::move( lower_part ) ); auto new_higher( parrallel_quick_sort( std::move( input ) ) ); result.splice( result.end(), new_higher ); result.splice( result.begin(), new_lower.get() ); return result;}","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"},{"name":"并发编程","slug":"并发编程","permalink":"http://example.com/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"函数式编程","slug":"函数式编程","permalink":"http://example.com/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"}]},{"title":"并发编程-3","slug":"concurrency-programming-3","date":"2024-03-26T09:24:09.000Z","updated":"2024-11-08T02:21:34.891Z","comments":true,"path":"2024/03/26/concurrency-programming-3/","permalink":"http://example.com/2024/03/26/concurrency-programming-3/","excerpt":"","text":"利用条件变量实现线程安全队列 本文介绍如何使用条件变量控制并发的同步操作 条件变量试想有一个线程A一直输出1，另一个线程B一直输出2。我想让两个线程交替输出1，2，1，2…之类的效果，该如何实现？有的同学可能会说不是有互斥量mutex吗？可以用一个全局变量num表示应该哪个线程输出，比如num为1则线程A输出1，num为2则线程B输出2，mutex控制两个线程访问num，如果num和线程不匹配，就让该线程睡一会，这不就实现了吗？比如线程A加锁后发现当前num为2则表示它不能输出1，就解锁，将锁的使用权交给线程A，线程B就sleep一会。 12345678910111213141516171819202122232425262728293031323334int num = 1;std::mutex mtx;void PoorImplemention() &#123; std::thread t1( []() &#123; while ( true ) &#123; &#123; std::lock_guard&lt;std::mutex&gt; lock( mtx ); if ( num == 1 ) &#123; std::cout &lt;&lt; &quot;This thread A print &quot; &lt;&lt; num &lt;&lt; std::endl; ; num++; &#125; &#125; std::this_thread::sleep_for( std::chrono::seconds( 1 ) ); &#125; &#125; ); std::thread t2( []() &#123; while ( true ) &#123; &#123; std::lock_guard&lt;std::mutex&gt; lock( mtx ); if ( num == 2 ) &#123; std::cout &lt;&lt; &quot;This thread B print &quot; &lt;&lt; num &lt;&lt; std::endl; num--; &#125; &#125; std::this_thread::sleep_for( std::chrono::seconds( 1 ) ); &#125; &#125; ); t1.join(), t2.join();&#125; PoorImplement虽然能实现我们交替打印的功能，会造成消息处理的不及时处理，因为线程A要循环检测num值，如果num不为1,则线程A就睡眠了，在线程A睡眠这段时间里面很可能线程B已经处理完了，此时A还在睡眠，是对资源的浪费，也错过了最佳的处理时机。所以我们提出了用条件变量来通知线程的机制，当线程A发现条件不满足时可以挂起，等待线程B通知，线程B通知线程A后，A被唤醒继续处理 123456789101112131415161718192021222324252627282930313233int num = 1;std::mutex mtx;std::condition_variable cvA , cvB;void ReasonableImplemention() &#123; std::thread t1( []() &#123; while ( true ) &#123; std::unique_lock&lt;std::mutex&gt; lock(mtx); cvA.wait(lock , []()&#123; return num == 1; &#125;); num++; std::cout &lt;&lt; &quot;Thread A print 1....&quot; &lt;&lt; std::endl; cvB.notify_one(); &#125; &#125; ); std::thread t2( []() &#123; while ( true ) &#123; std::unique_lock&lt;std::mutex&gt; lock(mtx); cvB.wait(lock , []()&#123; return num == 2; &#125;); num--; std::cout &lt;&lt; &quot;Thread B print 2....&quot; &lt;&lt; std::endl; cvA.notify_one(); &#125; &#125; ); t1.join(), t2.join();&#125; 当条件不满足时(num !&#x3D; 1)cvA.wait就会挂起，等待线程B通知线程A唤醒，线程B采用cvA.notify_one。这么做的好处是线程交替处理十分及时，比起sleep的方式，我们可以从控制台看出差异效果，sleep的方式看出日志基本是每隔1秒才打印一次，效率不高 线程安全队列之前我们实现过线程安全的栈，对于pop操作，我们如果在线程中调用empty判断是否为空，如果不为空，则pop，因为empty和pop内部分别加锁，是两个原子操作，导致pop时可能会因为其他线程提前pop导致队列为空，从而引发崩溃。我们当时的处理方式是实现了两个版本的pop，一种是返回智能指针类型，一种通过参数为引用的方式返回。对于智能指针版本我们发现队列为空则返回空指针，对于引用版本，发现队列为空则抛出异常，这么做并不是很友好，所以我们可以通过条件变量完善之前的程序，不过这次我们重新实现一个线程安全队列。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#pragma once#include &lt;memory&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;#include &lt;queue&gt;template &lt;typename T&gt; class Queue_Thread_Safe &#123;private: std::queue&lt;T&gt; data_; std::mutex mtx_; std::condition_variable cvq_;public: Queue_Thread_Safe() = default; Queue_Thread_Safe( const Queue_Thread_Safe &amp; ); void push( T &amp;&amp; ); void wait_and_pop( T &amp;&amp; ); std::shared_ptr&lt;T&gt; wait_and_pop(); bool try_pop( T&amp; ); std::shared_ptr&lt;T&gt; try_pop(); bool empty();&#125;;template &lt;typename T&gt;Queue_Thread_Safe&lt;T&gt;::Queue_Thread_Safe( const Queue_Thread_Safe &amp;other ) &#123; std::lock_guard&lt;std::mutex&gt; lock( other.mtx_ ); this-&gt;data_ = other.data_;&#125;template &lt;typename T&gt; void Queue_Thread_Safe&lt;T&gt;::push( T &amp;&amp;param ) &#123; std::lock_guard&lt;std::mutex&gt; lock( mtx_ ); data_.emplace( param ); // NOTE: 这里通知线程是因为如果别的线程有pop操作，由于队列可能是空的会被挂起，所以要通知一个线程 cvq_.notify_one();&#125;template &lt;typename T&gt; void Queue_Thread_Safe&lt;T&gt;::wait_and_pop( T &amp;&amp;value ) &#123; std::unique_lock&lt;std::mutex&gt; lock( mtx_ ); cvq_.wait( lock, [this]() &#123; return !data_.empty(); &#125; ); value = data_.front(); data_.pop();&#125;template &lt;typename T&gt; std::shared_ptr&lt;T&gt; Queue_Thread_Safe&lt;T&gt;::wait_and_pop() &#123; std::unique_lock&lt;std::mutex&gt; lock( mtx_ ); cvq_.wait( lock, [this]() &#123; return !data_.empty(); &#125; ); std::shared_ptr&lt;T&gt; res( std::make_shared&lt;T&gt;( data_.front() ) ); data_.pop(); return res;&#125;template&lt;typename T&gt; bool Queue_Thread_Safe&lt;T&gt;::try_pop(T&amp; value) &#123; std::unique_lock&lt;std::mutex&gt; lock(mtx_); if(empty()) &#123; return false; &#125; value = data_.front(); return true;&#125;template&lt;typename T&gt;std::shared_ptr&lt;T&gt; Queue_Thread_Safe&lt;T&gt;::try_pop() &#123; std::unique_lock&lt;std::mutex&gt; lock(mtx_); cvq_.wait(lock, [this]()&#123; return !data_.empty(); &#125;); std::shared_ptr&lt;T&gt; res( std::make_shared&lt;T&gt;(data_.front()) ); data_.pop(); return res;&#125;template&lt;typename T&gt; bool Queue_Thread_Safe&lt;T&gt;::empty() &#123; // WARN:这里记得要加个锁，因为在判断队列是否为空的时候，要保证状态一致 std::unique_lock&lt;std::mutex&gt; lock(mtx_); return data_.empty();&#125;// 测试函数void test_thread_safe_queue() &#123; thread_safe_queue&lt;int&gt; safe_queue; std::mutex mtx_print; std::thread producer( [&amp;]() &#123; for ( int i = 0;; i++ ) &#123; safe_queue.push( std::forward&lt;decltype(i)&gt;(i) ); &#123; std::lock_guard&lt;std::mutex&gt; lock_print( mtx_print ); std::cout &lt;&lt; &quot;producer push data is &quot; &lt;&lt; i &lt;&lt; std::endl; &#125; std::this_thread::sleep_for( std::chrono::milliseconds( 200 ) ); &#125; &#125; ); std::thread consumer1( [&amp;]() &#123; while ( true ) &#123; auto data = safe_queue.wait_and_pop(); &#123; std::lock_guard&lt;std::mutex&gt; lock_print( mtx_print ); std::cout &lt;&lt; &quot;consumer1 wait and pop data is &quot; &lt;&lt; *data &lt;&lt; std::endl; &#125; std::this_thread::sleep_for( std::chrono::milliseconds( 500 ) ); &#125; &#125; ); std::thread consumer2( [&amp;]() &#123; while ( true ) &#123; auto data = safe_queue.try_pop(); if ( data != nullptr ) &#123; &#123; std::lock_guard&lt;std::mutex&gt; lock_print( mtx_print ); std::cout &lt;&lt; &quot;consumer2 try pop data is &quot; &lt;&lt; *data &lt;&lt; std::endl; &#125; &#125; std::this_thread::sleep_for( std::chrono::milliseconds( 500 ) ); &#125; &#125; ); producer.join(); consumer1.join(); consumer2.join();&#125; 输出如下: 123456789101112131415161718192021222324252627282930producer push data is 0consumer1 wait and pop data is 0producer push data is 1producer push data is 2consumer2 try pop data is 1consumer1 wait and pop data is 2producer push data is 3producer push data is 4consumer1 wait and pop data is 3consumer2 try pop data is 4producer push data is 5producer push data is 6producer push data is 7consumer2 try pop data is 5consumer1 wait and pop data is 6producer push data is 8producer push data is 9consumer2 try pop data is 7consumer1 wait and pop data is 8producer push data is 10producer push data is 11producer push data is 12consumer2 try pop data is 9consumer1 wait and pop data is 10producer push data is 13producer push data is 14consumer2 try pop data is 11consumer1 wait and pop data is 12producer push data is 15producer push data is 16 C++异步在C++中future, promise和async是C++标准库中的一些重要概念，它们可以用于实现异步编程。它们的具体用法可以参考官方文档 。 async用法std::async是用于异步执行函数的函数模板，它返回一个future对象，该对象用于获取函数的返回值 例子: 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;chrono&gt;#include &lt;future&gt;#include &lt;thread&gt;// 定义一个异步任务std::string FetchFromDB(const std::string&amp; query) &#123; //模拟一个异步任务，比如从数据库中获取数据 std::this_thread::sleep_for(std::chrono::milliseconds(200)); return &quot;Data: &quot; + query;&#125;void async_demo() &#123; // NOTE: 使用std::async异步调用FetchFromDB std::future&lt;std::string&gt; resultFromDB = std::async(std::launch::async , FetchFromDB , &quot;Data&quot;); // 主线程中做其他事情 std::cout &lt;&lt; &quot;Doing something else&quot; &lt;&lt; std::endl; // 从future对象中获取数据 std::string dbData = resultFromDB.get(); std::cout &lt;&lt; dbData &lt;&lt; std::endl;&#125;int main() &#123; async_demo(); return 0;&#125; 在这个事例中，std::async创建了一个新的线程(或从内部线程池中挑选了一个线程)并自动与一个std::promise对象相关联。std::promise对象被传递给FetchFromDB函数，函数返回值被存储在std::future对象中，在主线程中，我们可以使用std::future::get方法从std::future对象中获取数据。注意，在使用std::async的情况下，我们必须使用std::launch::async标志来明确表示我们希望函数异步执行。 输出如下： 12Doing something elseData: Data async的启动策略std::async函数可以接受几个不同的启动策略，这些策略在std::launch枚举中定义。除了std::launch::async之外，还有以下启动策略 std::launch::deferred:这种策略意味着任务将在调用std::future::get()或std::future::wait()函数时延迟执行。换句话说，任务将在需要结果时同步执行。 std::launch::async | std::launch::deferred: 这种策略是上面两个策略的组合。任务可以在一个单独的线程上异步执行，也可以延迟执行，具体取决于实现。 默认情况下，std::async使用std::launch::async|std::launch::deferred策略。这意味着任务可能异步执行，也可能延迟执行，具体取决于实现。需要注意的是，不同的编译器和操作系统可能会有不同的默认行为。 future的wait和getstd::future::get()和std::future::wait()是c++中用于处理异步人物的两个方法，它们的功能和用法有一些重要区别。 std::future::get() std::future::get()是一个阻塞调用，用于获取std::future对象表示的值或异常。如果异步任务还没有完成，get()会阻塞当前线程，直到任务完成。如果任务已经完成，get()会立即返回结果。重要的是，get()只能调用一次，因为它会移动或消耗掉std::future对象的状态。一旦get()被调用，std::future对象就不能再被用来获取结果。 std::future::wait() std::future::wait也是一个阻塞调用，但它与get()的主要区别在与wait()不会返回任务的结果。它只是等待异步任务完成。如果任务已经完成，wait()会立即返回。如果任务没有完成，wait()会阻塞当前线程，直到任务完成。与get()不同，wait()可以被多次调用，它不会消耗掉std::future对象的状态。 总结： std::future::get()用于获取并返回任务的结果，而std::future::wait()只是等待任务完成。 get()只能被调用一次，而wait()可以被多次调用。 如果任务还没有完成，get()和wait()都会阻塞当前线程，但get()会一直阻塞知道任务完成并返回结果，而wait()只是在等待任务完成。 你可以使用std::future的wait_for()或wait_until()方法来检查异步操作是否完成。这些方法返回一个表示操作状态的std::future_status的值 12345if(fut.wait_for(std::chrono::seconds(0)) == std::future_status::ready) &#123;// 操作完成&#125; else &#123;// 操作尚未完成&#125; 将任务和future关联std::packaged_task和std::future是C++11中引入的两个类，它们用于处理异步任务的结果。 std::packaged_task是一个可调用目标，它包装了一个任务，该任务可以在另一个线程上运行。它可以捕获任务的返回值或异常，并将其存储在std::future对象中，一边以后使用。 以下是使用std::packaged_task和std::future对象的基本步骤： 创建一个std::packaged_task对象，该对象包装了要执行的任务。 调用std::packaged_task对象的get_future()方法，该方法返回一个与任务关联的std::future对象 在另一个线程上调用std::packaged_task对象的operator()，用于执行任务 在需要任务结果的地方，调用与任务关联的std::future对象的get()方法，以获取任务的返回值或异常 例子: 123456789101112131415161718192021int mytask() &#123; std::this_thread::sleep_for(std::chrono::seconds(5)); std::cout &lt;&lt; &quot;my task run 5s&quot; &lt;&lt; std::endl; return 52;&#125;void use_package() &#123; // 创建了一个包装了任务的std::packaged_task对象 std::packaged_task&lt;int()&gt; task(mytask); // 获取与任务关联的std::future对象 std::future&lt;int&gt; result = task.get_future(); // 在另一个线程上执行任务 std::thread t(std::move(task)); // NOTE: std::packaged_task对象不能被复制，只能移动。因为std::packaged_task内部保存了一个对应的执行任务，这个任务应该被唯一执行，并且任务的结果也应该唯一保存，因此不允许复制，只能移动。 t.detach(); // 将线程与主线程分离，以便主线程可以等待任务完成 // 等待任务完成并获取结果 int value = result.get(); // get在获取结果之前会阻塞当前线程 std::cout &lt;&lt; &quot;The result is: &quot; &lt;&lt; value &lt;&lt; std::endl;&#125; 在上面的实例中，我们创建了一个包装了任务的std::packaged_task对象，并获取了与任务关联的std::future对象，然后，我们在另一个线程上执行任务，并等待任务完成并获取结果。最后，我们输出结果。 我们可以使用std::function和std::packaged_task来包装带参数的函数。std::packaged_task是一个模板类，他包装了一个可调用对象，并允许我们将其作为异步任务传递。 promise的用法C++11引入了std::promise和std::future两个类，用于实现异步编程。std::promise用于在某一线程中设置某个值或异常，而std::future则用于在另一线程中获取这个值或异常。 例子： 12345678910111213141516void set_value(std::promise&lt;int&gt; prom) &#123; prom.set_value(10); std::cout &lt;&lt; &quot;promise set value successfully by the thread\\n&quot;;&#125;void promise_demo() &#123; std::promise&lt;int&gt; prom; std::future&lt;int&gt; fut = prom.get_future(); std::thread t1(set_value , std::move(prom)); std::cout &lt;&lt; &quot;Waiting for the thread to set value ...\\n&quot;; std::cout &lt;&lt; &quot;Value set by the thread: &quot; &lt;&lt; fut.get() &lt;&lt; &quot;\\n&quot;; t1.join();&#125; 输出: 123Waiting for the thread to set value ...Value set by the thread: promise set value successfully by the thread10 在上面的代码中，我们首先创建了一个std::promise&lt;int&gt;对象，然后通过调用get_future()方法获取与之相关联的std::future&lt;int&gt;对象。然后，我们在新线程中通过调用set_value()方法设置promise的值，并在主线程中通过调用fut.get()方法获取这个值。注意，在调用fut.get()方法时，如果promise的值还没有被设置，则该方法会阻塞当前线程，直到值被设置为止。 除了set_value方法外，std::promise还有一个set_exception()方法，用于设置异常。该方法接受一个std::exception_ptr参数，该参数可以通过调用std::current_exception()方法获取。 例子如下： 1234567891011121314151617181920212223242526272829void set_exception(std::promise&lt;void&gt; prom) &#123; try &#123; // 抛出一个异常 throw std::runtime_error(&quot;An error occurred\\n&quot;); &#125; catch(...) &#123; // NOTE: ... 表示捕获任意类型的异常 // 设置promise的异常 prom.set_exception(std::current_exception()); &#125;&#125;void promise_exception_demo() &#123; std::promise&lt;void&gt; prom; // 获取与promise相关联的对象 std::future&lt;void&gt; fut = prom.get_future(); // 创建一个线程 std::thread t1(set_exception , std::move(prom)); // 在主线程获取future的异常 try&#123; std::cout &lt;&lt; &quot;Waiting for the thread to set exception....\\n&quot;; fut.get(); &#125; catch(const std::exception&amp; e) &#123; std::cout &lt;&lt; &quot;Exception set by the thread: &quot; &lt;&lt; e.what() &lt;&lt; &quot;\\n&quot;; &#125; t1.join();&#125; 输出如下 12Waiting for the thread to set exception....Exception set by the thread: An error occurred 当然我们在使用std::promise时要注意一点，如果std::promise被释放了，而其他线程还未使用与std::promise关联的future,当其使用这个std::future时会报错。 例子： 123456789101112131415void use_promise_destruct() &#123; std::thread t; std::future&lt;int&gt; fut; &#123; std::promise&lt;int&gt; prom; fut = prom.get_future(); t = std::thread(set_value , std::move(prom)); &#125; std::cout &lt;&lt; &quot;Waiting for the thread to set value ...\\n&quot;; std::cout &lt;&lt; &quot;Value set by the thread: &quot; &lt;&lt; fut.get() &lt;&lt; &quot;\\n&quot;; t.join();&#125; 随着局部&#125;的结束，prom可能被释放也可能会被延迟释放，如果立即释放则fut.get()获取的值会报error_value的错误 共享型的future当我们需要多个线程等待同一个执行结果时，需要使用std::shared_future 以下是一个适合使用std::shared_future的场景，多个线程等待一个异步操作的结果 假设你有一个异步任务，需要多个线程等待其完成，然后这些线程需要访问任务的结果。在这种情况下，你可以使用std::shared_future来共享异步结果 1234567891011121314151617181920212223242526272829void myFunction(std::promise&lt;int&gt;&amp;&amp; prom) &#123; // 模拟一些工作 std::this_thread::sleep_for(std::chrono::seconds(1)); prom.set_value(42);&#125;void threadFunction(std::shared_future&lt;int&gt; fut) &#123; try&#123; int result = fut.get(); std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; result &lt;&lt; &quot;\\n&quot;; &#125; catch(const std::future_error&amp; e) &#123; std::cout &lt;&lt; &quot;Future error: &quot; &lt;&lt; e.what() &lt;&lt; std::endl; &#125;&#125;void shared_future_demo() &#123; std::promise&lt;int&gt; prom; std::shared_future&lt;int&gt; shared_fut = prom.get_future(); // NOTE: 第一个线程先去执行任务，后面两个线程等待std::shared_future的值 std::thread myThread1(myFunction , std::move(prom)); std::thread myThread2(threadFunction, shared_fut); std::thread myThread3(threadFunction , shared_fut); myThread1.join() , myThread2.join() , myThread3.join();&#125; 我们创建了一个std::promise&lt;int&gt;对象prom和一个与之关联的std::shared_future&lt;int&gt;对象shared_fut。然后我们将promise对象移动到另一个线程myThread1中，该线程将执行myFunction函数，并在完成后设置prom的值，那么shared_fut.get()将返回该值。这些线程可以同时访问和等待future对象的结果，而不会相互干扰 注意，如果一个future被移动给两个shared_future是错误的 12345678910111213141516171819void threadFunction(std::shared_future&lt;int&gt; fut) &#123; try&#123; int result = fut.get(); std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; result &lt;&lt; &quot;\\n&quot;; &#125; catch(const std::future_error&amp; e) &#123; std::cout &lt;&lt; &quot;Future error: &quot; &lt;&lt; e.what() &lt;&lt; std::endl; &#125;&#125;void shared_future_demo() &#123; std::promise&lt;int&gt; prom; std::shared_future&lt;int&gt; shared_fut = prom.get_future(); std::thread myThread1(myFunction , std::move(prom)); std::thread myThread2(threadFunction, std::move(shared_fut)); std::thread myThread3(threadFunction , std::move(shared_fut)); myThread1.join() , myThread2.join() , myThread3.join();&#125; 这种用法是错误的，一个future通过隐式构造传递给shared_future之后，这个shared_future被移动传递给两个线程是不合理的，因为第一次移动之后shared_future的生命周期被转移了，接下俩myThread3构造时用的std::move(future)future已经失效了，会报错，一般都是no state之类的错误。 异常处理std::future是一个模板类，它用于表示一个可能还没有准备好的异步操作的结果。你可以通过调用std::future::get()方法来获取这个结果。如果在获取结果是发生了异常，那么std::future::get()会重新抛出这个异常 例子： 123456789101112void may_throw() &#123; throw std::runtime_error(&quot;Oops, something went wrong!&quot;);&#125;void get_future_error() &#123; // 创建一个异步任务 std::future&lt;void&gt; result(std::async(std::launch::async , may_throw)); try &#123; result.get(); &#125; catch(const std::exception&amp; e) &#123; std::cerr &lt;&lt; &quot;Caught exception: &quot; &lt;&lt; e.what() &lt;&lt; std::endl; &#125;&#125; 在这个例子中，我们创建了一个异步任务may_throw，这个任务会抛出一个异常。然后，我们创建一个std::future对象result来表示这个任务的结果。在get_future_error函数中，我们调用result.get()来获取任务的结果。如果在获取结果时发生了异常，那么result.get()会重新抛出这个异常，然后我们在catch块中捕获了并打印这个异常。 输出： 1Caught exception: Oops, something went wrong! 线程池我们可以利用上面提到的std::packaged_task和std::promise构建线程池，提高程序的并发能力 线程池的知识: 线程池是一种多线程处理形式，它处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。如果某个线程在托管代码中空闲（如正在等待某个事件）,则线程池将插入另一个辅助线程来使所有处理器保持繁忙。如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后创建另一个辅助线程但线程的数目永远不会超过最大值。超过最大值的线程可以排队，但他们要等到其他线程完成后才启动。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#pragma once#include &lt;iostream&gt;#include &lt;future&gt;#include &lt;atomic&gt;#include &lt;thread&gt;#include &lt;condition_variable&gt;#include &lt;vector&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;functional&gt;template &lt;typename T&gt; class TD;class ThreadPool &#123;public: ThreadPool( const ThreadPool &amp; ) = delete; ThreadPool &amp;operator=( const ThreadPool &amp; ) = delete; static ThreadPool &amp;getInstance() &#123; static ThreadPool ins; return ins; &#125; using Task = std::packaged_task&lt;void()&gt;; ~ThreadPool() &#123; stop(); &#125; // NOTE: 用于将任务队列中的任务提交到pool_里面 template &lt;typename F, class... Args&gt; auto commit( F &amp;&amp;func, Args &amp;&amp;...args ) -&gt; std::future&lt;decltype( func( args... ) )&gt; &#123; using RetType = decltype( func( args... ) ); if ( stop_.load() ) &#123; // NOTE: 这里如果触发异常处理，可以通过异常处理来了解状态 return std::future&lt;RetType&gt;&#123;&#125;; &#125; // NOTE:关于这里为什么要使用std::shared_ptr // 1. // 避免对象过早的销毁，我们通常需要在另一个线程中执行task,可能会在创建的作用域之外。 // 2. // 允许对象的共享，比如说，你可以在一个线程中安排一个任务，并在另一个线程中等待该任务完成并获取其结果。 // 这样的话，任务对象就需要在多个线程中共享，而 // std::shared_ptr 正好可以满足这个要求。 auto task = std::make_shared&lt;std::packaged_task&lt;RetType()&gt;&gt;( std::bind( std::forward&lt;F&gt;( func ), std::forward&lt;Args&gt;( args )... ) ); std::future&lt;RetType&gt; ret = task-&gt;get_future(); &#123; std::lock_guard&lt;std::mutex&gt; cv_mt( cv_mt_ ); tasks_.emplace( [task] &#123; ( *task )(); &#125; ); &#125; cv_lock_.notify_one(); return ret; &#125; int idleThreadCount() &#123; return thread_num_; &#125;private: ThreadPool( unsigned int num = 5 ) : stop_( false ) &#123; if ( num &lt; 1 ) &#123; thread_num_ = 1; &#125; else &#123; thread_num_ = num; &#125; start(); &#125; void start() &#123; for ( int i = 0; i &lt; thread_num_; i++ ) &#123; pool_.emplace_back( [this]() &#123; while ( !this-&gt;stop_.load() ) &#123; Task task; std::unique_lock&lt;std::mutex&gt; cv_mt( cv_mt_ ); this-&gt;cv_lock_.wait( cv_mt, [this]() &#123; // NOTE: 当stop_为true,或者任务队列不空时，线程都会醒来。 return this-&gt;stop_.load() || !this-&gt;tasks_.empty(); &#125; ); if ( this-&gt;tasks_.empty() ) &#123; return; &#125; task = std::move( this-&gt;tasks_.front() ); this-&gt;tasks_.pop(); // 拿到一个任务，空闲线程-1 this-&gt;thread_num_--; task(); // NOTE: 拿到一个新任务，进行异步调用，执行任务。 // 任务执行完之后，空闲线程又回来了，空闲线程+1 this-&gt;thread_num_++; &#125; &#125; ); &#125; &#125; void stop() &#123; stop_.store( true ); cv_lock_.notify_all(); for ( auto &amp;td : pool_ ) &#123; if ( td.joinable() ) &#123; std::cout &lt;&lt; &quot;join thread &quot; &lt;&lt; td.get_id() &lt;&lt; std::endl; td.join(); &#125; &#125; &#125;private: std::mutex cv_mt_; std::condition_variable cv_lock_; std::atomic_bool stop_; std::atomic_int thread_num_; std::queue&lt;Task&gt; tasks_; std::vector&lt;std::thread&gt; pool_;&#125;; 注意： 线程池做的任务是并发的、无序的，无法保证有序性 如果执行的任务是强关联或者互斥性很大，建议使用单线程，线程池的意义不大 源码链接","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"},{"name":"并发编程","slug":"并发编程","permalink":"http://example.com/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"OpenWrt TCP UDP 网络性能优化","slug":"network-optimization","date":"2024-03-24T14:34:34.000Z","updated":"2024-11-08T02:21:34.892Z","comments":true,"path":"2024/03/24/network-optimization/","permalink":"http://example.com/2024/03/24/network-optimization/","excerpt":"","text":"写这篇文章的原因是今天在打2042的时候丢包严重，一开始以为是Dice的服务器又爆了，后面跟同学对比了之后发现完全是路由器的问题。刚好拨号和主路由用的是R2S，可以学习一下linux内核的一些跟TCP, UDP有关的参数修改 下面的参数可以在/etc/sysctl.conf这个文件中修改 另外再多说一句，Turbo acc这个插件对这种500M一下的带宽基本没什么作用 最大队列大小优化在通过TCP\\UDP层处理数据之前，系统会将数据放入内核队列中。net.core.netdev_max_backlog值指定在传递到上层之前要放入队列的最大数据包数。对于高负载的网络，默认值是不够的.因此，我们可以适当地增加该值可以解决内核导致的性能损失。默认值为1000，将其增加到3000以上足以阻止数据包在10Gbps网络中被丢弃 12345# 默认值$ sysctl net.core.netdev_max_backlogsysctl net.core.netdev_max_backlog = 1000net.core.netdev_max_backlog = 4096 还有一个类似的设置是net.ipv4.tcp_max_syn_backlog，这个指定的是记住的连接请求的最大数量，但仍未受到来自客户端的确认。对于内存超过128MB的系统，默认值为1024，对于低内存计算机，默认值为128。如果服务器过载，可以尝试增加该值 12345# 默认值$ sysctl net.ipv4.tcp_max_syn_backlognet.ipv4.tcp_max_syn_backlog = 128net.ipv4.tcp_max_syn_backlog = 4096 最大挂起连接数优化应用程序可以在处理一个连接之前指定要放入队列的最大待处理请求数，当此值达到最大值时，进一步的连接开始退出。对于发布大量连接的Web服务器等应用程序，此值必须很高才能使这些连接正常工作 12345# 默认值$ sysctl net.core.somaxconnnet.core.somaxconn = 128net.core.somaxconn = 4096 TCP FIN超时优化在TCP连接中，双方必须独立关闭连接。在Linux下，发送FIN数据包以关闭连接并等待FINACK知道定义超时值。这玩意的默认值是60，可以减少到20或者30使TCP关闭连接并释放资源以进行另一个连接 1234$ sysctl net.ipv4.tcp_fin_timeoutsysctl net.ipv4.tcp_fin_timeout = 60net.ipv4.tcp_fin_timeout = 30 重用TIME_WAIT状态的套接字进行新连接在处理必须处理TIME_WAIT状态下的许多短TCP连接的Web服务器时，或许会有用 1234$ sysctl net.ipv4.tcp_tw_reusenet.ipv4.tcp_tw_reuse = 0net.ipv4.tcp_tw_reuse = 1 tcp_keepalive_time优化TCP连接是由两个socket组成，每个socket在连接的两端。当一方想要终止连接时，它会发送另一方确认的RST数据包并关闭其socket 然而，在此之前，双方将无期限地sochi其socket开放。这使得一方可能有意或者由于某些错误而关闭其插座，而无需通过RST通知另一端。为了检测此场景并关闭过时连接，可以使用TCP Keep Alive处理 Linux中有三个可配置属性来确定Keep-Alives的属性: tcp_keepalive_time 默认是7200 tcp_keepalive_probes 默认是9 tcp_keepalive_intvl 默认是75 具体过程如下: 客户端打开TCP连接 如果tcp_keepalive_time秒的连接是静默的，则发送一个空的ACK数据包 服务器是否使用自己的相应的ACK进行响应 没有 等待tcp_keepalive_intvl秒，然后发送另一个ACK 重复，直到已发送的ACk探测数等于tcp_keepalive_probes 如果此时未收到响应，请发送RST并终止连接 有 返回第二步 默认情况下，在大多数操作系统上启动了此过程的处理，因此一旦另一端无响应2小时11分钟( 7200s + 75 * 9 ), 则会定期移除死TCP连接 1234$ sysctl net.ipv4.tcp_keepalive_timenet.ipv4.tcp_keepalive_time = 7200net.ipv4.tcp_keepalive_time = 1200 启用智能MTU黑同检测优化一旦启用，系统将尝试使用路径MTU发现机制在客户端和服务器之间找到MTU，可以通过ip a检查接口上的MTU: 1234567$ ip a | grep &#x27;mtu&#x27;1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 10002: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 10003: ip6tnl0@NONE: &lt;NOARP&gt; mtu 1452 qdisc noop state DOWN group default qlen 10004: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel master br-lan state UP group default qlen 10005: br-lan: &lt;BROADCAST,MULTICAST,PROMISC,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 10006: pppoe-wan: &lt;POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP&gt; mtu 1492 qdisc fq_codel state UNKNOWN group default qlen 3 关于MTU 要在Linux上启用此功能，运行下面的命令： 123456$ sysctl net.ipv4.tcp_mtu_probingnet.ipv4.tcp_mtu_probing = 0$ sysctl net.ipv4.tcp_base_mssnet.ipv4.tcp_base_mss = 1024net.ipv4.tcp_mtu_probing = 1 tcp_mtu_probing，控制TCP分组化-层路径MTU发现，有三个可选值： 0 已禁用 1 默认情况下禁用，在检测到ICMP黑洞时起用 2 始终启用，使用tcp_base_mss的初始MSS 内核缓冲区优化系统默认的socket缓冲区大小: 12345678$ sysctl net.core.wmem_defaultnet.core.wmem_default = 212992$ sysctl net.core.rmem_defaultnet.core.rmem_default = 212992$ sysctl net.core.rmem_maxsysctl net.core.rmem_max = 212992$ sysctl net.core.wmem_maxnet.core.wmem_max = 212992 这些参数显示分配给任何类型连接的默认和最大写入、读取缓冲区大小。 由于分配的空间来自RAM，因此默认值设置总是有点低。增加这一点可能会提高运行NFS等服务器的系统的性能。 将它们增加到256k &#x2F; 4MB将最有效，否则您必须对这些值进行基准测试，以找到系统配置的理想值 123456789101112# 256 KB / 4 MBnet.core.rmem_default = 262144net.core.wmem_default = 262144net.core.rmem_max = 4194304net.core.wmem_max = 4194304# Or 256 Kb / 64 MBnet.core.rmem_default = 262144net.core.wmem_default = 262144net.core.rmem_max = 67108864net.core.wmem_max = 67108864 TCP缓冲区大小优化确认一下默认值: 1234$ sysctl net.ipv4.tcp_rmemnet.ipv4.tcp_rmem = 4096 131072 6291456$ sysctl net.ipv4.tcp_wmemnet.ipv4.tcp_wmem = 4096 16384 4194304 这些值是三个整数的数组，分别指定TCP读取和发送缓冲区的最小，平均和最大值 [!WARNING] 值要以页为单位。如果需要查看页面大小，可以使用getconf PAGE_SIZE来查看 TCP缓冲区最大值修改： 123456789101112# 64MBnet.ipv4.tcp_rmem = 4096 87380 67108864net.ipv4.tcp_wmem = 4096 16384 67108864# 12MB:net.ipv4.tcp_rmem = 4096 87380 12582912net.ipv4.tcp_wmem = 4096 16384 12582912# 4MB:net.ipv4.tcp_rmem = 4096 87380 4194304net.ipv4.tcp_wmem = 4096 16384 4194304 Time Wait优化TIME WAIT TCP套接字状态是套接字关闭但等待处理仍在网络中的数据包的状态。 参数tcp_max_tw_buckets是 TIME_WAIT 状态下的最大套接字数。 达到此数字后，系统将开始在此状态下销毁套接字 此限制仅用于防止简单的DoS攻击，您不得人为地降低限制，而是增加它（可能在增加安装的内存之后），如果网络条件需要超过默认值 12345$ sysctl net.ipv4.tcp_max_tw_bucketsnet.ipv4.tcp_max_tw_buckets = 4096$ sudo vi /etc/sysctl.d/98-network-custom.confnet.ipv4.tcp_max_tw_buckets = 5000 如果遇到大量的TCP 错误，如： 12__ratelimit: 33491 callbacks suppressedTCP: time wait bucket table overflow 可以增加net.ipv4.tcp_max_tw_buckets的值，比如 654320，前提是拥有足够的内存 请尝试以下命令来确定您是否有来自一个地址的大量连接，或者您是否受到分布式攻击 netstat -nt | cut -c 40- | cut -d: -f1 | sort | uniq -c | sort -n netstat -nt | cut -d: -f2 | sort | uniq -c | sort -n 如果您从几个IP地址获得高数字，则更容易限制连接。 然后，您可以向 iptables 添加拒绝规则或速率限制规则，以限制从这些地址访问 经测试，优化此项可能造成上传文件至某些网站超时或错误 开启TCP时间戳关于tcp_timestamps Linux 系统中的 tcp_timestamps 参数控制是否启用 TCP 时间戳。要启用该功能可以用下面的命令： 1net.ipv4.tcp_timestamps=1 通常，出于性能考虑，默认情况下，在现代操作系统上该参数会启用，除非有特定安全上的考虑需要关闭它。在某些情况下，为了提高安全性，可能会选择关闭时间戳功能，因为时间戳可以被恶意用户用来估算服务上次重启的时间，或者进行更精细的网络流量分析。 TCP Sacktcp_sack 表示 TCP Selective Acknowledgment (选择性确认)，这是一个 TCP&#x2F;IP 的性能优化特性。在 TCP 通信中，数据是按顺序发送的，如果包丢失了，底层 TCP 协议需要进行重传。传统的 TCP 重传机制是累积确认的，也就是说，只有当所有的包按顺序全部接收时，接收端才会发送一个 ACK (确认)。选择性确认允许接收方告诉发送方哪些数据包已经成功接收，即使它们不是按顺序到达的。这样，如果一些数据包丢失，发送方可以只重传那些未被确认接收的数据包，而不用从丢失的数据包或者先前已经被确认接收的部分开始重传整个数据流。这可以大大提高网络通信的效率，尤其是在丢包率较高或者网络延迟较大的环境下。 要启用该功能: 1net.ipv4.tcp.sack = 1 TCP窗口大小tcp_window_scaling 是 TCP 协议提供的一个特性，用于支持较大的窗口大小，从而使得在高延迟和高带宽的网络上可以有更好的性能。在TCP中，窗口大小决定了不需要等待确认应答就可以发送的数据的最大值。这个值也就是说，在任一时刻，可以无确认地发送在网络上未确认的数据的最大量。正常情况下，TCP 窗口的大小由一个 16 位的字段控制，这限制了最大的窗口大小为 65,535 字节（64 KB）。随着网络的发展，这个大小变得不足以利用高速网络的潜力。通过启用窗口缩放选项，TCP 可以使用最多 14 位的移位计数来扩大这个值，从而扩大可能的窗口大小，最大可达 1GB。 要启用该功能: 1net.ipv4.tcp_window_scaling = 1 禁用 tcp_window_scaling 会限制 TCP 窗口的最大值为 64 KB，这可能会降低网络性能，尤其是在高速宽带连接上。因此，在不需要兼容老旧网络设备或特定网络配置的情况下，建议保持该选项为启用状态，以便能够充分利用网络带宽。","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"软路由","slug":"软路由","permalink":"http://example.com/tags/%E8%BD%AF%E8%B7%AF%E7%94%B1/"}]},{"title":"并发编程-2","slug":"concurrency-programming-2","date":"2024-03-23T14:49:37.000Z","updated":"2024-11-08T02:21:34.890Z","comments":true,"path":"2024/03/23/concurrency-programming-2/","permalink":"http://example.com/2024/03/23/concurrency-programming-2/","excerpt":"","text":"互斥体与锁mutex开发并发系统的目的主要是为了提升性能：将任务分散到多个线程，然后在不同的处理器上同时执行。这些分散开来的线程通常会包含两类任务： 独立的对于划分给自己的数据进行处理 对于结果的汇总 其中第一项任务由于每个线程都是独立的，不存在竞争条件的问题。而第二个任务，由于所有的线程都可能往总结果汇总，这就需要做保护了。在某一个具体的时刻，只应当有一个线程更新结果，即：保证每个线程对于共享数据的访问是”互斥的”，mutex就提供了这样的功能。 方法 说明 lock 加锁，如果不可用，则阻塞 try_lock 尝试加锁，如果mutex不可以用直接返回(bool) unlock 解开互斥锁 这三个方法提供了基础的锁定和解除锁定的功能。使用lock意味着你有很强的意愿一定要获取到互斥体，而使用try_lock则是进行一次尝试。这意味着如果失败了，你通常还有其他的路径可以走。 在这些基础功能之上，其他的类分别在下面三个方面进行了扩展 超时： timed_mutex, recursive_timed_mutex, shared_timed_mutex的名称都带有timed,这意味着它们都支持超时的功能。它们都提供了try_lock_for和try_lock_until方法，这两个方法分别可以制定超时的时间长度和时间点。如果在超时的时间范围内没有能获取到锁，则直接返回，不再继续等待。 可重入：rescursive_mutex和recursive_timed_mutex的名称都带有rescursive。可重入或者叫做可递归，是指在同一个线程中，同一把锁可以锁定多次。这就避免了一些不必要的死锁。 共享：shared_timed_mutex和shared_mutex提供了共享功能。对于这类互斥体，实际上是提供了两把锁：一把是共享锁、一把是互斥锁。一旦某个线程获取了互斥锁，任何其他线程都无法再获取互斥锁和共享锁;但是如果有某个线程获取到了共享锁，其他线程无法再获取到互斥锁，但是还有获取到共享锁。这里互斥锁的使用和其他互斥体接口功能一样。而共享锁可以被同时多个线程获取到。共享锁通常用在读者写者模型 上 使用共享锁的接口如下： 方法 说明 lock_shared 获取互斥体的共享锁，如果无法获取则阻塞 try_lock_shared 尝试获取共享锁，如果不可用，直接返回 unlock_shared 解锁共享锁 接下里对之前的代码进行改造 12345678910111213141516171819202122232425262728293031323334// 初始化一个互斥锁，开全局static std::mutex lock1;void concurrent_func(int min , int max) &#123; double tmp_sum = 0; for(int i = min ; i &lt;= max; i++) &#123; tmp_sum += sqrt(i); &#125; lock1.lock(); sum += tmp_sum; lock1.unlock();&#125;void concurrent_task(int min , int max) &#123; auto start_time = std::chrono::steady_clock::now(); // 得到线程数量 unsigned int concurrent_count = std::thread::hardware_concurrency(); std::cout &lt;&lt; &quot;hardware_concurrency: &quot; &lt;&lt; concurrent_count &lt;&lt; &quot;\\n&quot;; std::vector&lt;std::thread&gt; threads; min = 0; sum = 0; for(int t = 0; t &lt; concurrent_count; t++) &#123; int range = max / concurrent_count * (t + 1); threads.push_back(std::thread(concurrent_func , min , range)); min = range + 1; &#125; for(auto &amp;i : threads) &#123; i.join(); &#125; auto end_time = std::chrono::steady_clock::now(); auto ms = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end_time - start_time).count(); std::cout &lt;&lt; &quot;Task finish, &quot; &lt;&lt; ms &lt;&lt; &quot; ms consumed , Result: &quot; &lt;&lt; sum &lt;&lt; &quot;\\n&quot;;&#125; 这里有两个地方需要关注： 在访问共享数据之前加锁 在访问完之后解锁 输出如下： 12hardware_concurrency: 20Task finish, 201 ms consumed , Result: 2.10819e+13 通过多线程实现并行求容器和 123456789101112131415161718192021222324252627282930313233343536373839404142434445template&lt;typename Iterator , typename T&gt;void get_sum(Iterator fst , Iterator lst , T&amp; res) &#123; static std::mutex g1; auto tmp_res = std::accumulate(fst , lst , T&#123;&#125;); std::lock_guard&lt;std::mutex&gt; g(g1); res += tmp_res;&#125;template &lt;typename Iterator, typename T&gt;T parallel_accumulate( Iterator fst, Iterator lst, T init ) &#123; auto res = init; unsigned long const min_thread = 2; unsigned long const hardware_threads = std::thread::hardware_concurrency(); unsigned long const length = std::distance(fst , lst); unsigned long const max_thread = (length + min_thread - 1) / min_thread; unsigned long const num_threads = std::min(hardware_threads ? hardware_threads : min_thread , max_thread ); unsigned long const dis = length / num_threads; std::vector&lt;std::thread&gt; threads(num_threads); Iterator st = fst; for(auto&amp; th : threads) &#123; Iterator ed = st; std::advance(ed , dis); th = std::thread(get_sum&lt;Iterator , T&gt; , st , ed , std::ref(res)); th.join(); st = ed; &#125; return res;&#125;void use_parallel_acc() &#123; std::vector&lt;int&gt; vec; for ( int i = 0; i &lt; 100000; i++ ) &#123; vec.push_back( i ); &#125; int sum = 0; sum = parallel_accumulate&lt;std::vector&lt;int&gt;::iterator, int&gt;( vec.begin(), vec.end(), sum ); std::cout &lt;&lt; &quot;sum is &quot; &lt;&lt; sum &lt;&lt; &quot;\\n&quot;;&#125; 我们通常用锁的粒度来描述锁的范围。细粒度是指锁保护较小的范围，粗粒度是指保护较大的范围。出于性能的考虑，我们应该保证锁的粒度尽可能的细。并且，不应该在获取锁的范围内执行耗时的操作，例如执行IO。如果是耗时的运算也应该尽可能的移动到锁的外边。 锁的使用 mutex 我们可以通过mutex对共享数据进行加锁，防止多线程访问共享区造成数据不一致问题。如下，我们初始化一个共享变量shared_data,然后定义了一个互斥量std::mutex，接下来启动了两个线程，分别执行use_lock增加数据，和一个lambda表达式减少数据。结果可以看到两个线程对于共享数据的访问是独占的，单位时间片只有一个线程访问并输出日志 12345678910111213141516171819202122232425262728std::mutex mtx1;int shared_data = 100;void use_lock() &#123; while(true) &#123; mtx1.lock(); shared_data++; std::cout &lt;&lt; &quot;current thread is &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot;\\n&quot;; std::cout &lt;&lt; &quot;shared_data is &quot; &lt;&lt; shared_data &lt;&lt; &quot;\\n&quot;; mtx1.unlock(); std::this_thread::sleep_for(std::chrono::microseconds(10)); &#125;&#125;void test_lock() &#123; std::thread t1(use_lock); std::thread t2([]()&#123; mtx1.lock(); shared_data--; std::cout &lt;&lt; &quot;current thread is &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot;\\n&quot;; std::cout &lt;&lt; &quot;shared_data is &quot; &lt;&lt; shared_data &lt;&lt; &quot;\\n&quot;; mtx1.unlock(); std::this_thread::sleep_for(std::chrono::microseconds(10)); &#125;); t1.join(); t2.join();&#125; lock_guard lock_guard可以自动加锁和解锁 123456789void use_lock() &#123; while(true) &#123; std::lock_guard&lt;std::mutex&gt; g(mtx1); shared_data++; std::cout &lt;&lt; &quot;current thread is &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot;\\n&quot;; std::cout &lt;&lt; &quot;shared_data is &quot; &lt;&lt; shared_data &lt;&lt; &quot;\\n&quot;; std::this_thread::sleep_for(std::chrono::microseconds(10)); &#125;&#125; lock_guard在作用域结束时自动调用其析构函数解锁，这么做的一个好处是简化了一些特殊情况从函数返回的写法，比如异常或者条件不满足时，函数内部直接return,锁也会自动解开。 如何保证数据安全 有时候我们可以对共享数据的访问和修改聚合到一个函数，在函数内部加锁保证数据的安全性。但是对于读取类型的操作，即使读取函数是线程安全的，但是返回值抛给外边使用，存在不安全性。比如一个栈对象，我们要保证其在多线程访问的时候是安全的，可以在判断栈是否为空，判断操作内部我们可以加锁，但是判断结束后返回值就不加锁了，就会存在线程安全问题 比如定义了如下栈，对于多线程的访问时判断栈是否为空，此后两个线程同时出栈，可能会造成崩溃 1234567891011121314151617181920212223242526272829template&lt;typename T&gt;class threadsafe_stack1 &#123;private: std::stack&lt;T&gt; data; mutable std::mutex m;public: threadsafe_stack1() &#123;&#125; threadsafe_stack1(const threadsafe_stack1&amp; other) &#123; std::lock_guard&lt;std::mutex&gt; Lock(m); data = other.data; &#125; threadsafe_stack1&amp; operator=(const threadsafe_stack1&amp; other) = delete; void push(T new_value) &#123; std::lock_guard&lt;std::mutex&gt; Lock(m); data.push(std::move(new_value)); &#125; // 问题代码 T pop() &#123; std::lock_guard&lt;std::mutex&gt; Lock(m); auto element = data.top(); data.pop(); return element; &#125; bool empty() const &#123; return data.empty(); &#125;&#125;; 如下，线程1和线程2先后判断都不为空，之后执行出栈，会造成崩溃 1234567891011121314151617void test_threadsafe_stack1() &#123; threadsafe_stack1&lt;int&gt; safe_stack; safe_stack.push(1); std::thread t1([&amp;safe_stack]()&#123; std::this_thread::sleep_for(std::chrono::seconds(1)); safe_stack.pop(); &#125;); std::thread t2([&amp;safe_stack]()&#123; if(!safe_stack.empty()) &#123; std::this_thread::sleep_for(std::chrono::seconds(1)); safe_stack.pop(); &#125; &#125;); t1.join(); t2.join();&#125; 解决这个问题我们可以用抛出异常函数，例如定义一个空栈的异常 123struct empty_stack : std::exception &#123; const char *what() const throw();&#125;; 然后修改出栈函数 123456789T pop() &#123; std::lock_guard&lt;std::mutex&gt; Lock(m); if(data.empty()) &#123; throw empty_stack(); &#125; auto element = data.top(); data.pop(); return element;&#125; 这么做就需要在外层使用的时候捕获异常。这是C++ 并发编程中提及的建议。但是现在这个pop函数仍存在问题，比如T是一个vector&lt;int&gt;类型时，那么在pop函数内部element就是vector&lt;int&gt;类型，开始element存储了一些int值，程序没问题，函数执行了pop操作，假设此时程序内存暴增，导致当前程序使用的内存足够大时，可用的有效空间不够，函数返回element时，就会存在vector做拷贝赋值时造成失败。即使我们捕获异常，释放部分空间但也会导致栈元素已经出栈，数据丢失了。这其实是内存管理不当造成的，但书中给了优化方案 1234567891011121314151617181920212223242526272829303132333435363738394041template&lt;typename T&gt;class threadsafe_stack1 &#123;private: std::stack&lt;T&gt; data; mutable std::mutex m;public: threadsafe_stack1() &#123;&#125; threadsafe_stack1(const threadsafe_stack1&amp; other) &#123; std::lock_guard&lt;std::mutex&gt; Lock(m); data = other.data; &#125; threadsafe_stack1&amp; operator=(const threadsafe_stack1&amp; other) = delete; void push(T new_value) &#123; std::lock_guard&lt;std::mutex&gt; Lock(m); data.push(std::move(new_value)); &#125; std::shared_ptr&lt;T&gt; pop() &#123; std::lock_guard&lt;std::mutex&gt; Lock(m); // NOTE:1.试图弹出前检查栈是否为空 if(data.empty()) return nullptr; // NOTE:2.改动栈容器前设置返回值 std::shared_ptr&lt;T&gt; const res(std::make_shared&lt;T&gt;(data.top())); data.pop(); return res; &#125; void pop(T&amp; value) &#123; std::lock_guard&lt;std::mutex&gt; Lock(m); if(data.empty()) &#123; throw empty_stack(); &#125; value = data.top(); data.pop(); &#125; bool empty() const &#123; return data.empty(); &#125;&#125;; 我们提供了两个版本的pop操作，一个是带引用类型参数的，一个是直接pop出智能指针类型，这样在pop函数内部减少了数据的拷贝，防止内存溢出，其实这两种做法确实是相比之前直接pop固定类修能够的值更节省内存，运行效率也好很多。我们也完全可以基于之前的思想，在pop时如果栈为空返回空指针，这样比抛出异常好些 死锁死锁是如何造成的死锁一般是调用顺序不一致而导致的。例如两个线程循环调用。当线程1先加锁A,在加锁B,而线程而先加锁B,在加锁A。那么在某一时刻就可能造成一种情况，线程1先加锁了A,线程2先加锁了B,那么他们都希望彼此占有对方的锁，又不释放自己占有的锁 12345678910111213141516171819202122232425262728293031323334std::mutex lock1 , lock2;int m_1 = 0 , m_2 = 1;void dead_lock1() &#123; while(true) &#123; std::cout &lt;&lt; &quot;DeadLock1 Begin\\n&quot;; lock1.lock(); m_1 = 1024; lock2.lock(); m_2 = 2048; lock2.unlock(); lock1.unlock(); std::this_thread::sleep_for(std::chrono::milliseconds(5)); std::cout &lt;&lt; &quot;DeadLock1 End\\n&quot;; &#125;&#125;void dead_lock2() &#123; while(true) &#123; std::cout &lt;&lt; &quot;DeadLock2 Begin\\n&quot;; lock2.lock(); m_2 = 2222; lock1.lock(); m_1 = 1111; lock1.unlock(); lock2.unlock(); std::this_thread::sleep_for(std::chrono::milliseconds(5)); std::cout &lt;&lt; &quot;DeadLock2 End\\n&quot;; &#125;&#125;void call_dead_lock() &#123; std::thread t1(dead_lock1) , t2(dead_lock2); t1.join() , t2.join();&#125; 这样运行之后在某一个时刻一定会导致死锁。实际工作中避免死锁的一个方式就是将加锁和解锁的功能封装为独立函数，这样能保证独立的函数里执行完操作之后就解锁，不会导致一个函数里面使用多个锁的情况。 123456789101112131415161718192021222324252627282930313233343536void atomic_lock1() &#123; std::cout &lt;&lt; &quot;AtomicLock1 Begin\\n&quot;; lock1.lock(); m_1 = 1024; lock1.unlock(); std::cout &lt;&lt; &quot;AtomicLock1 End\\n&quot;;&#125;void atomic_lock2() &#123; std::cout &lt;&lt; &quot;AtomicLock2 Begin\\n&quot;; lock2.lock(); m_2 = 2048; lock2.unlock(); std::cout &lt;&lt; &quot;AtomicLock2 End\\n&quot;;&#125;void safe_lock1() &#123; while(true) &#123; atomic_lock1(); atomic_lock2(); std::this_thread::sleep_for(std::chrono::milliseconds(5)); &#125;&#125;void safe_lock2() &#123; while(true) &#123; atomic_lock2(); atomic_lock1(); std::this_thread::sleep_for(std::chrono::milliseconds(5)); &#125;&#125;void call_safe_lock() &#123; std::thread t1(safe_lock1) , t2(safe_lock2); t1.join() , t2.join();&#125; 同时加锁当我们无法避免在一个函数内部使用两个互斥量，并且都要解锁的情况下，闹我们可以采取同时加锁的方式，我们先定义一个类，假设这个类不推荐拷贝构造，但我们也提供了这个类的拷贝构造和移动构造。 12345678910111213141516171819202122232425262728class some_big_object &#123;public: some_big_object() = default; some_big_object(int item) : _data(item) &#123;&#125; some_big_object(const some_big_object&amp; other) : _data(other._data) &#123;&#125; some_big_object(some_big_object&amp;&amp; other) : _data(std::move(other._data)) &#123;&#125; some_big_object&amp; operator=(const some_big_object&amp; other) &#123; if(_data == other._data) &#123; return *this; &#125; _data = other._data; return *this; &#125; friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os , const some_big_object&amp; soj) &#123; os &lt;&lt; soj._data; return os; &#125; friend void swap(some_big_object&amp; o1 , some_big_object&amp; o2) &#123; some_big_object temp = std::move(o1); o1 = std::move(o2); o2 = std::move(temp); &#125;private: int _data;&#125;; 接下来再定义一个类对上面的类进行管理，为防止多线程情况下数据混乱，包含了一个互斥量。 1234567891011121314class big_obj_manager &#123;public: big_obj_manager(int data = 0) : sbo(data) &#123;&#125; void printinfo() &#123; std::cout &lt;&lt; &quot;The current data is: &quot; &lt;&lt; sbo &lt;&lt; &quot;\\n&quot;; &#125; friend void danger_swap(big_obj_manager&amp; bo1 , big_obj_manager&amp; bo2); friend void safe_swap(big_obj_manager&amp; bo1 , big_obj_manager&amp; bo2); friend void safe_swap_scope(big_obj_manager&amp; bo1 , big_obj_manager&amp; bo2);private: some_big_object sbo; std::mutex mtx;&#125;; 为了演示哪些交换是安全的，哪些交换是危险的，所以写了三个函数 123456789101112void danger_swap(big_obj_manager&amp; bo1 , big_obj_manager&amp; bo2) &#123; std::cout &lt;&lt; &quot;thread[&quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot;] begin \\n&quot;; if(&amp;bo1 == &amp;bo2) &#123; return; &#125; std::lock_guard&lt;std::mutex&gt; g1(bo1.mtx); std::this_thread::sleep_for(std::chrono::seconds(1)); std::lock_guard&lt;std::mutex&gt; g2(bo2.mtx); swap(bo1.sbo , bo2.sbo); std::cout &lt;&lt; &quot;thread[&quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot;] end \\n&quot;;&#125; danger_swap是危险的交换方式，例如如下调用 12345678910void test_lock() &#123; big_obj_manager o1(1) , o2(2); std::thread t1(danger_swap , std::ref(o1) , std::ref(o2)) , t2(danger_swap , std::ref(o1) , std::ref(o2)); t1.join(); t2.join(); o1.printinfo(); o2.printinfo();&#125; 这种调用方式存在隐患，因为danger_swap函数在两个线程中使用会造成竞争互相加锁的情况。那就需要用锁同时锁住两个锁。 12345678910111213141516171819202122232425void safe_swap(big_obj_manager&amp; bo1 , big_obj_manager&amp; bo2) &#123; std::cout &lt;&lt; &quot;thread[&quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot;] begin \\n&quot;; if(&amp;bo1 == &amp;bo2) &#123; return; &#125; // NOTE: 同时锁住两个以上的锁（最少两个） std::lock(bo1.mtx , bo2.mtx); std::lock_guard&lt;std::mutex&gt; g1(bo1.mtx , std::adopt_lock); std::this_thread::sleep_for(std::chrono::seconds(1)); std::lock_guard&lt;std::mutex&gt; g2(bo2.mtx , std::adopt_lock); swap(bo1.sbo , bo2.sbo); std::cout &lt;&lt; &quot;thread[&quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot;] end \\n&quot;;&#125;void test_lock() &#123; big_obj_manager o1(1) , o2(2); std::thread t1(safe_swap , std::ref(o1) , std::ref(o2)) , t2(danger_swap , std::ref(o1) , std::ref(o2)); t1.join(); t2.join(); o1.printinfo(); o2.printinfo();&#125; 上面的加锁方式可以简化，C++17scoped_lock可以对多个互斥两同时加锁，同时释放 123456789101112void safe_swap_scope(big_obj_manager&amp; bo1 , big_obj_manager&amp; bo2) &#123; std::cout &lt;&lt; &quot;thread[&quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot;] begin \\n&quot;; if(&amp;bo1 == &amp;bo2) &#123; return; &#125; std::scoped_lock guard(bo1.mtx , bo2.mtx); // 等价于 // std::scoped_lock&lt;std::mutex , std::mutex&gt; guard(bo1.mtx , bo2.mtx); swap(bo1.sbo , bo2.sbo); std::cout &lt;&lt; &quot;thread[&quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot;] end \\n&quot;;&#125; 层级锁现实开发中常常很难规避同一个函数内部多个加锁的情况，我们要尽可能避免循环加锁，所以可以自定义一个层级锁，保证实际项目中对多个互斥量加锁时是有序的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;thread&gt;#include &lt;climits&gt;#include &lt;mutex&gt;#include &lt;thread&gt;#include &lt;exception&gt;#include &lt;stdexcept&gt;class hierarchial_mutex&#123;public: explicit hierarchial_mutex(unsigned long value) : _hierarchy_value(value) , _previous_hierarchy_value(0) &#123;&#125; hierarchial_mutex(const hierarchial_mutex&amp;) = delete; hierarchial_mutex&amp; operator=(const hierarchial_mutex&amp;) = delete; // @brief: 加锁函数，先检查是否违反当前层级值，如果没有，可以加锁并且更新线程的层级值 void lock() &#123; check_for_hierarchy_violation(); _internal_mutex.lock(); update_hierarchy_value(); &#125; // @brief: 解锁函数, 如果线程的层级值和当前层级值不一致，就抛出异常，否则先更新线程的层级为上一层的层级值，再解锁 void unlock() &#123; if(_this_thread_hierarchy_value != _hierarchy_value) &#123; throw std::logic_error(&quot;mutex hierarchy violated&quot;); &#125; _this_thread_hierarchy_value = _previous_hierarchy_value; _internal_mutex.unlock(); &#125; // @brief: 尝试加锁函数，先检查是否违反当前层级值，再检查锁是否可以加，最后在更新线程的层级值 bool trylock() &#123; check_for_hierarchy_violation(); if(!_internal_mutex.try_lock()) &#123; return false; &#125; update_hierarchy_value(); return true; &#125;private: std::mutex _internal_mutex; // NOTE: 当前层级值 unsigned long const _hierarchy_value; // NOTE: 上一次层级值 unsigned long _previous_hierarchy_value; // NOTE: 本线程记录的层级值 static thread_local unsigned long _this_thread_hierarchy_value; // NOTE: thread_local 关键字修饰的变量具有线程周期，这些变量在线程开始时被生成，在线程结束时被销毁，并且每一个线程都拥有一个独立的变量实例 // @brief: 检查当前线程是否违反当前层级 void check_for_hierarchy_violation() &#123; if(_this_thread_hierarchy_value &lt;= _hierarchy_value) &#123; throw std::logic_error(&quot;mutex hierarchy violated&quot;); &#125; &#125; // @brief: 更新线程的层级值 void update_hierarchy_value() &#123; _previous_hierarchy_value = _this_thread_hierarchy_value; _this_thread_hierarchy_value = _hierarchy_value; &#125;&#125;;// 初始化静态成员变量thread_local unsigned long hierarchial_mutex::_this_thread_hierarchy_value = ULONG_MAX; 层级锁能保证我们每个线程加锁时，一定是先加权重最高的锁(不然会抛出异常)，并且释放时也保证了顺序。主要原理就是将当前锁的权重保存在变量中，这样该线程再次加锁时判断线程变量的权重和锁的权重是否大于，如果满足条件就继续加锁。 C++ unique_lock,共享锁和递归锁 介绍了 unique_lock、shared_lock、recursive_lock，其中shared_lock和unique_lock比较常用，而recursive_lock用得不多，尽可能规避使用这个锁 unique_lockunique_lock和lock_guard用法基本一致，构造时默认加锁，析构时默认解锁，但unique_lock有个好处就是可以手动解锁，这一点尤为重要，方便我们控制锁区域的粒度，也能支持和条件变量配套使用。 12345678910// unique_lock的基本用法std::mutex mtx;int shared_data = 0;void use_unique() &#123; std::unique_lock&lt;std::mutex&gt; lock(mtx); std::cout &lt;&lt; &quot;Lock success \\n&quot;; shared_data++; lock.unlock();&#125; 我们可以通过unique_lock的owns_lock判断是否持有锁 12345678910111213141516void owns_lock() &#123; std::unique_lock&lt;std::mutex&gt; lock(mtx); shared_data++; if(lock.owns_lock()) &#123; std::cout &lt;&lt; &quot;owns_lock\\n&quot;; &#125; else &#123; std::cout &lt;&lt; &quot;doesn&#x27;t own lock\\n&quot;; &#125; lock.unlock(); if(lock.owns_lock()) &#123; std::cout &lt;&lt; &quot;owns_lock\\n&quot;; &#125; else &#123; std::cout &lt;&lt; &quot;doesn&#x27;t own lock\\n&quot;; &#125;&#125; unqiue_lock可以延时加锁 12345678void defer_lock() &#123; // 延迟加锁 std::unique_lock&lt;std::mutex&gt; lock(mtx , std::defer_lock); // 可以加锁 lock.lock(); // 可以自动析构解锁，也可以手动解锁 lock.unlock();&#125; 综合运用owns_lock和defer_lock 1234567891011121314151617181920212223242526272829void use_own_defer() &#123; std::unique_lock&lt;std::mutex&gt; lock( mtx ); if ( lock.owns_lock() ) &#123; std::cout &lt;&lt; &quot;Main thread has the lock\\n&quot;; &#125; else &#123; std::cout &lt;&lt; &quot;Main thread doesn&#x27;t have the lock&quot;; &#125; std::thread t1( []() &#123; std::unique_lock&lt;std::mutex&gt; lock( mtx ); if ( lock.owns_lock() ) &#123; std::cout &lt;&lt; &quot;The thread has the lock\\n&quot;; &#125; else &#123; std::cout &lt;&lt; &quot;The thread doesn&#x27;t have the lock&quot;; &#125; lock.lock(); if ( lock.owns_lock() ) &#123; std::cout &lt;&lt; &quot;The thread has the lock\\n&quot;; &#125; else &#123; std::cout &lt;&lt; &quot;The thread doesn&#x27;t have the lock&quot;; &#125; lock.unlock(); &#125; ); t1.join();&#125; 上述代码会一次输出，但是程序会阻塞，因为子线程会卡在加锁的逻辑上，因为主线程为释放锁，而主线程又等待子线程推出，导致整个程序卡住 和lock_guard一样，unique_lock也支持领养锁 123456789void use_own_adopt() &#123; mtx.lock(); std::unique_lock&lt;std::mutex&gt; lock(mtx , std::adopt_lock); if ( lock.owns_lock() ) &#123; std::cout &lt;&lt; &quot;owns_lock\\n&quot;; &#125; else &#123; std::cout &lt;&lt; &quot;doesn&#x27;t own lock\\n&quot;; &#125;&#125; 经管是领养的，但是打印还是会出现owns_lock,因为不管如何锁被加上，就会输出owns_lock既然unique_lock支持领养操作也支持延迟加锁，那么可以用两种方式实现lock_guard实现的swap操作 123456789101112131415161718192021int a = 10 , b = 99;std::mutex mtx1 , mtx2;void safe_swap() &#123; std::lock(mtx1 , mtx2); std::unique_lock&lt;std::mutex&gt; lock1(mtx1 , std::adopt_lock) , lock2(mtx2 , std::adopt_lock); std::swap(a , b); // FIX: 错误用法 // lock1.unlock(); // lock2.unlock();&#125;void safe_swap2() &#123; std::unique_lock&lt;std::mutex&gt; lock1(mtx1 , std::defer_lock) , lock2(mtx2 , std::defer_lock); // lock1 , lock2加锁 std::lock(lock1 , lock2); // FIX: 错误用法 // std::lock(mtx1 , mtx2);&#125; 注意， 一旦mutex被unique_lock管理，加锁和释放操作就交给unique_lock，不能调用mutex加锁和解锁，因为锁的使用权已经交给了unique_lock 我们知道mutex是不支持拷贝和构造的，但是unique_lock支持移动，当一个mutex被转移给unique_lock后，可以通过unique_ptr转移其归属权 12345678910111213141516std::mutex mtx1 , mtx2 , mtx;int shared_data = 0;// 转移互斥量所有权// 互斥量本身不支持move操作，但是unique_lock支持std::unique_lock&lt;std::mutex&gt; get_lock() &#123; std::unique_lock&lt;std::mutex&gt; lock(mtx); shared_data++; return lock;&#125;void use_return() &#123; std::unique_lock&lt;std::mutex&gt; lock(get_lock()); shared_data++;&#125; 锁的粒度表示加锁的精细程度，一个锁的粒度要足够大，保证可以锁住要访问的共享数据。同时一个锁的粒度要足够小，保证非共享数据不被锁住影响性能，而unique_ptr则很好支持手动解锁 123456789void precision_lock() &#123; std::unique_lock&lt;std::mutex&gt; lock(mtx); shared_data++; lock.unlock(); // NOTE:不涉及共享数据的耗时操作不要放在锁内执行 std::this_thread::sleep_for(std::chrono::seconds(1)); lock.lock(); shared_data++;&#125; 共享锁试想这样一个场景，对于一个DNS服务，我们可以根据域名查询服务对应的ip地址，它很久才更新一次，比如新增记录，删除记录或者更新记录等。平时大部分时间都是提供给外部查询，对于查询操作，即使多个线程并发查询不加锁也不会有问题，但是当有线程修改DNS服务的ip记录或者增减记录时，其他线程不能查询，需等待修改完再查询。或者等待查询完，线程才能修改。也就是说读操作并不是互斥的，同一时间可以有多个线程同时读，但是写和读是互斥的，写与写是互斥的，简而言之，写操作需要独占锁。而读操作需要共享锁。 要想使用共享锁，需要使用互斥量std::shared_mutex , std::shared_mutex是C++17标准提出的， C++14标准可以使用std::shared_timed_mutex std::shared_mutex和std::shared_timed_mutex都是用于实现多线程并发访问共享数据的互斥锁，但它们之间存在一些区别 std::shared_mutex 123451.* 提供了lock()和try_lock_for()以及`try_lock_until`函数，这些函数都可以用于获取互斥锁。2.* 提供了try_lock_shared()和lock_shared()函数，这些函数可以用于获取共享锁3.* 当std::shared_mutex被锁定之后，其他尝试获取该锁的线程将会被阻塞，直到该锁被解锁。 std::shared_timed_mutex 1231.* 与std::shared_mutex类似，也提供了lock() , try_lock_for() , try_lock_until() 函数用于获取互斥锁。2.* 与std::shared_mutex不同的是，它还提供了try_lock_shared()和lock_shared()函数用于获取共享锁，这些函数在尝试获取共享锁时具有超时机制。3.* 当std::shared_timed_mutex被锁定之后，其他尝试获取该锁的线程将会被阻塞，直到该锁被解锁，这与std::shared_mutex相同。然而，当尝试获取共享锁时，如果不能立即获得锁，std::shared_timed_mutex会设置一个超时，超时过后如果仍然没有获取到锁，则操作将返回失败 C++11标准没有共享互斥量，可以使用boost提供的boost::shared_mutex 如果我们想构造共享锁，可以使用std::shared_lock，如果我们想构造独占锁，可以使用std::lock_guard 我们可以用一个类DNService表示DNS服务，查询操作使用共享锁，写操作使用独占锁 123456789101112131415161718192021222324class DNService &#123;public: DNService() = default; //读操作使用共享锁 std::string QueryDNS(const std::string&amp; dnsname) &#123; std::shared_lock&lt;std::shared_mutex&gt; shared_locks(_shared_mutex); auto iter = _dns_info.find(dnsname); if(iter != _dns_info.end()) &#123; return iter-&gt;second; &#125; return &quot;&quot;; &#125; //写操作使用独占锁 void AddDNSInfo(const std::string&amp; dnsname , const std::string&amp; dnsentry) &#123; std::lock_guard&lt;std::shared_mutex&gt; guard_locks(_shared_mutex); _dns_info.insert(std::make_pair(dnsname , dnsentry)); &#125;private: std::map&lt;std::string , std::string&gt; _dns_info; mutable std::shared_mutex _shared_mutex;&#125;; QueryDNS用来查询dns信息，多个线程可以同时访问AddDNSInfo用来写入dns信息，属于独占锁，同一时刻只有一个线程在修改 递归锁有时候我们在实现接口的时候内部加锁，接口内部调用结束自动解锁。会出现一个接口调用另一个接口的情况。如果用普通的std::mutex就会出现卡死，因为嵌套加锁导致卡死，我们可以使用递归锁。 但可以从设计源头规避嵌套加锁的情况，我们可以将接口相同的功能抽象出来，统一加锁。 1234567891011121314151617181920212223242526272829303132333435363738class RecursiveDemo&#123;public: RecursiveDemo() = default; bool QueryStudent(const std::string &amp;name) &#123; std::lock_guard&lt;std::recursive_mutex&gt; recursive_lock(_recursive_mutex); auto iter = _student_info.find(name); if(iter == _student_info.end()) &#123; return false; &#125; return true; &#125; void AddScore(const std::string &amp;name , const int score) &#123; std::lock_guard&lt;std::recursive_mutex&gt; recursive_lock(_recursive_mutex); if(!QueryStudent(name)) &#123; _student_info[name] = score; &#125; else &#123; _student_info[name] = _student_info[name] + score; &#125; &#125; // NOTE: 不推荐采用递归锁，使用递归锁说明设计思路并不理想，需要优化设计 // NOTE: 推荐拆分逻辑，将共有逻辑拆分为同一接口 void AddScoreAtomic(const std::string&amp; name , const int score) &#123; std::lock_guard&lt;std::recursive_mutex&gt; recursive_lock(_recursive_mutex); auto iter = _student_info.find(name); if(iter == _student_info.end()) &#123; _student_info.insert(std::make_pair(name , score)); &#125; else &#123; _student_info[name] = _student_info[name] + score; &#125; &#125;private: std::map&lt;std::string , int&gt; _student_info; std::recursive_mutex _recursive_mutex; // NOTE: recursive_mutex可以在同一个线程被锁多次&#125;; 我们可以看到AddScore函数内部调用了QueryStudent，所以采用了递归锁，但是我们同样可以改变设计，将两者共有的部分抽离出来生成一个新的接口AddScoreAtomic， AddScoreAtomic可以不适用于递归锁，照样能完成线程安全的操作。","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"},{"name":"并发编程","slug":"并发编程","permalink":"http://example.com/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"并发编程-1","slug":"concurrency-programming-1","date":"2024-03-23T14:43:23.000Z","updated":"2024-11-08T02:21:34.890Z","comments":true,"path":"2024/03/23/concurrency-programming-1/","permalink":"http://example.com/2024/03/23/concurrency-programming-1/","excerpt":"","text":"线程基础线程的创建12345678910111213141516#include &lt;iostream&gt;#include &lt;thread&gt;void func() &#123; std::cout &lt;&lt; &quot;hello world\\n&quot;;&#125;int main() &#123; std::thread t1(func); t1.join(); return 0;&#125; 如果函数需要传参 12345678910111213141516#include &lt;iostream&gt;#include &lt;thread&gt;void func(std::string name) &#123; std::cout &lt;&lt; name &lt;&lt; &quot;\\n&quot;;&#125;int main() &#123; std::thread t1(func , &quot;127.0.0.1&quot;); t1.join(); return 0;&#125; 仿函数作为参数 123456class Background_task &#123;public: void operator[](const std::string&amp; str) &#123; std::cout &lt;&lt; str &lt;&lt; &quot;\\n&quot;; &#125;;&#125;; 注意： 如果采用如下的方式调用函数，编译器一定会报错 12std::thread t1(Background_task());t1.join(); 因为编译器会将t1当作一个函数对象，返回一个std::thread类型的值，函数的参数为一个函数指针，该函数指针返回值为Back_ground_task，参数为void 1std::thread (*)(Background_task (*)()); 修改的方式如下 1234std::thread t1((background_task()));t1.join();std::thread t2&#123;background_task()&#125;;t2.join(); lambda表达式作为参数 12345std::thread t1([](const std::string&amp; str)&#123; std::cout &lt;&lt; str &lt;&lt; &quot;\\n&quot;;&#125; , &quot;hello world\\n&quot;);t1.join(); 注意在线程中参数是以拷贝的形式进行传递，因此对于拷贝耗时的对象可以选择用引用或者指针进行传递。但是需要考虑对象的生命周期。因为线程的运行长度可能会超过参数的生命周期，这个时候如果线程还在访问一个已经被销毁的对象就会出现问题 detach 和 join 主要API 一旦启动线程之后，我们必须决定是要等待到这个线程结束(join)，或者直接和主线程独立开来(detach)，我们必须二者选其一。如果std::thread对象销毁时我们还没有触发任何操作，则std::thread对象在析构函数将调用std::terminate()从而导致进程异常退出 join: 调用这个API时，当前线程就会停滞，直到目标线程执行完毕。 detach: 这个API是让目标线程成为守护线程。一旦detach之后，目标线程将独立运行，即便其对应的std::thread对象销毁也不影响线程的执行。并且无法与之通信。 对于这两个接口，都必须是可执行的线程才有意义。可以通过joinable()接口查询是否可以对它们进行join或者detach 管理线程 yield: 通常在自己的主要任务已经完成时，希望让出处理器给其他任务使用 get_id: 返回当前线程的id，可以用来标识不同的线程 sleep_for: 可以让当前线程停滞一段时间 sleep_until: 和sleep_for类似，但是以具体时间点为参数，这两个API都是以chronoapi为基础 123456789101112131415161718192021222324252627282930313233343536#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;sstream&gt;void print_time() &#123; auto now = std::chrono::system_clock::now(); auto in_time_t = std::chrono::system_clock::to_time_t(now); std::stringstream ssin; ssin &lt;&lt; std::put_time(std::localtime(&amp;in_time_t) , &quot;%Y-%m-%d %X&quot;); std::cout &lt;&lt; &quot;now is: &quot; &lt;&lt; ssin.str() &lt;&lt; &quot;\\n&quot;;&#125;void sleep_thread() &#123; std::this_thread::sleep_for(std::chrono::seconds(3)); std::cout &lt;&lt; &quot;[thread-&quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot;] is waking up\\n&quot;;&#125;void loop_thread() &#123; for(int i = 0; i &lt; 10; i++) &#123; std::cout &lt;&lt; &quot;[thread-&quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot;] print: &quot; &lt;&lt; i &lt;&lt; &quot;\\n&quot;; &#125;&#125;int main() &#123; print_time(); std::thread t1(sleep_thread) , t2(loop_thread); t1.join(); t2.detach(); print_time(); return 0;&#125; 线程的归属权 每个线程都有其归属权，也就是说归属给每个变量管理 1234567void func() &#123;&#125;std::thread t1(func); t1是一个线程变量，管理一个线程，该线程执行func()对于std::threadC++不允许拷贝构造和拷贝赋值，所以只能通过移动和局部变量返回的方式将线程变量管理权转移给其他变量管理。 例如下面的例子 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;chrono&gt;namespace &#123;void func1() &#123; while(true) &#123; std::this_thread::sleep_for(std::chrono::seconds(1)); &#125;&#125;void func2() &#123; while(true) &#123; std::this_thread::sleep_for(std::chrono::seconds(1)); &#125;&#125;&#125;; // namespaceint main() &#123; //1. t1绑定函数func1() std::thread t1(func1); //2. 转移t1的管理的线程给t2，转移后t1无效 std::thread t2 = std::move(t1); //3. t1绑定函数func2() t1 = std::thread(func2); //4. 新建一个线程t3 std::thread t3; //5. 转移t2管理的线程给t3，， t3 = std::move(t2); //6. 转移t3管理的线程给t1 t1 = std::move(t3); // BUG:不可以将一个线程的管理权交给一个已经绑定线程的变量， //否则会触发线程的terminate函数引发崩溃 // t1 = std::move(t3); std::this_thread::sleep_for(std::chrono::seconds(2000)); return 0;&#125; 异常处理当我们启动一个线程之后，如果主线程崩溃，会导致子线程也会异常退出，调用std::terminate()，如果自线程在进行一些重要的操作比如将充值信息入库等，丢失这些信息是很为危险的。所以常用的做法是捕获异常，并且在异常情况下保证子线程稳定运行结束后，主线程抛出异常结束运行 1234567891011121314151617void catch_exception() &#123; int some_local_state = 0; std::function&lt;void()&gt; myfunc = []()&#123; // doing something &#125;; std::thread functhread(myfunc); try&#123; // 本线程做的一些事情，可能引发崩溃 std::this_thread::sleep_for(std::chrono::seconds(1)); &#125; catch (std::exception&amp; e) &#123; functhread.join(); throw std::runtime_error(&quot;ababababa\\n&quot;); &#125; functhread.join();&#125; 但是用这种方式编码会显得臃肿，可以使用RAII技术，保证线程对象析构的时候等待线程运行结束，回收资源。 12345678910111213141516171819202122232425class thread_guard &#123;private: std::thread&amp; _t;public: explicit thread_guard(std::thread&amp; t) : _t(t) &#123;&#125; ~thread_guard() &#123; if(_t.joinable()) &#123; _t.join(); &#125; &#125; thread_guard(const thread_guard&amp;) = delete; thread_guard&amp; operator=(const thread_guard&amp;) = delete;&#125;;void auto_guard() &#123; int some_local_state = 0; std::function&lt;void()&gt; myfunc = []()&#123; // doing something &#125;; std::thread t1(myfunc); thread_guard guard(t1); std::cout &lt;&lt; &quot;auto guard finish\\n&quot;;&#125; 慎用隐式转换C++中会有一些隐式转换，例如char*转换为std::string等，这些隐式转换在线程的调用上可能会造成崩溃问题 12345678910void danger_oops(int som_param) &#123; char buffer[1024]; sprintf(buffer, &quot;%i&quot;, som_param); // NOTE:在线程内部将char const* 转化为std::string // 指针常量 char const* 指针本身不能变 // 常量指针 const char * 指向的内容不能变 std::thread t(print_str, 3, buffer); t.detach(); std::cout &lt;&lt; &quot;danger oops finished &quot; &lt;&lt; std::endl;&#125; 在以上代码中，当我们定义一个线程变量thread t时，传递给这个线程参数buffer会被保存到thread的成员变量中。而在线程对象t内部启动并运行线程时，参数才会被传递给调用函数print_str。而此时buffer可能到&#125;就被销毁了。改进方式很简单，我们将参数传递给thread时显示转换成string就可以了，其实相当于拷贝一份过去。 1234567891011 void danger_oops(int som_param) &#123; char buffer[1024]; sprintf(buffer, &quot;%i&quot;, som_param); //在线程内部将char const* 转化为std::string //指针常量 char const* 指针本身不能变 //常量指针 const char * 指向的内容不能变 std::thread t(print_str, 3, std::string(buffer)); t.detach(); std::cout &lt;&lt; &quot;danger oops finished &quot; &lt;&lt; std::endl;&#125; 引用参数在线程要调用的回调函数参数作为引用类型时，需要将参数显式转换为引用对象传递给构造函数，如果采用如下调用会编译失败 1234567891011void change_param(int&amp; param) &#123; ++param;&#125;void ref_oops(int some_param) &#123; std::cout &lt;&lt; &quot;before change , param is &quot; &lt;&lt; some_param &lt;&lt; std::endl; // 需要引用显式转换 std::thread t2(change_param , some_param); t2.join(); std::cout &lt;&lt; &quot;after change , param is &quot; &lt;&lt; some_param &lt;&lt; std::endl;&#125; 即使函数change_param的参数为int&amp;类型，我们传递给t2的构造函数为some_param，也不会达到在change_param函数内部修改关联到外部some_param的效果。因为some_param在传递给thread的构造函数后会转变为右值保存，右值传递给一个左值引用会出问题，所以编译也出了问题。 只需要使用std::ref()就可以解决 12345678910111213void change_param(int&amp; param) &#123; ++param;&#125;void ref_oops(int some_param) &#123; std::cout &lt;&lt; &quot;before change , param is &quot; &lt;&lt; some_param &lt;&lt; std::endl; // 需要引用显式转换 std::thread t2(change_param , std::ref(some_param)); t2.join(); std::cout &lt;&lt; &quot;after change , param is &quot; &lt;&lt; some_param &lt;&lt; std::endl;&#125; 绑定类成员函数有时候我们需要绑定一个类的成员函数。 12345678910111213class X &#123;public: void do_length_work() &#123; std::cout &lt;&lt; &quot;do_length_work&quot; &lt;&lt; std::endl; &#125;&#125;;void bind_class_oops() &#123; X my_x; std::thread t(&amp;X::do_length_work , &amp;my_x); t.join();&#125; 注意，如果thread绑定的是普通函数，可以在函数前加&amp;或者不加&amp;，因为编译器默认将普通函数名作为函数地址，但是如果是绑定类的成员函数，必须加&amp; 1234567void thead_work1(std::string str) &#123; std::cout &lt;&lt; &quot;str is &quot; &lt;&lt; str &lt;&lt; std::endl;&#125;std::string hellostr = &quot;hello world!&quot;;//两种方式都正确std::thread t1(thead_work1, hellostr);std::thread t2(&amp;thead_work1, hellostr); 使用move操作有时候传递给线程的参数是独占的，所谓独占就是不支持拷贝赋值和构造，但是我们可以通过std::move()的方式将参数的所有权转移给线程。 123456789101112void deal_unqiue(std::unique_ptr&lt;int&gt; p) &#123; std::cout &lt;&lt; &quot;unique ptr data is &quot; &lt;&lt; *p &lt;&lt; std::endl; (*p)++; std::cout &lt;&lt; &quot;after unqiue ptr data is &quot; &lt;&lt; *p &lt;&lt; std::endl;&#125;void move_oops() &#123; auto p = std::make_unique&lt;int&gt;(100); std::thread t(deal_unqiue , std::move(p)); t.join();&#125; 一次调用在一些情况下，我们有些任务需要执行一次，并且我们只希望它执行一次，例如资源的初始化人物。这个时候就可以用到std::call_once和std::once_flag。这两个接口保证即便在多线程的环境下，相应的函数也只会调用一次。 例如下面的代码，有四个线程会执行init()函数，但是只有一个线程会执行。 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;void init() &#123; std::cout &lt;&lt; &quot;Initializing....&quot; &lt;&lt; std::endl;&#125;void worker(std::once_flag&amp; flag) &#123; std::call_once(flag, init);&#125;int main() &#123; std::once_flag flag; std::thread t1( worker, std::ref(flag) ); std::thread t2( worker, std::ref(flag) ); std::thread t3( worker, std::ref(flag) ); std::thread t4( worker, std::ref(flag) ); std::thread t5( worker, std::ref(flag) ); t1.join(); t2.join(); t3.join(); t4.join(); t5.join(); return 0;&#125; 注意，我们无法确定哪个线程执行了init()函数，但是我们也不需要关心，因为只要有一个线程执行了init()函数就可以了 并发任务实例：需要计算某个范围内所有数的平方根总和 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;cmath&gt;#include &lt;chrono&gt;static int MAX = 10e8;static double sum = 0;void func(int min , int max) &#123; for(int i = min ; i &lt;= max; i++) &#123; sum += sqrt(i); &#125;&#125;void task(int min , int max) &#123; // 得到调用func之前的时间 auto start_time = std::chrono::steady_clock::now(); sum = 0; func(min , max); // 得到调用后func之后的时间 auto end_time = std::chrono::steady_clock::now(); // 得到持续的时间 auto ms = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end_time - start_time).count(); std::cout &lt;&lt; &quot;Task finish, &quot; &lt;&lt; ms &lt;&lt; &quot; ms consumed , Result: &quot; &lt;&lt; sum &lt;&lt; &quot;\\n&quot;;&#125;int main() &#123; task(1 , MAX); return 0;&#125; 输出为 1Task finish, 1821 ms consumed , Result: 2.10819e+13 很明显上面的计算使用单线程性能太差，可以使用并发进行。 先获取当前硬件支持多少个线程并行执行 根据处理器情况决定线程数量 对于每一个线程都通过func()函数来完成任务，并划分一部分数据给它处理 等待每一个线程结束。 123456789101112131415161718192021void concurrent_task(int min , int max) &#123; auto start_time = std::chrono::steady_clock::nowxainshi(); // 得到线程数量 unsigned int concurrent_count = std::thread::hardware_concurrency(); std::cout &lt;&lt; &quot;hardware_concurrency: &quot; &lt;&lt; concurrent_count &lt;&lt; &quot;\\n&quot;; std::vector&lt;std::thread&gt; threads; min = 0; sum = 0; for(int t = 0; t &lt; concurrent_count; t++) &#123; int range = max / concurrent_count * (t + 1); threads.push_back(std::thread(func , min , range)); min = range + 1; &#125; for(auto &amp;i : threads) &#123; i.join(); &#125; auto end_time = std::chrono::steady_clock::now(); auto ms = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end_time - start_time).count(); std::cout &lt;&lt; &quot;Task finish, &quot; &lt;&lt; ms &lt;&lt; &quot; ms consumed , Result: &quot; &lt;&lt; sum &lt;&lt; &quot;\\n&quot;;&#125; 输出如下 12hardware_concurrency: 20Task finish, 2086 ms consumed , Result: 1.53287e+12 但是我们会发现性能并没有多少提升，并且结果还是错的。 要搞清楚为什么，我们需要一点背景知识 对于现代处理器来说，为了加速处理的速度，每个处理器都会有自己的高速缓存，这个高速缓存是与每个处理相对应的 现在的处理器起码有三级缓存 处理器在进行计算的时候，高速缓存会参与其中，例如数据的读和写。而高速缓存和系统主存（Memory）是有可能存在不一致的。即：某个结果计算后保存在处理器的高速缓存中了，但是没有同步到主存中，此时这个值对于其他处理器就是不可见的。 事情还没有这么简单。我们对于全局变量值的修改sum += sqrt(i);这条语句，它并非是原子的。它其实很多条指令的组合才完成的。假设在某个设备上，这条语句通过下面这几个步骤来完成的，时序可能如下： 如图所示，在时间点a的时候，所有线程对于sum变量的值是一致的。 但是在时间点b之后，thread3上已经对sum进行了赋值，而这个时候其他几个线程也同时在其他处理器上使用了这个值，那么这个时候它们所使用的值是旧的，也就是错误的。最后得到的结果也就是错误的。 竞争条件与临界区当多个进程或者线程同时访问共享数据时，只要有一个任务会修改数据，那么就可能会发生问题。此时结果依赖于这些任务执行的相对时间，这种场景称为竞争条件 访问共享数据的代码片段称之为临界区。例如上面的实例，临界区就是读写sum变量的地方 要避免竞争条件，就需要对临界区进行数据保护。 那么对于上面的实例的解决方法就是一次只让一个线程访问共享数据，访问完了再让其他线程接着访问，这样就可以避免问题发生了。","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"},{"name":"并发编程","slug":"并发编程","permalink":"http://example.com/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"GDB使用指南-3","slug":"gdb-3","date":"2024-03-20T14:46:38.000Z","updated":"2024-11-08T02:21:34.891Z","comments":true,"path":"2024/03/20/gdb-3/","permalink":"http://example.com/2024/03/20/gdb-3/","excerpt":"","text":"调试运行环境设置运行参数123456789101112#include &lt;iostream&gt;int main (int argc, char *argv[]) &#123; std::cout &lt;&lt; &quot;The arguments&#x27; count is: &quot; &lt;&lt; argc &lt;&lt; std::endl; for(int i = 0; i &lt; argc; i++) &#123; std::cout &lt;&lt; argv[i] &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; return 0;&#125; 在GDB中，可以通过set args命令来设置运行参数 1(gdb) set args 参数1 参数2... 改变工作目录有时候我们需要在GDB跳转到别的文件目录中 1(gdb) cd /path/to/directory 设置输入输出假设我们有一个input.txt和一个output.txt作为程序的输入和输出文件，我们想让gdb在启动程序的时候进行重定向 1(gdb) run &lt; input.txt &gt; output.txt 如果想保存整个程序的日志文件，我们需要set logging命令 12(gdb) set logging file 文件名(gdb) set logging on 线程调试12345678910111213141516171819#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;chrono&gt;int main() &#123; std::thread t1( []() &#123; std::cout &lt;&lt; &quot;this is thread 1&quot; &lt;&lt; std::endl; std::this_thread::sleep_for( std::chrono::duration( std::chrono::seconds( 10 ) ) ); &#125; ); std::thread t2( []() &#123; std::cout &lt;&lt; &quot;this is thread 2&quot; &lt;&lt; std::endl; std::this_thread::sleep_for( std::chrono::duration( std::chrono::seconds( 10 ) ) ); &#125; ); t1.detach(), t2.detach(); return 0;&#125; 在线程调试中，如果要查看线程信息可以使用info thread 1(gdb) info thread 如果需要切换到特定的线程里面 1(gdb) thread 线程号 其他关于线程的命令 break location thread thread-id: 在指定线程上设置断点，仅当该特定线程执行时，它才会停止。 set scheduler-locking: 控制在调试过程中其他线程的行为。可以设置以下模式： off：不锁定，所有线程都可以运行。on：锁定，只有当前线程可以运行。step：只有一个线程在单步执行时才锁定其他线程。 thread apply all command: 对所有线程执行指定的命令。 set follow-fork-mode: 设置GDB在fork系统调用时如何跟踪进程。可以设置为 parent 或 child，分别表示跟踪父进程或子进程。 set detach-on-fork: 控制GDB在fork后是否保持调试父进程和子进程。 catch thread: 在任何线程创建或退出时设置断点。 thread select: 切换到已经停止的线程（例如，通过断点或者异常）。 检查堆栈1234567891011121314151617#include &lt;iostream&gt;void test(int i) &#123; if(i &lt; 0) &#123; return; &#125; test(i - 1); std::cout &lt;&lt; i &lt;&lt; std::endl;&#125;int main() &#123; test(10); return 0;&#125; 在调试过程中，堆栈是经常需要查看的 1(gdb) info stack 跳转命令在GDB中，我们可以使用jump命令（或简写为j）来实现跳转执行。例如，如果我们想从当前位置直接跳到第10行执行，可以使用以下命令： 1j 10 这样程序就会直接跳转到第10行开始执行，跳过中间所有的代码 跳转的限制虽然跳转命令很强大，但它也有一些限制。例如，我们不能跳到一个没有被加载的函数或模块中，也不能跳到一个已经执行完毕的函数或模块中。此外，频繁地使用跳转命令可能会导致程序状态的不一致，因此在使用时需要格外小心。 跳转应用的场景 绕过错误或崩溃：如果你在调试过程中遇到了一个会导致程序崩溃的代码块，并且希望跳过这部分代码继续调试程序的其他部分，可以使用jump命令。 重复执行代码：你可能想反复执行某段代码以观察问题，jump能够让你回到这段代码的起点。 测试代码路径：在多个分支或执行路径的代码中，你可能想强制执行某个特定的路径，即使它实际上在当前的程序状态下不会被执行。 跳过执行时间很长的函数：在调试时，你可能不想等待一个耗时的函数完成。你可以跳过这个函数的调用，直接跳到其后的代码执行。 信号命令信号是一种通知机制，用于告知进程某些事件已经发生。经常被用于处理异常情况（例如程序错误、外部中断等），在GDB中我们可以通过信号命令来处理、模拟这些信号 生成和处理信号在GDB中，我们可以使用signal命令来发送信号到正在调试的程序。例如，要发送一个SIGINT信号，我们可以使用以下命令： 1(gdb) signal SIGINT 这是模拟用户按下Ctrl+C的情况 查看和设置信号要查看当前程序如何处理各种信号，可以使用info signals 1(gdb) info signals 这将显示所有信号及其当前的处理方式。 如果我们想改变某个信号的处理方式，可以使用handle命令。例如，要让程序在接收到SIGINT信号时停止并打印消息，我们可以使用： 1(gdb) handle SIGINT stop print 这样，每当程序接收到SIGINT信号时，它都会停止执行并在GDB中打印消息 运行SHELL命令要想运行shell命令，我们只需要在命令前加上shell关键字即可 1(gdb) shell ... 调试core文件在软件开发过程中，程序可能会出现崩溃。为了更好地理解和解决这些崩溃，我们经常需要调试程序的core文件。core文件是程序崩溃时生成的，它包含了程序崩溃时的内存快照，帮助我们定位问题。 生成core文件先放一份源文件，方便调试 12345678910#include &lt;iostream&gt;#include &lt;numeric&gt;int main() &#123; int a[10]; std::iota(a , a + 10, 0); std::cout &lt;&lt; a[100001] &lt;&lt; std::endl; return 0;&#125; 当程序崩溃时，系统通常会生成一个core文件，要确保core文件被生成，需要设置ulimit 1ulimit -c unlimited 使用GDB查看core文件要使用GDB查看core文件，我们需要两个文件：崩溃的程序的可执行文件和core文件。使用以下命令启动GDB： 1gdb &lt;executable-file&gt; &lt;core-file&gt; 这里可以使用coredumpctl来调用gdb 12# 启动最新的core文件coredumpctl debug 实时观察进程Crash信息有时，我们可能希望实时观察进程的崩溃信息，而不是等待程序崩溃后再查看core文件。为此，我们可以使用strace工具跟踪系统调用和信号。 1strace -o output.txt &lt;executable-file&gt; 这将在output.txt文件中记录所有的系统调用和信号，帮助我们实时观察进程的行为。","categories":[{"name":"工具","slug":"工具","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"},{"name":"调试","slug":"调试","permalink":"http://example.com/tags/%E8%B0%83%E8%AF%95/"}]},{"title":"GDB 使用指南-2","slug":"gdb-2","date":"2024-03-18T14:24:45.000Z","updated":"2024-11-08T02:21:34.891Z","comments":true,"path":"2024/03/18/gdb-2/","permalink":"http://example.com/2024/03/18/gdb-2/","excerpt":"","text":"本文主要描述了GDB中断点调试和数据命令的使用方法 断点调试设置断点要设置断点时，使用break或b来设置断点 1b main.cpp:5 条件断点有时，我们只想在满足特定条件时暂停程序 1b main.cpp:5 if i == 5 查看断点如果需要查看所有断点所在的位置信息，使用info breakpoints 1info breakpoints 清除断点有些断点我们不再需要，可以直接清除 12# 清理第5行的断点clear main.cpp:5 观察点观察点允许我们监视变量的值，并在其值发生变化时暂停程序。这对于跟踪变量的变化非常有用 1watch variable_name 捕捉点捕捉点是一种特殊类型的断点，它允许我们在发生特定事件，如抛出异常时暂停程序。 12# 设置捕捉点catch throw 这将设置一个捕捉点，当程序抛出异常时，它将暂停。 数据类型显示表达式值在GDB中，可以通过print来评估表达式并显示其值 1print variable_name 查看数据类型当我们需要查看一个变量的类型，（例如类型推断的变量），需要使用whatis命令 1whatis variable_name 打印变量值display命令可以自动显示表达式的值，每次程序停止时都会显示 1display x 每次程序停止时，都会显示变量x的值 修改变量值在某些情况下，需要在调试过程中修改变量值。假设要将变量x的值设置为5，使用set命令 1set variable x = 5 这将立即更改变量x的值，而不需要重新编译或重新启动程序。","categories":[{"name":"工具","slug":"工具","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"},{"name":"调试","slug":"调试","permalink":"http://example.com/tags/%E8%B0%83%E8%AF%95/"}]},{"title":"GDB 使用指南-1","slug":"gdb-1","date":"2024-03-18T13:48:08.000Z","updated":"2024-11-08T02:21:34.891Z","comments":true,"path":"2024/03/18/gdb-1/","permalink":"http://example.com/2024/03/18/gdb-1/","excerpt":"","text":"本文主要描述了GDB的基础命令使用 GDB 介绍GDB，全称GNU调试器（GNU Debugger），是一个强大的Unix系统下的源代码级调试工具。它可以帮助程序员查看程序在执行过程中的内部状态，从而更好地理解程序的运行机制。GDB主要用于调试C和C++语言编写的程序。它的存在，使得我们能够更深入地了解程序的运行过程，找出并修复程序中的错误。 基本命令启动GDB假如我们有一个编译好的C++程序，名字是a.out，（记得编译的时候要带-g表示有调试信息），接下来我们需要启动GDB 1gdb a.out 查看源码在GDB中，我们可以通过list来查看源码信息 1(gdb) list 设置断点断点是调试的核心，允许在程序特定的位置暂停执行，可以通过break来设置断点，通常只需要b + 文件名: + 行号即可 1(gdb) b main.cpp:5 查看断点在设置了多个断点之后，我们可能需要查看所有的断点信息，来确保没有遗漏或者打错位置的断点，可以使用info breakpoints来查看所有的断点 1(gdb) info breakpoints 运行代码接下来可以开始执行程序了，使用run来让程序跑起来 1(gdb) run 当程序遇到断点时，它会暂停，等待我们的进一步指令。 显示变量值在调试过程中，如果需要查看变量，使用print + variable_name 1(gdb) print b 观察变量在某些情况下，我们可能想要知道一个变量何时被修改。GDB提供了watch命令，允许我们观察变量的变化。 1(gdb) watch variable_name 每当variable_name的值发生变化时，程序会暂停执行。 单步运行如果需要一行一行执行代码，可以使用step，一般用s即可 1(gdb) s 继续执行如果设置了断点停止了程序，这时想让程序直接执行到下一个断点时，使用continue 1(gdb) continue","categories":[{"name":"工具","slug":"工具","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"},{"name":"调试","slug":"调试","permalink":"http://example.com/tags/%E8%B0%83%E8%AF%95/"}]},{"title":"CPP-类","slug":"cpp-oop-1","date":"2024-03-17T14:46:26.000Z","updated":"2024-11-08T02:21:34.891Z","comments":true,"path":"2024/03/17/cpp-oop-1/","permalink":"http://example.com/2024/03/17/cpp-oop-1/","excerpt":"","text":"类简介类就是对一种类型的抽象，例如纸箱、木箱都是箱子，箱子就是类，而木箱、纸箱就是类实例化的对象 构造函数类相当于定义了一个新的类型，该类型生成在堆或栈上的对象时内存排布与C语言相同。C++规定有在类对象创建时就在对应内存将数据初始化的能力，这就是构造函数 例子: 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;class Box &#123;public: // 默认构造函数 Box() = default; // 普通构造函数 Box(const std::string&amp; name, const int cap) : id_(name) , capacity_(cap) &#123; std::cout &lt;&lt; &quot;Box Constructor&quot; &lt;&lt; std::endl; &#125; // 复制构造函数 Box(const Box&amp; other) &#123; std::cout &lt;&lt; &quot;Box copy constructor&quot; &lt;&lt; std::endl; id_ = other.id_; capacity_ = other.capacity_; &#125; // 移动构造函数 Box(Box&amp;&amp; other) noexcept &#123; std::cout &lt;&lt; &quot;Box move constructor&quot; &lt;&lt; std::endl; id_ = std::move(other.id_); capacity_ = other.capacity_; capacity_ = 0; &#125; // 析构函数 ~Box() &#123;&#125;private: std::string id_; std::size_t capacity_;&#125;;int main() &#123; Box b1(&quot;Paper Box&quot;, 100); // 创建一个对象 Box b2(b1); // 复制一个对象 Box b3 = std::move(b2); // 移动构造 return 0;&#125; 输出如下 123Box ConstructorBox copy constructorBox move constructor 上面的例子演示了构造函数的几种类型: 普通构造函数: 如代码所示 复制构造函数：用另一个对象来初始化对象 移动构造函数：用另一个对象来初始化对象, 可以避免复制带来的开销 默认构造函数：当没有定义任何构造函数时，编译器会为该类生成一个默认构造函数，默认构造函数什么都没做，内存没被初始化 例如Box() &#123;&#125; 析构函数当类对象被销毁时，就会调用析构函数。栈上对象的销毁就是函数栈的销毁时 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;class Box &#123;public: // 默认构造函数 Box() = default; // 普通构造函数 Box(const std::string&amp; name, const int cap) : id_(name) , capacity_(cap) &#123; std::cout &lt;&lt; &quot;Box Constructor&quot; &lt;&lt; std::endl; &#125; // 复制构造函数 Box(const Box&amp; other) &#123; std::cout &lt;&lt; &quot;Box copy constructor&quot; &lt;&lt; std::endl; id_ = other.id_; capacity_ = other.capacity_; &#125; // 移动构造函数 Box(Box&amp;&amp; other) noexcept &#123; std::cout &lt;&lt; &quot;Box move constructor&quot; &lt;&lt; std::endl; id_ = std::move(other.id_); capacity_ = other.capacity_; capacity_ = 0; &#125; // 析构函数 ~Box() &#123; std::cout &lt;&lt; &quot;Box destructor&quot; &lt;&lt; std::endl; &#125;private: std::string id_; std::size_t capacity_;&#125;;int main() &#123; Box b1(&quot;Paper Box&quot;, 100); // 创建一个对象 Box b2(b1); // 复制一个对象 Box b3 = std::move(b2); // 移动构造 return 0;&#125; 输出如下 123456Box ConstructorBox copy constructorBox move constructorBox destructorBox destructorBox destructor 总结 构造函数就是C++提供的必须有的在对象创建时初始化对象的方法(默认什么都不做也是一种初始化的方式) 当类对象销毁时有一些我们必须手动操作的步骤时，析构函数就派上了用场（例如手动释放内存 所以，几乎所有的类都需要写一个构造函数，但是析构函数却未必需要","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"},{"name":"面向对象","slug":"面向对象","permalink":"http://example.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}]},{"title":"java语法","slug":"java-grammar","date":"2024-03-16T07:47:30.000Z","updated":"2024-11-08T02:21:34.892Z","comments":true,"path":"2024/03/16/java-grammar/","permalink":"http://example.com/2024/03/16/java-grammar/","excerpt":"","text":"the grammar of java数据类型byte: 数据类型是8位 short: 数据类型是16位 int: 数据类型是32位 long: 数据类型是64位 float: 单精度浮点数 double: 双精度浮点数 boolean: 存储bool量 char: 存储任何字符 number &amp; math类number子类 java为每一个数据类型都封装了对应的包装类 包装类 基本数据类型 booleans boolean byte byte short short integer int long long character char float float double double 123456public class main &#123; public static void main(string[] args) &#123; integer x = 5; system.out.println(x); &#125;&#125; 一些基本方法 名称 描述 xxxvalue() 将number对象转换为xxx数据类型并返回 compareto() 将number对象与参数比较 equals() 判断number对象是否与参数相等 valueof() 返回一个number对象指定的内置数据类型 tostring() 以字符串形式返回值 paraseint() 将字符串解析为int类型 用法 paraseint() 1234567public class main &#123; public static void main(string[] args) &#123; string re = &quot;10.0&quot;; double x = double.parsedouble(re); system.out.println(x); &#125;&#125; math类 math类包含了基本的数学运算math类的方法都被定义为static形式，可以在主函数直接调用 12345678public class main &#123; public static void main(string[] args) &#123; system.out.println(&quot;the sin value of 90 degree is: &quot; + math.sin(math.pi / 2.0)); system.out.println(&quot;the cos value of 0 degree is: &quot; + math.cos(0)); system.out.println(&quot;the tan value of 60 degree is: &quot; + math.tan(math.pi / 3.0)); system.out.println(&quot;the degree of pi / 2 is: &quot; + math.todegrees(math.pi / 2)); &#125;&#125; 基本方法 名称 描述 abs() 返回参数的绝对值 ceil() 返回向上取整的给定参数的整数 floor() 返回向下取整的给定参数的整数 rint() 返回与参数最接近的整数，返回类型为double round() 表示四舍五入 math.floor(x + 0.5) min() 返回两个参数中的最小值 max() 返回两个参数中的最大值 pow() 返回第一个参数的第二个参数的次方 sqrt() 返回参数的算术平方根 random() 返回一个随机数 character类123456789101112131415public class main &#123; public static void main(string[] args) &#123; //note: 定义一个字符串数组 char[] test = &#123;&#x27;h&#x27; , &#x27;e&#x27; , &#x27;l&#x27; , &#x27;l&#x27; , &#x27;o&#x27;&#125;; for(char ch : test) &#123; system.out.print(ch); &#125; system.out.println(); char ch = &#x27;h&#x27;; system.out.println(ch); //note: character字符串数组 character[] test_2 = &#123;&#x27;h&#x27; , &#x27;e&#x27; , &#x27;l&#x27; , &#x27;l&#x27; , &#x27;o&#x27;&#125;; system.out.println(test_2[1]); &#125;&#125; 基本方法 方法 说明 isletter() 是否是一个字母 isdigit() 是否是一个数字字符 iswhitespace() 是否是一个空白字符 isuppercase() 是否是大写字母 islowercase() 是否是小写字母 tostring() 返回字符的字符串形式，字符串的长度为1 string类 java提供了string类来创建和操作字符串 字符串创建 1234567891011//note: 创建字符串string tmp = &quot;noob&quot;;string tmp2 = new string(&quot;awdawd&quot;);system.out.println(tmp);system.out.println(tmp2);//note: 用字符串数组创建字符串char[] hello = &#123;&#x27;h&#x27; , &#x27;e&#x27; , &#x27;l&#x27; , &#x27;l&#x27; , &#x27;o&#x27;&#125;;string tmp3 = new string(hello);system.out.println(tmp3);string tmp4 = tmp2; // note: 这种创建方式是引用 求字符串长度 length() 1234//note: 求字符串长度string world = &quot;world&quot;;system.out.println(world.length()); 连接字符串 concat(string) 返回一个连接好字符串 12345//note: 连接字符串string s1 = &quot;hello, &quot; , s2 = &quot;world!&quot;;string s3 = s1.concat(s2);system.out.println(s3); 创建格式化字符串 string类使用静态方法format()返回一个string对象而不是printstream对象string类的静态方法format()能用来创建可复用的格式化字符串 1234//note: 创建格式化字符串string fs;fs = string.format(&quot;float is: &quot; + &quot;%f , int is: &quot; + &quot;%d , string is: &quot; + &quot;%s&quot; , 10.1 , 12 , s3);system.out.println(fs); 基本方法 名称 描述 char charat(int index) 返回指定索引处的char值 int compareto(string anotherstring) 按字典序比较两个字符串 int comparetoignorecase(string str) 按字典序比较两个字符串(忽略大小写) boolean contentequals(stringbuffer sb) 当且仅当字符串与指定的stringbuffer有相同顺序的字符时候返回真。 int indexof(string str) 返回指定子字符串在此字符串中第一次出现处的索引。 int indexof(string str , int from index) 返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。 int lastindexof(int ch) 返回指定字符在此字符串中最后一次出现处的索引。 int lastindexof(int ch, int fromindex) 返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索。 int lastindexof(string str) 返回指定子字符串在此字符串中最右边出现处的索引。 int lastindexof(string str, int fromindex) 返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。 string touppercase() 使用默认语言环境的规则将此 string 中的所有字符都转换为大写。 string tolowercase() 使用默认语言环境的规则将此 string 中的所有字符都转换为小写。 char[] tochararray() 将此字符串转换为一个新的字符数组。 string substring(int beginindex, int endindex) 返回一个新字符串，它是此字符串的一个子字符串。 string substring(int beginindex) 返回一个新的字符串，它是此字符串的一个子字符串。 stringbuffer &amp; string builder类 在使用 stringbuffer 类时，每次都会对 stringbuffer 对象本身进行操作，而不是生成新的对象，所以如果需要对字符串进行修改推荐使用 stringbuffer。在不要求线程安全的情况下，使用string builder类，string builder会比stringbuffer快。 1234567891011121314// note: 先创建一个大小为10的空字符串stringbuilder sb = new stringbuilder(10);system.out.println(sb);// note: 从尾部填充字符串sb.append(&quot;runoob..&quot;);system.out.println(sb);sb.append(&quot;!&quot;);system.out.println(sb);// note: 从指定索引处开始填充字符串，不足部分会扩容sb.insert(8 , &quot;java&quot;);system.out.println(sb);// note: 删除指定区间的字符串sb.delete(5 , 8);system.out.println(sb); 数组创建数组12345678/** note: 创建数组* datatype[] array* datatype[] array = new datatype[size]* */integer[] arr = &#123;1 , 2 , 3 , 4 , 5&#125;;integer[] arr2 = new integer[100]; 遍历数组及访问数组12345678// note: 遍历数组for(int i = 0; i &lt; arr.length; i++) &#123; system.out.println(arr[i]);&#125;// note: 范围遍历 for_eachfor(integer value : arr) &#123; system.out.println(value);&#125; 数组作为函数参数123456public static void printarray(integer[] arr) &#123; for(integer value : arr) &#123; system.out.println(value); &#125;&#125;printarray(new integer[]&#123;10 , 20 , 30 , 40&#125;); 数组作为返回值12345678public static integer[] reverse(integer[] arr) &#123; integer[] res = new integer[arr.length]; for(int i = 0, j = arr.length - 1; i &lt; arr.length; i++ , j--) &#123; res[i] = arr[j]; &#125; return res;&#125;printarray(reverse(arr)); 多维数组123456/** note: type[][] typename = new type[length][length]* */string[][] arr = new string[20][30]; arrays类 包含了排序、查找、打印等内容 要先import java.util.arrays 打印数组 1234int [] a = &#123;1 , 2 , 3, 4, 5&#125;;system.out.println(a);system.out.println(arrays.tostring(a)); // 打印数组元素的值 升序排序 12345int [] b = &#123;2 , 56 ,12893 ,12 , 23 ,3 , 5 , 67123&#125;;system.out.println(arrays.tostring(b)); // 打印数组元素的值arrays.sort(b);system.out.println(arrays.tostring(b)); // 打印数组元素的值 数组元素是引用类型的排序 12345678910111213141516171819202122232425262728293031import java.util.arrays;class man implements comparable&#123; int age , id; string name; public man(int age , string name) &#123; super(); // 父类型特征，先初始化父类型特征，再初始化子类 this.age = age; this.name = name; &#125; public int compareto(object o) &#123; man man = (man) o; if(this.age &lt; man.age) &#123; return -1; &#125; else if(this.age &gt; man.age) &#123; return 1; &#125; else &#123; return 0; &#125; &#125;&#125;public class main &#123; public static void main(string[] args) &#123; man[] msmans = &#123;new man(3, &quot;a&quot;), new man(60, &quot;b&quot;),new man(2, &quot;c&quot;)&#125;; arrays.sort(msmans); system.out.println(arrays.tostring(msmans)); &#125;&#125; 1234integer[] arr = &#123;10 , 20 , 30 , 40 , 50 , 60 , 70&#125;;int x = arrays.binarysearch(arr , 30);system.out.println(x); 填充数组 1234int[] a = &#123;1,2,323,23,543,12,59&#125;;system.out.println(arrays.tostring(a));arrays.fill(a , 10);system.out.println(arrays.tostring(a)); 方法 定义 123456修饰符 返回值类型 方法名(参数类型 参数名)&#123; ... 方法体 ... return 返回值;&#125; 可变参数 12345678910111213public static void print(double... args) &#123; if(args.length == 0) &#123; system.out.println(&quot;no argument passed&quot;); &#125; for(double val : args) &#123; system.out.print(val + &#x27; &#x27;); &#125; system.out.println();&#125;public static void main(string[] args) &#123; print(10.1 , 2.1 , 3.2);&#125; finalize()方法 (弃用) 这种方法在对象被垃圾收集器析构前调用，用来清除回收对象 在finalize()方法里，必须指定在对象销毁时候要执行的操作一般格式是 123protected void finalize() &#123; // note: terminate your code&#125; 实例 1234567891011121314151617181920class cake extends object&#123; private int id; public cake(int id) &#123; this.id = id; system.out.println(&quot;cake object &quot; + id + &quot;is created&quot;); &#125; protected void finalize() throws java.lang.throwable &#123; super.finalize(); system.out.println(&quot;cake object &quot; + id + &quot;is disposed&quot;); &#125;&#125;public static void main(string[] args) &#123; cake c1 = new cake(1); cake c2 = new cake(2); cake c3 = new cake(3); c2 = c3 = null; system.gc();&#125; stream, file, iojava.io包含了所有操作输入、输出需要的类 使用这些类之前要先import java.io.* 读取控制台输入java的控制台输入由system.in完成。为了获得一个绑定到控制台的字符串，你可以把system.in包装在一个buffererreader对象中来创建一个字符串流。 1bufferedreader br = new bufferedreader(new inputstreamreader(system.in)); 创建完bufferedreader对象之后，可以使用其中的read()方法来获取控制台的一个字符，或者使用readline()方法来获取一个字符串 从控制台读取多字符输入12345678910public static void main(string[] args) throws ioexception &#123; bufferedreader br = new bufferedreader(new inputstreamreader(system.in)); char c; system.out.println(&quot;input something, press &#x27;q&#x27; to quit&quot;); // read do &#123; c = (char) br.read(); system.out.println(c); &#125; while(c != &#x27;q&#x27;);&#125; 从控制台读取字符串123456789101112public static void main(string[] args) throws ioexception &#123; bufferedreader br = new bufferedreader(new inputstreamreader(system.in)); string read; system.out.println(&quot;enter lines of text&quot;); system.out.println(&quot;enter \\&quot;end\\&quot; to quit&quot;); // read do &#123; read = br.readline(); system.out.println(read); &#125; while(!read.equals(&quot;end&quot;));&#125; 读写文件 fileinputstream该流用于从文件读取数据，它的对象可以用关键字 new 来创建。 创建方法: 123inputstream f = new fileinputstream(&quot;c:/java/hello&quot;);file f = new file(&quot;c:/java/hello&quot;);inputstream in = new fileinputstream(f); 基本方法 名称 描述 public void close() throws ioexception 关闭文件输入流并释放与此流相关的的所有系统资源。抛出ioexception异常 public int read(int r) throws ioexception 从inputstream对象读取指定字节的数据。返回下一字节的数据，如果已经到结尾则返回-1 public int read(byte[] r) throws ioexception 从输入流读取r.length长度的字节。返回读取的字节数，如果是文件结尾则返回-1 public int available() throws ioexception 返回下一次对此输入流调用的方法可以不接受阻塞地从此输入流读取的字节数。 fileoutputstream该类用来创建一个文件并向文件中写数据。如果该文件不存在，则会自动创建。 创建方法 123outputstream f = new fileoutputstream(&quot;c:/java/hello&quot;)file f = new file(&quot;c:/java/hello&quot;);outputstream fout = new fileoutputstream(f); 基本方法 名称 描述 public void close() throws ioexception 关闭此文件的输出流并释放有关的所有系统资源。抛出ioexception异常 public void write(int w) throws ioexception 把指定的字节写入到流中 public void write(byte[] w) throws ioexception 把指定的数组w.length长度的字节写到outputstream中 1234567891011121314151617181920public static void main(string[] args) &#123; try&#123; byte bwrite[] = &#123;11 , 23 , 3 , 40 , 5&#125;; outputstream os = new fileoutputstream(&quot;output.txt&quot;); for(byte value : bwrite) &#123; os.write(value); &#125; os.close(); inputstream is = new fileinputstream(&quot;input.txt&quot;); int size = is.available(); for(int i = 0; i &lt; size; i++) &#123; system.out.print((char) is.read() + &quot; &quot;); &#125; is.close(); &#125; catch(ioexception e) &#123; system.out.println(&quot;exception&quot;); &#125;&#125; scanner类可以通过scanner类来获取用户输入 创建方法 12import java.util.scanner;scanner sc = new scanner(system.in); 在读取字符串的时候，通常需要使用hasnext()与hasnextline判断是否还有输入的数据 12345678910public static void main(string[] args) &#123; scanner sc = new scanner(system.in); // read system.out.println(&quot;input something&quot;); if (sc.hasnext()) &#123; string str1 = sc.next(); system.out.println(str1); &#125; sc.close();&#125; 12345678910public static void main(string[] args) &#123; scanner sc = new scanner(system.in); // read system.out.println(&quot;input something&quot;); if (sc.hasnextline()) &#123; string str1 = sc.nextline(); system.out.println(str1); &#125; sc.close();&#125; next与nextline的区别next(): 一定要读取到有效字符后才可以结束输入 对输入有效字符之前遇到的空白，next()方法会自动将其去掉 只有输入有效字符之后才将其后面输入的空白作为分隔符或者结束符 next()不能的得到带有空格的字符串 nextline(): 以enter为结束符，也就是说，nextline()方法返回的是输入回撤之前的所有字符 可以获得空白 如果要输入int或float类型的数据，在scanner类中也有支持，但是在输入之前最好先使用hasnextxxx()方法进行验证，再使用nextxxx()来读取 123456789101112131415161718public static void main(string[] args) &#123; scanner sc = new scanner(system.in); // read int i = 0; float f = 0.0f; system.out.println(&quot;input integer&quot;); if(sc.hasnextint()) &#123; i = sc.nextint(); &#125; system.out.println(&quot;the integer is: &quot; + i); system.out.println(&quot;input float&quot;); if(sc.hasnextfloat()) &#123; f = sc.nextfloat(); &#125; system.out.println(&quot;the float is: &quot; + f); sc.close();&#125; 例如计算输入的数的总和和平均值 12345678910111213141516public static void main(string[] args) &#123; system.out.println(&quot;input some value&quot;); scanner sc = new scanner(system.in); double sum = 0; int cnt = 0; while(sc.hasnextdouble()) &#123; double m = sc.nextdouble(); sum += m; cnt++; &#125; // note: 如果需要退出循环，只需要输入一个非数字字符即可 system.out.println(&quot;the sum is: &quot; + sum); system.out.println(&quot;the avg is: &quot; + sum / cnt);&#125; 异常处理有三种异常类型： 检查型异常: 最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。 运行时异常：运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。 错误： 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。 exception类的层次所有的异常类是从java.lang.exception类继承的子类 捕获异常12345try &#123; // your code&#125; catch(exceptionname e) &#123; // catch 块&#125; 实例：检测数组索引是否合法 12345678910111213141516public static void main(string[] args) &#123; try&#123; int a[] = new int[2]; scanner sc = new scanner(system.in); system.out.println(&quot;please input a index&quot;); int index = 0; if(sc.hasnextint()) &#123; index = sc.nextint(); &#125; // note: 如果索引不合法，数组就会抛出arrayindexoutofboundsexception异常 system.out.println(&quot;access element successfully: &quot; + a[index]); &#125; catch(arrayindexoutofboundsexception e) &#123; system.out.println(&quot;exception thrown: &quot; + e); &#125; system.out.println(&quot;out of the block&quot;);&#125; 多重捕获块123456789try&#123;&#125; catch(exceptiontype e1) &#123;&#125; catch(exceptionname e2) &#123;&#125; catch(exceptiontype e3) &#123;&#125; 12345678910try &#123; file = new fileinputstream(filename); x = (byte) file.read();&#125; catch(filenotfoundexception f) &#123; // not valid! f.printstacktrace(); return -1;&#125; catch(ioexception i) &#123; i.printstacktrace(); return -1;&#125; 上述代码中，抛出的异常会去匹配对应的异常类型的catch块 throw &#x2F; throws 关键字throw关键字用于在代码中抛出异常，throws关键字用于在方法声明中指定可能会抛出的异常类型 throw 关键字通常情况下，当代码执行到某个条件下无法继续正常执行时，可以使用throw关键字抛出异常，已告知调用者当前代码的执行状态 例如下面的代码，用来判断参数是否小于0,如果是，则抛出一个illegalargumentexception异常 12345public static void test(int num) &#123; if(num &lt; 0) &#123; throw new illegalargumentexception(&quot;number must be greater than 0&quot;); &#125;&#125; throws 关键字throws关键字用于在方法声明中指定该方法可能抛出异常。当方法内部抛出指定类型的异常时，该异常会被传递给调用该方法的代码，并在该代码中处理异常 例如下面的代码，当readfile方法内部发生异常时，会将该异常传递给调用该方法的代码。在调用该方法的代码中，必须捕获或声明处理ioexception 123456789public static void readfile(string filepath) throws ioexception &#123; bufferedreader bf = new bufferedreader(new filereader(filepath)); string line = bf.readline(); while(line != null) &#123; system.out.println(line); line = bf.readline(); &#125; bf.close();&#125; 一个方法可以声明抛出多个异常，多个异常之间用逗号隔开 1234public static void withdraw(double amount) throws remoteexception, insufficientresourcesexception &#123; // do something&#125; finally 关键字finally 关键字用来创建在 try 代码块后面执行的代码块。 无论是否发生异常，finally 代码块中的代码总会被执行。 在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。 1234567try &#123;&#125; catch(exceptiontype e) &#123;&#125; finally &#123;&#125; 实例： 123456789101112public static void main(string[] args) &#123; int[] a = new int[2]; try &#123; system.out.println(&quot;access element three: &quot; + a[3]); &#125; catch (arrayindexoutofboundsexception e) &#123; system.out.println(&quot;exception thrown: &quot; + e); &#125; finally &#123; a[0] = 6; system.out.println(&quot;first element value: &quot; + a[0]); system.out.println(&quot;the finally statement is excuted&quot;); &#125;&#125; 注意： catch块不能独立于try块 try块后面不能没有catch块也没finally块 try, catch, finally块之间不能添加任何代码 try-with-source我们可以使用try-with-source语法糖来打开资源，并且可以在语句执行完毕后确保每个资源都被自动关闭 12345678public static void main(string[] args) throws ioexception &#123; try (scanner sc = new scanner(system.in))&#123; printwriter writer = new printwriter(new file(&quot;testwrite.txt&quot;)); while(sc.hasnext()) &#123; writer.print(sc.next()); &#125; &#125;&#125; 多个资源回收时，try-with-source语句以相反的顺序关闭这些资源 声明自定义异常在java编写自定义异常时，要记住以下几点： 所有异常都必须是throwable的子类 如果希望写一个检查性异常类，则需要继承exception类。 如果希望写一个运行时异常类，那么则需要继承runtimeexception类 创建方式: 123class myexception extends exception &#123;&#125; 例如我们要做一个检查银行账户类，用户在取款时，有可能余额小于取款额，这时我们就可以设计一个资金不足异常类，用于在这种情况下抛出异常 12345678910class insufficientfundsexception extends exception &#123; private double amount; public insufficientfundsexception(double amount) &#123; this.amount = amount; &#125; public double getamount() &#123; return amount; &#125;&#125; 然后再设计一个检查账户类 123456789101112131415161718192021222324252627282930313233343536class checkingaccount &#123; // balance是余额，number是卡号 private double balance; private int number; public checkingaccount(int num) &#123; this.number = num; &#125; // 存钱 public void deposit(double amount) &#123; this.balance = amount; &#125; // 取款 public void withdraw(double amount) throws insufficientfundsexception &#123; if(balance &gt;= amount) &#123; balance -= amount; &#125; else &#123; double needs = amount - balance; throw new insufficientfundsexception(needs); &#125; &#125; // 返回余额 public double getbalance() &#123; return balance; &#125; // 返回卡号 public int getnumber() &#123; return number; &#125;&#125; 测试如下： 123456789101112131415public static void main(string[] args) &#123; checkingaccount c = new checkingaccount(123); system.out.println(&quot;deposit 5000.0...&quot;); c.deposit(5000.0); try &#123; system.out.println(&quot;\\nwithdrawing $1000...&quot;); c.withdraw(100); system.out.println(&quot;\\nwithdrawing $6000...&quot;); c.withdraw(6000); &#125; catch(insufficientfundsexception e) &#123; system.out.println(&quot;sorry, but you are shot $&quot; + e.getamount()); e.printstacktrace(); &#125;&#125; 结果如下： 1234567891011insufficientfundsexception at checkingaccount.withdraw(main.java:40) at main.main(main.java:63)deposit 5000.0...withdrawing $1000...withdrawing $6000...sorry, but you are shot $1100.0 面向对象继承特性 子类拥有父类非private属性、方法 子类拥有自己的属性和方法，即子类可以对父类进行扩展 子类可以用自己的方式实现父类的方法 java的继承是单继承，但是可以多重继承，无法多继承 继承格式: 1234567class 父类 &#123;&#125;class 子类 extends 父类 &#123;&#125; 继承关键字继承可以使用extends和implements关键字，而且所有的类都是继承于java.lang.object，当一个类没有继承的两个关键字，则默认继承object祖先类 extends, super, this关键字 extends只能继承一个类 super用来实现对父类成员的访问，用来引用当前的父类对象 this，指向自己的引用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class animal &#123; private string name; private int id; public animal() &#123; this.name = &quot;none&quot;; this.id = 0; &#125; public animal(string name , int id) &#123; this.name = name; this.id = id; &#125; public void eat() &#123; system.out.println(&quot;eating&quot;); &#125; public void sleep() &#123; system.out.println(&quot;sleeping&quot;); &#125; public void introduction() &#123; system.out.println(&quot;my name is: &quot; + name + &quot; and my id is: &quot; + id); &#125; public void test() &#123; system.out.println(&quot;this is animal&quot;); &#125;&#125;class penguin extends animal &#123; public penguin(string name , int id) &#123; super(name , id); &#125;&#125;class mouse extends animal &#123; public mouse(string name , int id) &#123; super(name , id); &#125;&#125;class dog extends animal &#123; public void test() &#123; system.out.println(&quot;this is dog&quot;); &#125; public void test2() &#123; super.test(); &#125;&#125;public class main &#123; public static void main(string[] args) &#123; mouse mou = new mouse(&quot;mou&quot; , 1); penguin pen = new penguin(&quot;pen&quot; , 1); pen.eat(); mou.introduction(); dog dog = new dog(); dog.test(); dog.test2(); &#125;&#125; implements关键字 可以是java变相具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口 123456789101112interface a &#123; public void eat(); public void sleep();&#125;interface b &#123; public void show();&#125;abstract class c implements a , b &#123;&#125; final关键字 使用final关键字声明类，就是把类定义为最终类，不能被继承，或者用于修饰方法，该方法不能被子类重写 格式： 1234567// 声明类final class a &#123;&#125;// 声明方法(public, private, default, protected) final return type functionname() &#123;&#125; 构造器如果父类的构造器带有参数，则必须在子类的构造器中显式地通过super关键字调用父类的构造器并配以适当的参数列表，如果父类没有则不需要，系统会自动调用父类的无参构造器 1234567891011121314151617181920212223242526272829303132class superclass &#123; private int n; public superclass() &#123; system.out.println(&quot;call superclass()&quot;); &#125; public superclass(int n) &#123; this.n = n; system.out.println(&quot;call superclass(int n)&quot;); &#125;&#125;class subclass extends superclass &#123; private int n; public subclass(int n) &#123; super(n); system.out.println(&quot;subclass(n)&quot;); this.n = n; &#125; public subclass() &#123; system.out.println(&quot;subclass&quot;); &#125;&#125;public class main &#123; public static void main(string[] args) &#123; system.out.println(&quot;------subclass 类继承------&quot;); subclass sc1 = new subclass(); subclass sc2 = new subclass(100); system.out.println(&quot;------subclass2 类继承------&quot;); &#125;&#125; override &amp; overload重写(override)重写是子类对父类的允许访问的方法的实现过程重写，返回值和形参都不改变。重写方法不能抛出新的检查异常或者比被重写的方法声明更加广泛的异常。例如：父类的一个方法声明了一个检查异常ioexception，但是在重写这个方法的时候不能抛出exception异常，因为exception是ioexception的父类，抛出ioexception或者ioexception的子类异常 123456789101112131415161718192021class animal &#123; public void move() &#123; system.out.println(&quot;moving....&quot;); &#125;&#125;class dog extends animal &#123; public void move() &#123; system.out.println(&quot;the dog is moving...&quot;); &#125;&#125;public class main &#123; public static void main(string[] args) &#123; animal a = new animal(); animal b = new dog(); a.move(); b.move(); &#125;&#125; 在上面的代码中，dog类继承自animal类并重写了move方法，尽管b是属于animal类型，但它运行的是dog类的move方法。注意，如果dog类存在animal类中没有的方法，并且在调用了这个方法，编译不会通过。 方法的重写原则 参数列表和被重写的方法的参数列表必须完全相同 返回类型与被重写的方法的返回类型可以不相同，但是必须是父类返回值的派生类 访问权限不能比父类被重写的方法的访问权限更低。 父类的成员方法只能被它的子类重写 声明为 static 的方法不能被重写，但是能够被再次声明。 声明为 final 的方法不能被重写。 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。 子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。 构造方法不能被重写。 super关键字 当需要在子类中调用父类的被重写方法时，要使用 super 关键字。 12345678910111213141516171819class animal &#123; public void move() &#123; system.out.println(&quot;moving....&quot;); &#125;&#125;class dog extends animal &#123; public void move() &#123; super.move(); system.out.println(&quot;the dog is moving...&quot;); &#125;&#125;public class main &#123; public static void main(string[] args) &#123; animal b = new dog(); b.move(); &#125;&#125; 重载(overload)接口接口（英文：interface），在java编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。 接口与类的区别: 接口不能用于实例化对象 接口没有构造方法 接口中所有的方法都必须是抽象方法 接口不能包含成员变量，除了static，final变量 接口不是被类继承了，而是要被类实现 接口支持多继承 接口特性 接口是隐式抽象的，当声明一个接口时，不必使用abstract关键字 接口中的每一个方法也是隐式抽象的，所有字段是隐式的public static final，因此没必要在接口内部指定访问说明符 接口实现和抽象类一样，无法创建接口的对象。可以使用implements关键字来实现接口 12345678910111213141516interface polygon &#123; void getarea(int length, int breadth);&#125;class rectangle implements polygon &#123; public void getarea(int length, int breadth) &#123; system.out.println(&quot;the area is: &quot; + length * breadth); &#125;&#125;public class main &#123; public static void main(string[] args) &#123; rectangle r1 = new rectangle(); r1.getarea(10, 20); &#125;&#125; 接口中的私有方法和静态方法与类相似，可以使用其引用访问接口的静态方法 1polygon.staticmethod(); 接口中的默认方法要在接口内使用默认方法，可以使用default关键字 123public default void getside() &#123; // do something...&#125; 具体实现 1234567891011121314151617181920212223242526272829303132333435363738import java.lang.math;interface polygon &#123; void getarea(); default void getperimeter(int... sides) &#123; int perimeter = 0; for (int side : sides) &#123; perimeter += side; &#125; system.out.println(&quot;the total sides is: &quot; + perimeter); &#125;&#125;class trangle implements polygon &#123; private int a, b, c; private double s, area; trangle(int a, int b, int c) &#123; this.a = a; this.b = b; this.c = c; s = 0; &#125; public void getarea() &#123; s = (double) (a + b + c) / 2; area = math.sqrt(s * (s - a) * (s - b) * (s - c)); system.out.println(&quot;the area is: &quot; + area); &#125;&#125;public class main &#123; public static void main(string[] args) &#123; trangle t1 = new trangle(2 , 3, 4); t1.getarea(); t1.getperimeter(2 , 3 , 4); &#125;&#125; 接口与extends关键字接口可以继承其他接口 12345678interface line &#123;&#125;interface polygon extends line &#123;&#125; 注意一个接口可以继承多个接口 12345678910111213interface a &#123;&#125;interface b &#123;&#125;interface c extends a, b &#123;&#125; java抽象类和抽象方法抽象类java抽象类是无法实例化的类，使用abstract声明 123abstract class animal &#123; // doing something...&#125; 抽象方法依然使用abstract关键字来创建抽象方法 1abstract void makesound(); 抽象类的继承123456789101112131415abstract class animal &#123; public void displayinfo() &#123; system.out.println(&quot;i am a animal&quot;); &#125;&#125;class dog extends animal &#123;&#125;public class main &#123; public static void main(string[] args) &#123; dog d1 = new dog(); d1.displayinfo(); &#125;&#125; 输出如下 1i am a animal 重写抽象方法在java中，必须在子类重写父类的抽象方法。如果子类也被声明为抽象，则不必强制重写抽象方法 1234567891011121314151617181920abstract class animal &#123; abstract void makesound(); public void eat() &#123; system.out.println(&quot;i can eat...&quot;); &#125;&#125;class dog extends animal &#123; public void makesound() &#123; system.out.println(&quot;barking...&quot;); &#125;&#125;public class main &#123; public static void main(string[] args) &#123; dog d1 = new dog(); d1.eat(); d1.makesound(); &#125;&#125; 访问抽象类的构造函数依旧使用super()关键字访问父类 12345678910111213abstract class animal &#123; animal() &#123; // doing something... &#125;&#125;class dog extends animal &#123; dog() &#123; super(); &#125;&#125; java抽象实例1234567891011121314151617181920212223242526272829303132333435abstract class animal &#123; abstract void makesound();&#125;class dog extends animal &#123; public void makesound() &#123; system.out.println(&quot;barking...&quot;); &#125;&#125;class cat extends animal &#123; public void makesound() &#123; system.out.println(&quot;meows...&quot;); &#125;&#125;public class main &#123; public static void test(animal... ani) &#123; if(ani.length &lt;= 0) &#123; return; &#125; for(animal val : ani) &#123; val.makesound(); &#125; &#125; public static void main(string[] args) &#123; dog d1 = new dog(); cat c1 = new cat(); test(d1, c1); &#125;&#125; 总结 为了实现抽象类的功能，我们从其继承子类并创建该子类的对象。 类必须重写抽象类的所有抽象方法。但是，如果子类被声明为抽象的，则不必强制重写抽象方法。 嵌套静态类与常规类一样，静态嵌套类可以同时包含静态和非静态方法 12345class animal &#123; static class mammal &#123; &#125;&#125; 例子 1234567891011121314151617181920212223242526272829class animal &#123; // 内部类 class reptile &#123; public void displayinfo() &#123; system.out.println(&quot;i am a reptile...&quot;); &#125; &#125; // 静态类 static class mammal &#123; public void displayinfo() &#123; system.out.println(&quot;i am a mammal...&quot;); &#125; &#125;&#125;public class main &#123; public static void main(string[] args) &#123; //创建外部类对象 animal ani = new animal(); //非静态类的对象创建 animal.reptile rep = ani.new reptile(); rep.displayinfo(); //静态嵌套类的对象创建 animal.mammal ma = new animal.mammal(); ma.displayinfo(); &#125;&#125; 在上面的实例中关于非静态类reptile的创建，使用 1animal.reptile rep = ani.new reptile(); 关于静态类mammal的创建，使用 1animal.mammal ma = new animal.mammal(); 访问外部类的成员静态嵌套类只能访问外部类的成员（静态字段和方法） 示例：访问非静态成员 123456789101112131415161718192021222324252627282930313233class animal &#123; // 内部类 class reptile &#123; public void displayinfo() &#123; system.out.println(&quot;i am a reptile...&quot;); &#125; &#125; // 静态类 static class mammal &#123; public void displayinfo() &#123; system.out.println(&quot;i am a mammal...&quot;); &#125; &#125; public void eat() &#123; system.out.println(&quot;eating...&quot;); &#125;&#125;public class main &#123; public static void main(string[] args) &#123; //创建外部类对象 animal ani = new animal(); //非静态类的对象创建 animal.reptile rep = ani.new reptile(); rep.displayinfo(); //静态嵌套类的对象创建 animal.mammal ma = new animal.mammal(); ma.displayinfo(); ma.eat(); &#125;&#125; 12345/home/encounter/code/java/learning/src/main.java:31:11java: 找不到符号 符号: 方法 eat() 位置: 类型为animal.mammal的变量 ma 在上面的实例中，animal类中创建了一个非静态的方法eat()，由于ma是静态类的对象，因此无法从静态类访问非静态方法 静态顶级类只有嵌套类可以是静态的，不能有静态的顶级类 1234567891011static class animal &#123; public void displayinfo() &#123; system.out.println(&quot;i am an animal&quot;); &#125;&#125;public class main &#123; public static void main(string[] args) &#123; animal.displayinfo(); &#125;&#125; 12/home/encounter/code/java/learning/src/main.javajava: 此处不允许使用修饰符static 匿名类在java中，一个类可以包含另一个称为嵌套类的类。可以在不提供任何名称的情况下创建嵌套类。 没有任何名称的嵌套类成为匿名类 必须在另一个类定一个匿名类，因此也被成为匿名内部类 123456class outerclass &#123; // define object1 = new type(paramenterlist) &#123; // doing something... &#125;;&#125; 匿名类通常继承子类或实现接口在这里, **类型(type)**可以是 匿名类继承的父类 匿名实现的接口 实例：匿名内部类继承类 12345678910111213141516171819202122232425class polygon &#123; public void display() &#123; system.out.println(&quot;in class of polygon&quot;); &#125;&#125;class anonymousdemo &#123; public void createclass() &#123; // 创建匿名类，继承类polygon polygon p1 = new polygon() &#123; public void display() &#123; system.out.println(&quot;in class of anonymousdemo&quot;); &#125; &#125;; p1.display(); &#125;&#125;public class main &#123; public static void main(string[] args) &#123; anonymousdemo any = new anonymousdemo(); any.createclass(); &#125;&#125; 输出 1in class of anonymousdemo 在上面的实例中，创建了一个类polygon，只有一个方法display()，然后创建了一个匿名类，该类继承类polygon并重写了display()方法，在运行时，将创建一个类p1,然后调用p1的display()方法 实例：实现接口的匿名类 123456789101112131415161718192021interface polygon &#123; public void display();&#125;class anonymousdemo &#123; public void createclass() &#123; polygon p1 = new polygon() &#123; public void display() &#123; system.out.println(&quot;in class of anonymousdemo&quot;); &#125; &#125;; p1.display(); &#125;&#125;public class main &#123; public static void main(string[] args) &#123; anonymousdemo any = new anonymousdemo(); any.createclass(); &#125;&#125; 输出 12in class of anonymousdemo 匿名类的优点在匿名类中，只需要创建对象。即创建对象执行某些任务 12345object = new example() &#123; public void display() &#123; system.out.println(&quot;overwrite display()&quot;); &#125;&#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]}],"categories":[{"name":"考研","slug":"考研","permalink":"http://example.com/categories/%E8%80%83%E7%A0%94/"},{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"工具","slug":"工具","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"408","slug":"408","permalink":"http://example.com/tags/408/"},{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"docker","slug":"docker","permalink":"http://example.com/tags/docker/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"},{"name":"QT","slug":"QT","permalink":"http://example.com/tags/QT/"},{"name":"网络编程","slug":"网络编程","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"socket","slug":"socket","permalink":"http://example.com/tags/socket/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"protobuf","slug":"protobuf","permalink":"http://example.com/tags/protobuf/"},{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"并发编程","slug":"并发编程","permalink":"http://example.com/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"函数式编程","slug":"函数式编程","permalink":"http://example.com/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"name":"软路由","slug":"软路由","permalink":"http://example.com/tags/%E8%BD%AF%E8%B7%AF%E7%94%B1/"},{"name":"调试","slug":"调试","permalink":"http://example.com/tags/%E8%B0%83%E8%AF%95/"},{"name":"面向对象","slug":"面向对象","permalink":"http://example.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]}